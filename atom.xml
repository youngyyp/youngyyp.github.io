<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>young&#39;s blog</title>
  
  <subtitle>慢慢来，比较快</subtitle>
  <link href="https://youngyyp.github.io/atom.xml" rel="self"/>
  
  <link href="https://youngyyp.github.io/"/>
  <updated>2023-05-31T02:43:26.413Z</updated>
  <id>https://youngyyp.github.io/</id>
  
  <author>
    <name>young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnext-29%E7%BB%93%E6%9E%84/"/>
    <id>https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnext-29%E7%BB%93%E6%9E%84/</id>
    <published>2023-05-31T02:43:26.405Z</published>
    <updated>2023-05-31T02:43:26.413Z</updated>
    
    <content type="html"><![CDATA[<p>CifarResNeXt(<br>  (conv_1_3x3): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>  (bn_1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>  (stage_1): Sequential(<br>    (0): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (downsample): Sequential(<br>        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      )<br>    )<br>    (1): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>    (2): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(128, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>  )<br>  (stage_2): Sequential(<br>    (0): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(256, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (downsample): Sequential(<br>        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      )<br>    )<br>    (1): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>    (2): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(256, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>  )<br>  (stage_3): Sequential(<br>    (0): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(512, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (downsample): Sequential(<br>        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      )<br>    )<br>    (1): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>    (2): ResNeXtBottleneck(<br>      (conv_reduce): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_reduce): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_conv): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=4, bias=False)<br>      (bn): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>      (conv_expand): Conv2d(512, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      (bn_expand): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    )<br>  )<br>  (avgpool): AvgPool2d(kernel_size=8, stride=8, padding=0)<br>  (classifier): Linear(in_features=1024, out_features=100, bias=True)<br>)</p><p>gaussian_noise<br>Epoch 1/1 (12s):        error: 39.90        mean_entropy: 1.3898<br>shot_noise<br>Epoch 1/1 (8s):         error: 33.59        mean_entropy: 1.0661<br>impulse_noise<br>Epoch 1/1 (8s):         error: 36.14        mean_entropy: 1.1230<br>defocus_blur<br>Epoch 1/1 (8s):         error: 27.31        mean_entropy: 0.7297<br>glass_blur<br>Epoch 1/1 (8s):         error: 37.69        mean_entropy: 1.0774<br>motion_blur<br>Epoch 1/1 (8s):         error: 28.11        mean_entropy: 0.7344<br>zoom_blur<br>Epoch 1/1 (8s):         error: 25.42        mean_entropy: 0.6851<br>snow<br>Epoch 1/1 (8s):         error: 31.37        mean_entropy: 0.8447<br>frost<br>Epoch 1/1 (8s):         error: 30.67        mean_entropy: 0.8091<br>fog<br>Epoch 1/1 (8s):         error: 36.76        mean_entropy: 0.9701<br>brightness<br>Epoch 1/1 (8s):         error: 24.66        mean_entropy: 0.6118<br>contrast<br>Epoch 1/1 (8s):         error: 28.08        mean_entropy: 0.6770<br>elastic_transform<br>Epoch 1/1 (8s):         error: 32.25        mean_entropy: 0.8842<br>pixelate<br>Epoch 1/1 (8s):         error: 27.83        mean_entropy: 0.7012<br>jpeg_compression<br>Epoch 1/1 (8s):         error: 36.49        mean_entropy: 0.9407<br>[23/05/22 15:55:41] [cifar100c_online_adapter.py:  143]: mean error %: 31.7513%</p>]]></content>
    
    
    <summary type="html">CifarResNeXt(
(conv_1_3x3): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
(bn_1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
(stage_1): Sequential(
(0): ResNeXtBottleneck(
(conv_reduce): Conv2d(64, 128, kernel_size=(1, 1), stride=(1</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet50-imagenet/"/>
    <id>https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet50-imagenet/</id>
    <published>2023-05-31T02:43:25.526Z</published>
    <updated>2023-05-31T02:43:25.562Z</updated>
    
    <content type="html"><![CDATA[<p>Sequential(<br>  (normalize): ImageNormalizer(mean=tensor([0.4850, 0.4560, 0.4060], device=’cuda:0’), std=tensor([0.2290, 0.2240, 0.2250], device=’cuda:0’))<br>  (model): ResNet(<br>    (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)<br>    (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>    (relu): ReLU(inplace=True)<br>    (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)<br>    (layer1): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>        (downsample): Sequential(<br>          (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>          (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>    )<br>    (layer2): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>        (downsample): Sequential(<br>          (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (3): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>    )<br>    (layer3): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>        (downsample): Sequential(<br>          (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (3): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (4): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (5): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>    )<br>    (layer4): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>        (downsample): Sequential(<br>          (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)<br>        (relu): ReLU(inplace=True)<br>      )<br>    )<br>    (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))<br>    (fc): Linear(in_features=2048, out_features=1000, bias=True)<br>  )<br>)</p>]]></content>
    
    
    <summary type="html">Sequential(
(normalize): ImageNormalizer(mean=tensor([0.4850, 0.4560, 0.4060], device=’cuda:0’), std=tensor([0.2290, 0.2240, 0.2250], device=’cuda:0’))
(model): ResNet(
(conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
(bn1): BatchNorm2d(64, eps=1e-05, momentum=0.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83/"/>
    <id>https://youngyyp.github.io/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83/</id>
    <published>2023-05-31T02:43:25.523Z</published>
    <updated>2023-05-31T02:43:25.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迁移学习代码示例"><a href="#迁移学习代码示例" class="headerlink" title="迁移学习代码示例"></a><a href="https://zhuanlan.zhihu.com/p/454614578">迁移学习代码示例</a></h2><pre class=" language-lang-python3"><code class="language-lang-python3"> def _freeze_stages(self): # 我们知道BN层比较特殊，它的gamma和beta是可学习参数，由requires_grad控制；mean和std是可更新参数，由eval()和train()方法控制 # 所以固定权重需要两步：eval模式，使得bn固定；requires_grad=False不计算梯度        if self.frozen_stages >= 0: # 为0的话就是stem（deep_stem为True）或者conv1与norm1            if self.deep_stem:                self.stem.eval()                for param in self.stem.parameters():                    param.requires_grad = False            else:                self.norm1.eval()                for m in [self.conv1, self.norm1]:                    for param in m.parameters():                        param.requires_grad = False        for i in range(1, self.frozen_stages + 1):            m = getattr(self, f'layer{i}')            m.eval()            for param in m.parameters():                param.requires_grad = False</code></pre><ul><li><strong>init_weights</strong>：初始化参数</li></ul><pre class=" language-lang-python3"><code class="language-lang-python3">    def init_weights(self, pretrained=None):        if isinstance(pretrained, str):            logger = get_root_logger()            load_checkpoint(self, pretrained, strict=False, logger=logger) # load预训练模型如torchvision//resnet        elif pretrained is None:            for m in self.modules():                if isinstance(m, nn.Conv2d):                    kaiming_init(m) # 以何凯明命名的初始化                elif isinstance(m, (_BatchNorm, nn.GroupNorm)):                    constant_init(m, 1) # constant_init 对weight初始化为1，bias默认为0            if self.dcn is not None:                for m in self.modules():                    if isinstance(m, Bottleneck) and hasattr(m.conv2, 'conv_offset'):                        constant_init(m.conv2.conv_offset, 0)            if self.zero_init_residual:            # 之前介绍过，预训练的小技巧，把最后一个BN的gamma和beta设置为0                for m in self.modules():                    if isinstance(m, Bottleneck):                        constant_init(m.norm3, 0)                    elif isinstance(m, BasicBlock):                        constant_init(m.norm2, 0)        else:            raise TypeError('pretrained must be a str or None')</code></pre><ul><li><strong>train：</strong>必须要重写train方法！否则初始化时调用了self._freeze_stages()，但是在runner里面，会进行train模式，那么_freeze_stages作用就没有了。</li></ul><pre class=" language-lang-python3"><code class="language-lang-python3">    def train(self, mode=True):        super(ResNet, self).train(mode)        self._freeze_stages()         if mode and self.norm_eval: # norm_eval，是否在训练时保持norm的mean和std不变            for m in self.modules():                 # trick: eval have effect on BatchNorm only                if isinstance(m, _BatchNorm):                    m.eval()</code></pre>]]></content>
    
    
    <summary type="html">迁移学习代码示例
 def _freeze_stages(self):
 # 我们知道BN层比较特殊，它的gamma和beta是可学习参数，由requires_grad控制；mean和std是可更新参数，由eval()和train()方法控制
 # 所以固定权重需要两步：eval模式，使得bn固定；requires_grad=False不计算梯度
        if self.frozen_stages &amp;gt;= 0: # 为0的话就是stem（deep_stem为True）或者conv1与norm1
            if self.deep_stem:
                </summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95/"/>
    <id>https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95/</id>
    <published>2023-05-30T13:04:38.238Z</published>
    <updated>2023-06-05T10:54:28.855Z</updated>
    
    <content type="html"><![CDATA[<p>一面很顺畅，手撕简单题</p><p>主管面挂，一直揪着我性格测试时焦虑指数过高这一条来说</p>]]></content>
    
    
    <summary type="html">一面很顺畅，手撕简单题

主管面挂，一直揪着我性格测试时焦虑指数过高这一条来说</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E8%81%94%E6%83%B3%E9%9D%A2%E8%AF%95/"/>
    <id>https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E8%81%94%E6%83%B3%E9%9D%A2%E8%AF%95/</id>
    <published>2023-05-30T13:04:37.185Z</published>
    <updated>2023-05-30T13:04:37.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="联想"><a href="#联想" class="headerlink" title="联想"></a>联想</h2><p>4/6投递</p><p>4/17面试 </p><p><a href="https://talent.lenovo.com.cn/position/detail?id=1030">https://talent.lenovo.com.cn/position/detail?id=1030</a></p><p><img src="/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E8%81%94%E6%83%B3%E9%9D%A2%E8%AF%95/image-20230406152835099.png" alt="image-20230406152835099"></p><p>面试官特别和蔼（姓包？）</p><p>感觉不怎么懂技术，问的问题都很简单，而且我不管怎么答都说很好</p><p>还问我家是哪的</p><p>全程就讲了二十几分钟，还是我自己主动多讲了几个项目才这么久</p><p>而且只有一面，说非常欢迎我来</p><p>去了做自动驾驶相关的内容</p><p>以及将一些最新的方法部署到TI平台或者</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MDYzNzg4Mw==&amp;mid=2247532097&amp;idx=3&amp;sn=ced9900155701446e3c56bf4b9fc4af0&amp;chksm=ebb74695dcc0cf834e50100189376506c185a2be7978b14da01f0b2fe798ac39daa4a8c81c03&amp;scene=27">transformer面试题的简单回答 (qq.com)</a></p><p><a href="https://www.rstk.cn/news/38666.html?action=onClick">Transformer面试常见问题总结 (rstk.cn)</a></p><p>简要介绍一下transformer：</p><p>Transfomer是一种基于注意力机制的神经网络模型。Transformer模型由编码器和解码器两部分组成，其中编码器用于将输入序列编码成一个高维向量表示，解码器用于将这个向量表示解码成目标序列。Transformer模型最核心的部分是自注意力机制，它能够让模型在不同位置之间进行信息传递和交互，从而更好地学习输入序列中的信息。</p><p>4/18 收到offer call</p>]]></content>
    
    
    <summary type="html">联想
4/6投递

4/17面试 

https://talent.lenovo.com.cn/position/detail?id=1030



面试官特别和蔼（姓包？）

感觉不怎么懂技术，问的问题都很简单，而且我不管怎么答都说很好

还问我家是哪的

全程就讲了二十几分钟，还是我自己主动多讲了几个项目才这么久

而且只有一面，说非常欢迎我来

去了做自动驾驶相关的内容

以及将一些最新的方法部署到TI平台或者

transformer面试题的简单回答 (qq.com)

Transformer面试常见问题总结 (rstk.cn)

简要介绍一下transformer：

Transfo</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/"/>
    <id>https://youngyyp.github.io/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/</id>
    <published>2023-05-30T13:04:34.499Z</published>
    <updated>2023-05-30T13:04:34.531Z</updated>
    
    <content type="html"><![CDATA[<h4 id="池化层是怎么进行反向传播的-最大池化-平均池化"><a href="#池化层是怎么进行反向传播的-最大池化-平均池化" class="headerlink" title="池化层是怎么进行反向传播的 最大池化 平均池化"></a>池化层是怎么进行反向传播的 最大池化 平均池化</h4><p>1、平均池化的反向传播<br>mean pooling的前向传播就是把一个patch中的值求取平均来做pooling，那么反向传播的过程也就是把某个元素的梯度等分为n份分配给前一层，这样就保证池化前后的梯度（残差）之和保持不变，还是比较理解的，图示如下 ：</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/resize,m_fixed,w_1184.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_面试_15"></p><p>2、最大池化的反向传播<br>反向传播也就是把梯度直接传给前一层某一个像素，而其他像素不接受梯度，也就是为0</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/resize,m_fixed,w_1184-16838108349864.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_激活函数_16"></p>]]></content>
    
    
    <summary type="html">池化层是怎么进行反向传播的 最大池化 平均池化
1、平均池化的反向传播
mean pooling的前向传播就是把一个patch中的值求取平均来做pooling，那么反向传播的过程也就是把某个元素的梯度等分为n份分配给前一层，这样就保证池化前后的梯度（残差）之和保持不变，还是比较理解的，图示如下 ：



2、最大池化的反向传播
反向传播也就是把梯度直接传给前一层某一个像素，而其他像素不接受梯度，也就是为0</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95/"/>
    <id>https://youngyyp.github.io/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95/</id>
    <published>2023-05-30T13:04:22.996Z</published>
    <updated>2023-05-30T13:04:23.023Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/05/30/work/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95/image-20230423101014585.png" alt="image-20230423101014585"></p><p>他们主要做搜广推</p><p>但是也会考虑其他做cv/nlp的人，因为做搜广推的人太少了</p><p>所以很看重对知识点思考的深度和广度，反而不怎么看重以前做的项目（因为都不对口）</p><p>项目中用了l2loss，面试官说这不是mse loss吗？ 我说l2不就是mse吗？面试官坚持说不是。。。。离谱</p><p>问了很多transformer的内容，以及项目中的网络结构的细节</p><p>说我广度和深度都还不够</p><p>考了一道题目，用代码写交叉熵函数及其导数，求梯度直接用的data.grad，面试官说不能直接调包</p><p>一面挂</p><p>需要补充的知识：<br>    unet具体结构、transformer相关知识点、bn层具体操作、交叉熵求导</p>]]></content>
    
    
    <summary type="html">他们主要做搜广推

但是也会考虑其他做cv/nlp的人，因为做搜广推的人太少了

所以很看重对知识点思考的深度和广度，反而不怎么看重以前做的项目（因为都不对口）

项目中用了l2loss，面试官说这不是mse loss吗？ 我说l2不就是mse吗？面试官坚持说不是。。。。离谱

问了很多transformer的内容，以及项目中的网络结构的细节

说我广度和深度都还不够

考了一道题目，用代码写交叉熵函数及其导数，求梯度直接用的data.grad，面试官说不能直接调包

一面挂

需要补充的知识：
unet具体结构、transformer相关知识点、bn层具体操作、交叉熵求导</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://youngyyp.github.io/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-05-30T13:04:22.537Z</published>
    <updated>2023-05-30T13:04:22.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>能够适应大数据，泛化性更强（transformer上限高，cnn下限高）</p><p>全局感受野</p><p>更好的处理序列数据能力</p><p>并行计算能力</p><p>更容易扩展到其他任务</p><p>缺点：</p><p>没有平移、缩放、形变的不变性（CNN存在归纳偏置，局部性和平移等变性）</p><p>CNN有强归纳偏置性,所以在小数据集上表现更好。但如果有大量的数据可用,CNN的强归纳偏置性反而会限制模型的能力</p><h3 id="卷积的平移等变性："><a href="#卷积的平移等变性：" class="headerlink" title="卷积的平移等变性："></a>卷积的平移等变性：</h3><p><strong>卷积+最大池化等于平移等变性</strong>。</p><p>卷积：简单地说，<strong>图像经过平移，相应的特征图上的表达也是平移的。</strong>输入图像的左下角有一个人脸，经过卷积，人脸的特征（眼睛，鼻子）也位于特征图的左下角</p><p>池化：比如最大池化，它返回感受野中的最大值，<strong>如果最大值被移动了，但是仍然在这个感受野中</strong>，那么池化层也仍然会输出相同的最大值。这就有点平移不变的意思了。</p><h4 id="也有论文认为cnn不具备平移等变性："><a href="#也有论文认为cnn不具备平移等变性：" class="headerlink" title="也有论文认为cnn不具备平移等变性："></a>也有论文认为cnn不具备平移等变性：</h4><p>论文地址：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1805.12177.pdf">arxiv.org/pdf/1805.12177.pdf</a></p><p>希伯来大学的Ah<a href="https://link.zhihu.com/?target=https%3A//www.jqr.com/service/company%3Fbusiness%3D17">ar</a>on Azulay和Yair Weiss近期发表的<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1805.12177.pdf">Why do deep convolutional networks generalize so poorly to small image transformations?</a> 这篇文章发现当小尺寸图像发生平移后，CNN会出现识别错误的现象，而且这一现象是普遍的。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Transformer采用Encoder-Decoder架构，N一般取6</p><p><strong>encoder</strong>主要包括self-attention和前馈网络两个模块，每个模块之后还会加上残差连接和layernorm</p><p>attention本质上就是通过加权求和获得对上下文的全局感知，qk计算权重，再乘以v嵌入上下文信息</p><p>每个向量的q 和 所有向量的k 相乘得到的权重就是attention，用softmax过滤掉不相干的单词，乘以v向量进行加权求和</p><p>encoder基本结构：Embedding + Position Embedding，Self-Attention，Add + LN，FN，Add + LN</p><p><strong>decoder</strong>主要包括masked multihead attention(self-attention)、encoder-decoder attention(cross attention) 和 feed forward network三个模块，每个模块之后还会加上残差连接和layernorm</p><p>encoder-decoder attention不仅考虑已经翻译的内容，还要考虑encoder中上下文的信息。解码器的输出经过线性层和softmax层，得到输出</p><p>每个self-attention又会分解成几个部分，称为multi-head self-attention（通常8头），在这之中使用了不同的权重矩阵qkv进行了8次计算，这样做的目的是为了消除QKV初始值的影响（一件事找八个人做，万一哪个不靠谱也不影响）</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426094514229.png" alt="image-20230426094514229" style="zoom:50%;"></p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095027000.png" alt="image-20230426095027000" style="zoom:50%;"></p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095826505.png" alt="image-20230426095826505" style="zoom: 33%;"></p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095902928.png" alt="image-20230426095902928" style="zoom: 33%;"></p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426100259964.png" alt="image-20230426100259964" style="zoom:50%;"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer">很好的讲解transformer的文章</a></p><h2 id="常见八股"><a href="#常见八股" class="headerlink" title="常见八股"></a>常见八股</h2><p>1.Transformer为何使用多头注意力机制？（为什么不使用一个头）</p><ul><li>Transformer使用多头注意力机制是为了增强模型的表达能力，可以让模型在不同的表征空间内学习到不同的特征表示。如果只使用一个头，模型就只能学习到单一的特征表示，而无法利用多个空间内的特征信息。</li><li>通俗来说就是从多个方面来进行理解</li></ul><p>2.Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？ （注意和第一个问题的区别）</p><ul><li><p>简单回答就是，使用Q/K/V不相同可以保证在不同空间进行投影，增强了表达能力，提高了泛化能力。</p></li><li><p><em>q</em>就是query，k就是key，v就是value，(k,v)就是键值对、也就是用query关键词去找到最相关的检索结果</p></li><li><p>Q和K使用不同的权重矩阵生成是因为它们的含义不同。Q是查询向量，K是键向量，它们代表了不同的信息，因此使用不同的权重矩阵可以让它们学习不同的表示。</p></li></ul><p>3.Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？</p><ul><li>Transformer计算attention时选择点乘而不是加法，是因为点乘可以反映不同向量之间的相似度，更好地捕捉到语义信息的相关性。而加法只是简单地把两个向量相加，不能反映语义信息的相关性。从计算复杂度和效果上看，点乘更适合文本序列的处理。</li></ul><p>4.为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根），并使用公式推导进行讲解</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230511101521508.png" alt="image-20230511101521508" style="zoom:50%;"></p><ul><li><p><a href="https://blog.csdn.net/jokerxsy/article/details/116299343">Transformer中的attention为什么要做scale？</a></p></li><li><p>一句话：</p></li><li><p><strong>如果不对softmax的输入做缩放，那么万一输入的数量级很大，输出会趋向1，softmax的梯度就会趋向于0，导致梯度消失。</strong>假设 Q 和 K 的均值为0，方差为1。它们的矩阵乘积将有均值为0，方差为<script type="math/tex">d_k</script>。方差越大，就有更可能取到很大的值，所以我们除以dk的平方根，使其方差为1。</p></li></ul><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pva2VyeHN5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>5.在计算attention score的时候如何对padding做mask操作？</p><ul><li><p><strong>Padding Mask</strong></p><p>  什么是padding mask呢？因为每个批次输入序列长度是不一样的也就是说，我们要对输入序列进行对齐。具体来说，就是给在较短的序列后面填充0。但是如果输入的序列太长，则是截取左边的内容，把多余的直接舍弃。因为这些填充的位置，其实是没什么意义的，所以我们的Attention机制不应该把注意力放在这些位置上，所以我们需要进行一些处理。</p><p>  具体的做法是，<strong>把这些位置的值加上一个非常大的负数(负无穷)，这样的话，经过softmax，这些位置的概率就会接近0</strong>！ 而我们的padding mask 实际上是一个张量，每个值都是一个Boolean，值为false的地方就是我们要进行处理的地方</p></li><li><p><strong>Sequence mask</strong></p><p>  文章前面也提到，sequence mask是为了使得Decoder不能看见未来的信息。也就是对于一个序列，在time_step为t的时刻，我们的解码输出应该只能依赖于t时刻之前的输出，而不能依赖t之后的输出。因此我们需要想一个办法，把t之后的信息给隐藏起来。 那么具体怎么做呢？也很简单：产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p><p>  sequence mask的目的是防止Decoder “seeing the future”，就像防止考生偷看考试答案一样。这里mask是一个下三角矩阵，对角线以及对角线左下都是1，其余都是0。下面是个10维度的下三角矩阵：</p><p>  [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]</p></li></ul><p>6.为什么在进行多头注意力的时候需要对每个head进行降维？（可以参考上面一个问题）</p><ul><li>借鉴CNN多核的思想，在更低的维度，在多个独立的特征空间，更容易学习到更丰富的特征信息。</li><li>将原有的高维空间转化为多个低维空间并再最后进行拼接，形成同样维度的输出，借此丰富特性信息，降低了计算量</li></ul><p>7.大概讲一下Transformer的Encoder模块？</p><ul><li><strong>encoder</strong>主要包括self-attention和前馈网络两个模块，每个模块之后还会加上残差连接和layernorm</li></ul><p>8.为何在获取输入词向量之后需要对矩阵乘以embedding size的开方？意义是什么？</p><ul><li><p>对矩阵乘以embedding size的开方是为了将词向量的scale调整到合适的范围，避免过大或过小的梯度对模型的训练产生影响。</p></li><li><p>embedding matrix的初始化方式是xavier init，这种方式的方差是1/embedding size，因此乘以embedding size的开方使得embedding matrix的方差是1，在这个scale下可能更有利于embedding matrix的收敛。</p></li></ul><p>9.简单介绍一下Transformer的位置编码？有什么意义和优缺点？</p><ul><li><p>因为self-attention是位置无关的，无论句子的顺序是什么样的，通过self-attention计算的token的hidden embedding都是一样的，这显然不符合人类的思维。因此要有一个办法能够在模型中表达出一个token的位置信息，transformer使用了固定的positional encoding来表示token在句子中的绝对位置信息。</p></li><li><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512112447304.png" alt="image-20230512112447304" style="zoom:50%;"></p></li><li><p>理解transformer的作者为什么设计这样的编码方式来生成位置向量呢? 因为三角函数有个性质</p><p>  ​          sin(a+b) = sin(a) <em> cos(b) + cos(a) </em> sin(b)</p><p>  ​         cos(a+b) = cos(a) <em> cos(b) - sin(a) </em> sin(b)</p><p>   因此可以推导出，两个位置向量的点积是一个与他们两个位置差值（即相对位置）有关，而与绝对位置无关。这个性质使得在计算注意力权重的时候(两个向量做点积)，使得相对位置对注意力发生影响，而不是绝对位置，这更符合常理。</p></li></ul><p>10.<strong>你还了解哪些关于位置编码的技术，各自的优缺点是什么？</strong></p><ul><li><p>相对位置编码（RPE）</p><p>  1.在计算attention score和weighted value时各加入一个可训练的表示相对位置的参数。</p><p>  2.在生成多头注意力时，把对key来说将绝对位置转换为相对query的位置</p><p>  3.复数域函数，已知一个词在某个位置的词向量表示，可以计算出它在任何位置的词向量表示。前两个方法是词向量+位置编码，属于亡羊补牢，复数域是生成词向量的时候即生成对应的位置信息。</p></li></ul><p>11.简单讲一下Transformer中的残差结构以及意义。</p><ul><li><p>encoder和decoder的self-attention层和ffn层都有残差连接</p></li><li><p>反向传播的时候不会造成梯度消失。</p></li><li><p>残差网络与普通网络不同的地方就是引入了跳连接,这可以使上一个残差块的信息没有阻碍的流入到下一个残差块,提高了信息流通,并且也避免了由与网络过深所引起的消失梯度问题和退化问题。</p></li><li><p>残差链接的方式：</p><p>  H(x)=F(x)+x 通道相同，所以采用计算方式为H(x)=F(x)+x</p><p>  H(x)=F(x)+x  通道不同，采用的计算方式为H(x)=F(x)+Wx，其中W是卷积操作，用来调整x维度的。</p></li></ul><p>12.为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm 在Transformer的位置是哪里？</p><p>layernorm的<script type="math/tex">x_i</script> 是样本内，bn是样本间</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512103216297.png" alt="image-20230512103216297" style="zoom:50%;"></p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512103229670.png" alt="image-20230512103229670" style="zoom:50%;"></p><ul><li>LN：针对每个样本序列进行求均值和方差，归一化到正态分布后再缩放到合适的均值和方差，没有样本间的依赖。位置在每个Atention和FFN后。</li><li>CV使用BN是认为channel维度的信息对cv方面有重要意义，如果对channel维度也归一化会造成不同通道信息一定的损失。而同理nlp领域认为句子长度不一致，并且各个batch的信息没什么关系，因此只考虑句子内信息的归一化，也就是LN。</li></ul><p>13.简单讲一下BatchNorm技术，以及它的优缺点。</p><p><a href="https://blog.csdn.net/Icanhearwawawa/article/details/123347946">【面试总结】BN的利弊</a></p><ul><li><p>BN优点：</p><ul><li>第一个就是可以<strong>解决内部协变量偏移</strong>，简单来说训练过程中，各层分布不同，增大了学习难度，BN缓解了这个问题。</li><li>BN 层通常设置在激活函数之前。BN层的作用机制是对隐藏层输入的分布进行平滑，缓解随机梯度下降权重更新对后续层的负面影响。对sigmoid和tanh而言，放非线性激活之前，能缓解sigmoid或者 tanh的<strong>梯度衰减</strong>问题，而对ReLU而言，BTTA相关实验结果和代码N放到relu之前，可以防止某一层的激活值全部都被抑制，从而防止从这一层往前传的梯度全都变成０，也就是防止<strong>梯度消失</strong>。（当然也可以防止<strong>梯度爆炸</strong>）</li></ul></li><li><p>BN缺点：</p><ul><li>第一个，batch_size较小的时候，效果差。</li><li>第二个缺点就是 BN 在NLP中效果不好，因为文本的输入长度是动态的。</li><li>在测试阶段若出现样本长度超过训练集的最大长度，则无法处理，需要对样本进行截断</li><li>测试阶段的均值和方差的计算可能与训练集的相差较大</li></ul></li></ul><p>14.简单描述一下Transformer中的前馈神经网络？使用了什么激活函数？相关优缺点？</p><p>就是全连接层加残差连接和LN  </p><p>使用的激活函数是ReLU()</p><p><a href="https://dandelioncloud.cn/article/details/1473009113708978178/">深度神经网络中常用的激活函数的优缺点分析</a></p><p>15.Encoder端和Decoder端是如何进行交互的？（在这里可以问一下关于seq2seq的attention知识）</p><p><img src="/2023/05/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/resize,m_fixed,w_1184.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_面试_03"></p><ul><li>Cross Self-Attention，Decoder提供Q，Encoder提供K，V</li><li>Encoder端和Decoder端通过attention机制进行交互，在Encoder端中，每个时间步都会计算一个attention向量，然后将其与输入向量相加得到新的向量；在Decoder端中，除了计算attention向量外还需要计算一个mask向量来避免模型看到未来的信息</li></ul><p>16.Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？（为什么需要decoder自注意力需要进行 sequence mask)</p><ul><li>Decoder阶段的多头自注意力和encoder的多头自注意力最大的区别就是decoder自注意力需要进行sequence mask来避免模型看到未来信息</li></ul><p>17.Transformer的并行化体现在哪个地方？Decoder端可以做并行化吗？</p><ul><li><p>Transformer的并行化我认为主要体现在self-attention模块，在Encoder端Transformer可以并行处理整个序列，并得到整个输入序列经过Encoder端的输出。因为单词之间没有依赖关系，不需要先输入前一个单词再输入下一个，可以同时输入所有单词。</p></li><li><p>Decode引入sequence mask就是为了并行化训练，推理过程不并行。 Transformer的Decoder部分，引入了一种“teacher force”的概念，就是每个时刻的输入不依赖上一时刻的输出，而是依赖之前所有正确的样本，而正确的样本在训练集中已经全部提供了。正是这种“teacher force”的思想，才可以在Transformer的Decoder部分进行并行化计算，</p></li><li><p>值得注意的一点是：Decoder的并行化仅在训练阶段，在测试阶段，因为我们没有label，所以t时刻的输入必然依赖t-1时刻的输出，这时跟之前的NLP中的序列预测就没什么区别了。</p><ul><li>NLP中的RNN之所以不能并行化，是因为其是一个马尔可夫过程，即当前状态只与前一个状态有关,而与再之前的所有状态无关。它天生是个时序结构，t时刻依赖t-1时刻的输出，而t-1时刻又依赖t-2时刻，如此循环往前，我们可以说t时刻依赖了前t时刻所有的信息。</li></ul></li></ul><p>19.Transformer训练的时候学习率是如何设定的？Dropout是如何设定的，位置在哪里？Dropout 在测试的需要有什么需要注意的吗？</p><ul><li>Transformer训练时学习率会有一个warmup的过程，即先升高再逐渐减小；Dropout一般设置为0.1-0.2之间，并且只在训练时使用，在测试时不需要使用</li></ul><p>20解码端的残差结构有没有把后续未被看见的mask信息添加进来，造成信息的泄露。</p><ul><li>解码端的残差结构没有把后续未被看见的mask信息添加进来，因此不会造成信息泄露³。</li></ul>]]></content>
    
    
    <summary type="html">特点
能够适应大数据，泛化性更强（transformer上限高，cnn下限高）

全局感受野

更好的处理序列数据能力

并行计算能力

更容易扩展到其他任务

缺点：

没有平移、缩放、形变的不变性（CNN存在归纳偏置，局部性和平移等变性）

CNN有强归纳偏置性,所以在小数据集上表现更好。但如果有大量的数据可用,CNN的强归纳偏置性反而会限制模型的能力

卷积的平移等变性：
卷积+最大池化等于平移等变性。

卷积：简单地说，图像经过平移，相应的特征图上的表达也是平移的。输入图像的左下角有一个人脸，经过卷积，人脸的特征（眼睛，鼻子）也位于特征图的左下角

池化：比如最大池化，它返回感受野中的</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://youngyyp.github.io/2023/04/27/cpp/%E5%9B%BE/"/>
    <id>https://youngyyp.github.io/2023/04/27/cpp/%E5%9B%BE/</id>
    <published>2023-04-27T02:13:33.000Z</published>
    <updated>2023-05-30T13:04:35.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><p><img src="/2023/04/27/cpp/%E5%9B%BE/2.jpeg" alt="img" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// graph[x] 存储 x 的所有邻居节点vector<int> graph[];  //其实也相当于vector<vector<int>> graph;// 邻接矩阵// matrix[x][y] 记录 x 是否有一条指向 y 的边bool matrix[][];</code></pre><p><strong>度</strong>（degree）：</p><p>无向图中，「度」就是每个节点相连的边的条数。</p><p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为<strong>入度</strong>（indegree）和<strong>出度</strong>（outdegree）</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/0.jpg" alt="img" style="zoom:50%;"></p><p>其中节点 <code>3</code> 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 记录遍历过的节点vector<bool> visited;// 记录从起点到当前节点的路径vector<bool> onPath;/* 图遍历框架 */void traverse(Graph graph, int s) {    if (visited[s]) return;    // 经过节点 s，标记为已遍历    visited[s] = true;    // 做选择：标记节点 s 在路径上    onPath[s] = true;    for (int neighbor : graph.neighbors(s)) {        traverse(graph, neighbor);    }    // 撤销选择：节点 s 离开路径    onPath[s] = false;}</code></pre><h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h2><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797. 所有可能的路径 - 力扣（Leetcode）</a></p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 j  <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="/2023/04/27/cpp/%E5%9B%BE/all_1.jpg" alt="img" style="zoom:50%;"></p><pre><code>输入：graph = [[1,2],[3],[3],[]]输出：[[0,1,3],[0,2,3]]解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void dfs(vector<vector<int>>& graph, int x){        if(x == graph.size() - 1) { // 如果不能走到终点就不用做处理            result.push_back(path);            return;        }        for(int i : graph[x]){            path.push_back(i);            dfs(graph, i);            path.pop_back();        }    }public:    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {        //注意dfs和回溯的区别，dfs需要加入根节点到路径中        path.push_back(0);        dfs(graph, 0);        return result;    }};</code></pre><h2 id="207-课程表——环检测-DFS）"><a href="#207-课程表——环检测-DFS）" class="headerlink" title="207. 课程表——环检测(DFS）"></a>207. 课程表——环检测(DFS）</h2><p><a href="https://leetcode.cn/problems/course-schedule/description/">207. 课程表 - 力扣（Leetcode）</a></p><p><strong>示例 1：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    // 记录一次 traverse 递归经过的节点    vector<bool> onPath;    // 记录遍历过的节点，防止走回头路    vector<bool> visited;// 如果有节点在之前的轮次中被遍历过了，证明这个节点不存在环了，跟这个节点相连的节点已经被检查过了，可以节省时间    // 记录图中是否有环    bool hasCycle = false;    void traverse(vector<vector<int>>& graph, int s) {        if (onPath[s]) {            // 出现环            hasCycle = true;        }        if (visited[s] || hasCycle) {            // 如果已经找到了环，也不用再遍历了            return;        }        //前序遍历位置        visited[s] = true; // 没有回溯！！！表示这条路上的节点已经都被检查过了        onPath[s] = true;        for (int t : graph[s]) {            traverse(graph, t);        }        //后序遍历位置        onPath[s] = false;    }public:    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {        // 首先将输入转换为邻接表        vector<vector<int>> graph(numCourses);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);        }        visited.resize(numCourses, false);//初始化！        onPath.resize(numCourses, false);        for (int i = 0; i < numCourses; i++) {            // 遍历图中的所有节点            traverse(graph, i);        }        // 只要没有循环依赖可以完成所有课程        return !hasCycle;    }};</code></pre><h2 id="210-课程表-II-——-拓扑排序-DFS"><a href="#210-课程表-II-——-拓扑排序-DFS" class="headerlink" title="210. 课程表 II —— 拓扑排序(DFS)"></a>210. 课程表 II —— 拓扑排序(DFS)</h2><p><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II - 力扣（Leetcode）</a></p><p>这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。</p><p>拓扑排序示意（C7-&gt;C8-&gt;C6<code>应该改为</code>C6-&gt;C7-&gt;C8）：</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/image-20230428094601419.png" alt="image-20230428094601419" style="zoom:50%;"></p><p><strong>直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的</strong>，比如上图所有箭头都是朝右的。</p><p>如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「<strong>有向无环图</strong>」，那么一定可以进行拓扑排序</p><p>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的<strong>拓扑排序</strong>结果就是上课顺序</p><p>将<strong>后序遍历</strong>的结果进行<strong>反转</strong>，就是拓扑排序的结果。—— <strong>逆后序遍历</strong></p><p>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行。</p><p>用树来做类比如下：</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/image-20230428101621512.png" alt="image-20230428101621512" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dfs逆后序遍历class Solution {private:    // 记录一次 traverse 递归经过的节点    vector<bool> onPath;    // 记录遍历过的节点，防止走回头路    vector<bool> visited;// 如果有节点在之前的轮次中被遍历过了，证明这个节点不存在环了，跟这个节点相连的节点已经被检查过了，可以节省时间    // 记录图中是否有环    bool hasCycle = false;    vector<int> postorder;    void traverse(vector<vector<int>>& graph, int s) {        if (onPath[s]) {            // 出现环            hasCycle = true;        }        if (visited[s] || hasCycle) {            // 如果已经找到了环，也不用再遍历了            return;        }        //前序遍历位置        visited[s] = true; // 没有回溯！！！表示这条路上的节点已经都被检查过了        onPath[s] = true;        for (int t : graph[s]) {            traverse(graph, t);        }        //后序遍历位置        onPath[s] = false;        postorder.push_back(s);    }public:    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {        // 首先将输入转换为邻接表        vector<vector<int>> graph(numCourses);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);        }        visited.resize(numCourses, false);//初始化！        onPath.resize(numCourses, false);        for (int i = 0; i < numCourses; i++) {            // 遍历图中的所有节点            traverse(graph, i);        }        // 只要没有循环依赖可以完成所有课程        if(hasCycle) return {};        reverse(postorder.begin(), postorder.end());        return postorder;    }};</code></pre><h2 id="BFS算法——宽度优先搜索"><a href="#BFS算法——宽度优先搜索" class="headerlink" title="BFS算法——宽度优先搜索"></a>BFS算法——宽度优先搜索</h2><p>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多</strong></p><p>BFS 的核心思想：就是把一些问题抽象成图，从一个点开始，向四周开始扩散</p><p>写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列</p><p>BFS使用场景：一幅「图」，让你从一个起点，走到终点，问最短路径</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 计算从起点 start 到终点 target 的最近距离int BFS(Node start, Node target) {    queue<Node> q; // 核心数据结构    unordered_set<Node> visited; // 避免走回头路    q.push(start); // 将起点加入队列    visited.insert(start);    int step = 0; // 记录扩散的步数    while (!q.empty()) {        int sz = q.size();        /* 将当前队列中的所有节点向四周扩散 */        for (int i = 0; i < sz; i++) {            Node cur = q.front();            q.pop();            /* 划重点：这里判断是否到达终点 */            if (cur == target)                return step;            /* 将 cur 的相邻节点加入队列 */            for (Node x : cur.adj()) {                if (visited.count(x) == 0) {                    q.push(x);                    visited.insert(x);                }            }        }        /* 划重点：更新步数在这里 */        step++;    }}</code></pre><h2 id="环检测算法（BFS-版本）—课程表题目优先用bfs"><a href="#环检测算法（BFS-版本）—课程表题目优先用bfs" class="headerlink" title="环检测算法（BFS 版本）—课程表题目优先用bfs"></a>环检测算法（BFS 版本）—课程表题目优先用bfs</h2><p><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/">环检测及拓扑排序算法 :: labuladong的算法小抄</a></p><p>BFS 算法借助 <code>indegree</code> 数组记录每个节点的「入度」，也可以实现【课程表】算法</p><p>思路：</p><p>1、构建邻接表，和之前一样，边的方向表示「被依赖」关系。</p><p>2、构建一个 <code>indegree</code> 数组记录每个节点的入度，即 <code>indegree[i]</code> 记录节点 <code>i</code> 的入度。</p><p>3、对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。</p><p><strong>4、开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列</strong>。</p><p><strong>5、如果最终所有节点都被遍历过（<code>count</code> 等于节点数），则说明不存在环，反之则说明存在环</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {        // 建立邻接表和入度表        vector<vector<int>> graph(numCourses);        vector<int> indegree(numCourses, 0);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);            indegree[pre[0]]++;        }        // 将入度为 0 的节点首先装入队列        queue<int> que;        for(int i = 0; i < numCourses; i++){            if(indegree[i] == 0){                que.push(i);            }        }        // 减少相邻节点的入度，并将入度变为 0 的节点加入队列        int count = 0;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                int node = que.front();                que.pop();                count++;                for(auto child : graph[node]){                    indegree[child]--;                    if(indegree[child] == 0){                        que.push(child);                    }                }            }        }        return count == numCourses;    }};</code></pre><h2 id="拓扑排序算法（BFS-版本）"><a href="#拓扑排序算法（BFS-版本）" class="headerlink" title="拓扑排序算法（BFS 版本）"></a>拓扑排序算法（BFS 版本）</h2><p>如果你能看懂 BFS 版本的环检测算法，那么就很容易得到 BFS 版本的拓扑排序算法，因为<strong>节点的遍历顺序就是拓扑排序</strong>的结果。</p><p>稍微修改一下 BFS 版本的环检测算法，记录节点的遍历顺序即可得到拓扑排序的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {       // 建立邻接表和入度表        vector<vector<int>> graph(numCourses);        vector<int> indegree(numCourses, 0);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);            indegree[pre[0]]++;        }        // 将入度为 0 的节点首先装入队列        queue<int> que;        for(int i = 0; i < numCourses; i++){            if(indegree[i] == 0){                que.push(i);            }        }        // 减少相邻节点的入度，并将入度变为 0 的节点加入队列        int count = 0;        vector<int> res; // 记录遍历顺序        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                int node = que.front();                que.pop();                res.push_back(node);                count++;                for(auto child : graph[node]){                    indegree[child]--;                    if(indegree[child] == 0){                        que.push(child);                    }                }            }        }        if(count == numCourses){            return res;        }else return {};     }};</code></pre>]]></content>
    
    
    <summary type="html">图论基础


// graph[x] 存储 x 的所有邻居节点
vector&lt;int&gt; graph[];  //其实也相当于vector&lt;vector&lt;int&gt;&amp;gt; graph;

// 邻接矩阵
// matrix[x][y] 记录 x 是否有一条指向 y 的边
bool matrix[][];


度（degree）：

无向图中，「度」就是每个节点相连的边的条数。

由于有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree）



其中节点 3 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。

// 记录遍历过的&lt;/vector&lt;int&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%AB%A0%E8%8A%82%E5%AE%89%E6%8E%92/"/>
    <id>https://youngyyp.github.io/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%AB%A0%E8%8A%82%E5%AE%89%E6%8E%92/</id>
    <published>2023-04-16T06:21:52.942Z</published>
    <updated>2023-04-16T06:21:52.991Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><p>第一章 绪论</p><p>​    1.1 研究背景与意义</p><p>​    1.2 国内外研究现状与挑战</p><p>​    1.3 研究内容与创新点</p><p>​    1.4 本文组织结构</p><p>第二章 域适应和测试阶段适应基本原理</p><p>​    2.1 域适应</p><p>​    2.2 TTA</p><p>​    2.3 本章小结</p><p>第三章 基于参数优化轨迹子空间的测试时间适应 / 基于 参数正则化的TTA</p><p>​    3.1 研究简介与问题分析</p><p>​    3.2 算法介绍</p><p>​        3.2.1 子空间</p><p>​        3.2.2 不同参数选取策略</p><p>第四章 基于adapter/prompt的TTA</p><p>​    </p><p>第五章 全文总结</p><p>参考文献</p><p>致谢</p>]]></content>
    
    
    <summary type="html">摘要

第一章 绪论

​ 1.1 研究背景与意义

​ 1.2 国内外研究现状与挑战

​ 1.3 研究内容与创新点

​ 1.4 本文组织结构

第二章 域适应和测试阶段适应基本原理

​ 2.1 域适应

​ 2.2 TTA

​ 2.3 本章小结

第三章 基于参数优化轨迹子空间的测试时间适应 / 基于 参数正则化的TTA

​ 3.1 研究简介与问题分析

​ 3.2 算法介绍

​ 3.2.1 子空间

​ 3.2.2 不同参数选取策略

第四章 基于adapter/prompt的TTA

​ 

第五章 全文总结

参考文献

致谢</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ACM模式</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/ACM%E6%A8%A1%E5%BC%8F/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/ACM%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-04-13T06:09:42.703Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qwe641259875/article/details/117031847">(79条消息) clion mac 下刷题最佳配置<em>clion 刷题模板</em>菜饼同学的博客-CSDN博客</a></p><p>单文件编译<a href="https://plugins.jetbrains.com/plugin/8352-c-c--single-file-execution">C/C++ Single File Execution - CLion Plugin | Marketplace (jetbrains.com)</a></p><h1 id="include-：-万能头文件＜bits-stdc-h＞"><a href="#include-：-万能头文件＜bits-stdc-h＞" class="headerlink" title="include   ： 万能头文件＜bits/stdc++.h＞"></a>include <bits stdc++.h>  ： 万能头文件<strong>＜bits/stdc++.h＞</strong></bits></h1><p><a href="https://blog.csdn.net/hehehe326/article/details/123954338">(79条消息) C++ 输入输出函数总结及 OJ 在线编程常见输入输出练习<em>c++ oj 输入</em>吃烧鸭的博客-CSDN博客</a></p><h1 id="C-输入"><a href="#C-输入" class="headerlink" title="C++ 输入"></a>C++ 输入</h1><h2 id="std-operator-gt-gt"><a href="#std-operator-gt-gt" class="headerlink" title="std::operator>>"></a>std::operator&gt;&gt;</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <string>istream& operator>> (istream& is, string& str);123</code></pre><ul><li>遇到空格（回车等）停止，但<strong>不会</strong>从输入中读取并丢弃空格；</li><li>连续使用 cin 时，会自动跳过前导空格（回车等）；</li></ul><h2 id="std-getline"><a href="#std-getline" class="headerlink" title="std::getline"></a>std::getline</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <string>istream& getline (istream&  is, string& str, char delim);istream& getline (istream&  is, string& str); // default delim '\n'123</code></pre><ul><li>遇到 delim 则停止读取，从输入缓冲<strong>读取并丢弃 delim</strong>；</li><li>delim 不会写入 str，且下一个输入操作将从 delim 下一位开始；</li></ul><h2 id="std-istream-getline"><a href="#std-istream-getline" class="headerlink" title="std::istream::getline"></a>std::<a href="https://so.csdn.net/so/search?q=istream&amp;spm=1001.2101.3001.7020">istream</a>::getline</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>istream& getline (char* s, streamsize n );  // default delim '\n'istream& getline (char* s, streamsize n, char delim );123</code></pre><ul><li>遇到 delim 或已经读入 n-1 个有效字符则停止，函数会在 s 尾部自动添加终止空字符<code>'\0'</code>；</li><li>从输入缓冲<strong>读取 delim 并丢弃</strong>，不会写入字符串 s 中；</li></ul><h2 id="std-istream-get"><a href="#std-istream-get" class="headerlink" title="std::istream::get"></a>std::istream::get</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>int peek(); // no extractingint get();  // extractistream& get (char& c);istream& get (char* s, streamsize n); // default delim '\n'istream& get (char* s, streamsize n, char delim);123456</code></pre><ul><li>读入 n-1 个有效字符 或 遇到 delim 则停止，且 delim <strong>不会</strong>被读入并丢弃；</li><li>空字符 <code>'\0'</code> 自动添加到 s 末尾；</li></ul><h2 id="std-istream-ignore"><a href="#std-istream-ignore" class="headerlink" title="std::istream::ignore"></a>std::istream::ignore</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">istream& ignore (streamsize n = 1, int delim = EOF);1</code></pre><ul><li>从输入序列中读取并丢弃字符，直到丢弃共计 n 个字符或遇到 delim；</li><li>delim 会被<strong>读取并丢弃</strong>；</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>大部分函数都会返回输入流的引用 <code>istream&amp;</code>，因此可以用于条件判断输入有效性，或连续输入；</li></ul><h1 id="牛客-OJ-输入输出练习"><a href="#牛客-OJ-输入输出练习" class="headerlink" title="牛客 OJ 输入输出练习"></a>牛客 <a href="https://so.csdn.net/so/search?q=OJ&amp;spm=1001.2101.3001.7020">OJ</a> 输入输出练习</h1><h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h2><p>输入描述:<br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 1000),输入数据包括多组。<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int a, b;    while(cin >> a >> b)        cout << a + b << endl;    return 0;}123456789</code></pre><h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h2><p>输入描述:<br>输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)<br>接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 1000)<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int t;    int a, b;    cin >> t;    while(t--){        cin >> a >> b;        cout << a + b << endl;    }    return 0;}12345678910111213</code></pre><h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h2><p>输入描述:<br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int a, b;    while(cin >> a >> b){        if(a == 0 && b == 0)            break ;        cout << a + b << endl;    }    return 0;}123456789101112</code></pre><h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h2><p>输入描述:<br>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int n, num;    int sum = 0;    while(cin >> n && n != 0){        while(n--){            cin >> num;            sum += num;        }        cout << sum << endl;        sum = 0;//注意输出后初始化结果    }    return 0;}12345678910111213141516</code></pre><h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h2><p>输入描述:<br>输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int lines, n, num;    int sum;    cin >> lines;    while (cin >> n) {        sum = 0;        while (n--) {            cin >> num;            sum += num;        }        cout << sum << endl;    }    return 0;}1234567891011121314151617</code></pre><h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h2><p>输入描述:<br>输入数据有多组, 每行表示一组输入数据。<br>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// F1#include <iostream>using namespace std;int main() {    int sum, num;    while (cin >> num) {        sum += num;        if (cin.get() == '\n') { // 提取空格或行尾回车            cout << sum << endl;            sum = 0;        }    }    return 0;}// F2#include <iostream>#include <sstream>using namespace std;int main() {    int sum, num;    string line;    while (getline(cin, line)) {        istringstream iss(line);        while (iss >> num)            sum += num;        cout << sum << endl;        sum = 0;    }    return 0;}</code></pre><h2 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a><a href="https://so.csdn.net/so/search?q=字符串排序&amp;spm=1001.2101.3001.7020">字符串排序</a>(1)</h2><p>输入描述:<br>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开<br>输出描述:<br>输出一行排序后的字符串，空格隔开，无结尾空格</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <string>#include <vector>#include <algorithm>using namespace std;int main() {    int n;    cin >> n;    vector<string> vec(n);    while(n--) cin >> vec[n];    sort(vec.begin(), vec.end());    for (string& str : vec)        cout << str << " ";    return 0;}1234567891011121314151617</code></pre><h2 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h2><p>输入描述:<br>多个测试用例，每个测试用例一行。<br>每行通过空格隔开，有n个字符，n＜100<br>输出描述:<br>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <vector>#include <string>#include <algorithm>using namespace std;int main(){    vector<string> vec;    string tmp;    while (cin >> tmp) {        vec.push_back(tmp);        if (cin.get() == '\n'){            sort(vec.begin(), vec.end());            for (string& str : vec)                cout << str << " ";            cout << endl;            vec.clear();        }    }    return 0;}12345678910111213141516171819202122</code></pre><h2 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h2><p>输入描述:<br>多个测试用例，每个测试用例一行。<br>每行通过,隔开，有n个字符，n＜100<br>输出描述:<br>对于每组用例输出一行排序后的字符串，用’,’隔开，无结尾空格</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <sstream>#include <vector>#include <string>#include <algorithm>using namespace std;int main(){    vector<string> vec;    string str;    while (getline(cin, str)) { // 解决 '\n'        istringstream iss(str);        while (getline(iss, str, ',')) // 按 ',' 分割            vec.push_back(str);        sort(vec.begin(), vec.end());        for (int i = 0; i < vec.size() - 1; ++i)            cout << vec[i] << ",";        cout << vec.back() << endl;        vec.clear();    }    return 0;}1234567891011121314151617181920212223</code></pre><h2 id="自测本地通过提交为0"><a href="#自测本地通过提交为0" class="headerlink" title="自测本地通过提交为0"></a>自测本地通过提交为0</h2><p>数据范围：0 &lt; a , b &lt; 2 × 1 0 10 0 &lt; a,b &lt; 2 \times 10^{10}0&lt;a,b&lt;2×1010<br>输入描述:<br>输入有多组测试用例，每组空格隔开两个整数<br>输出描述:<br>对于每组数据输出一行两个整数的和；</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    long long a, b;  // 需注意数据范围，样例通过不代表所有测试数据通过；    while (cin >> a >> b)        cout << a + b << endl;    return 0;}</code></pre><p><a href="https://blog.csdn.net/qq_46046431/article/details/129266738">(79条消息) ACM模式输入输出攻略 | C++篇<em>acm模式c++输入输出</em>小黛的求职笔记的博客-CSDN博客</a></p><pre class=" language-lang-CPP"><code class="language-lang-CPP">// 链表定义，并给出两个有参构造函数struct ListNode{    int val;    ListNode* next;    ListNode(int _val):val(_val),next(nullptr){}    ListNode(int _val,ListNode* _next):val(_val),next(_next){}};</code></pre><pre class=" language-lang-CPP"><code class="language-lang-CPP">//定义树节点struct TreeNode{    int val;    TreeNode* left;    TreeNode* right;    TreeNode():val(0),left(nullptr),right(nullptr){}    TreeNode(int _val):val(_val),left(nullptr),right(nullptr){}    TreeNode(int _val,TreeNode* _left,TreeNode* _right):val(0),left(_left),right(_right){}};</code></pre>]]></content>
    
    
    <summary type="html">(79条消息) clion mac 下刷题最佳配置clion 刷题模板菜饼同学的博客-CSDN博客

单文件编译C/C++ Single File Execution - CLion Plugin | Marketplace (jetbrains.com)

include ： 万能头文件＜bits/stdc++.h＞
(79条消息) C++ 输入输出函数总结及 OJ 在线编程常见输入输出练习c++ oj 输入吃烧鸭的博客-CSDN博客

C++ 输入
std::operator&amp;gt;&amp;gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
istream&amp;amp; operator&lt;/string&gt;&lt;/iostream&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-04-13T06:09:42.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调栈基础"><a href="#单调栈基础" class="headerlink" title="单调栈基础"></a>单调栈基础</h2><h4 id="什么时候用单调栈："><a href="#什么时候用单调栈：" class="headerlink" title="什么时候用单调栈："></a>什么时候用单调栈：</h4><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p>关于单调栈的顺序给大家一个总结： <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>中求一个元素右边第一个更大元素，单调栈就是递增的，<a href="https://programmercarl.com/0084.柱状图中最大的矩形.html">84.柱状图中最大的矩形 (opens new window)</a>求一个元素右边第一个更小元素，单调栈就是递减的。</p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">力扣题目链接(opens new window)</a></p><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接temperatures[i]就可以获取。class Solution {public:    vector<int> dailyTemperatures(vector<int>& temperatures) {        stack<int> st;        vector<int> result(temperatures.size(), 0);        st.push(0);        for(int i = 1; i < temperatures.size(); i++){            if(temperatures[i] <= temperatures[st.top()]) st.push(i);            else {                // 注意这里的非空判断条件要放到&&前面，会优先判断是否空                while(!st.empty() && temperatures[i] > temperatures[st.top()]){                    result[st.top()] = i - st.top();                     st.pop();                }                st.push(i);            }        }        return result;    }};</code></pre><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/">力扣题目链接(opens new window)</a></p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {        stack<int> st;        vector<int> result(nums1.size(), -1);        if (nums1.size() == 0) return result;        unordered_map<int, int> umap; // key:元素值，value：下标        for (int i = 0; i < nums1.size(); i++) {            umap[nums1[i]] = i;        }        st.push(0);        for (int i = 1; i < nums2.size(); i++) {            if (nums2[i] < nums2[st.top()]) {           // 情况一                st.push(i);            } else if (nums2[i] == nums2[st.top()]) {   // 情况二                st.push(i);            } else {                                    // 情况三                while (!st.empty() && nums2[i] > nums2[st.top()]) {                    if (umap.find(nums2[st.top()]) != umap.end()) { // 看map里是否存在这个元素                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标                        result[index] = nums2[i];                    }                    st.pop();                }                st.push(i);            }        }        return result;    }};</code></pre><h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a>503.下一个更大元素II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">力扣题目链接(opens new window)</a></p><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><ul><li>输入: [1,2,1]</li><li>输出: [2,-1,2]</li><li>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> nextGreaterElements(vector<int>& nums) {        vector<int> result(nums.size(), -1);        if (nums.size() == 0) return result;        stack<int> st;        for (int i = 0; i < nums.size() * 2; i++) {            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作            // 这里对三种情况进行了合并            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {                result[st.top()] = nums[i % nums.size()];                st.pop();            }            st.push(i % nums.size());        }        return result;    }};</code></pre><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/">力扣题目链接(opens new window)</a></p><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/20210713205038.png" alt="img"></p><ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单调栈是按照行方向来计算雨水class Solution {public:    int trap(vector<int>& height) {        stack<int> st;        st.push(0);        int result = 0;        for(int i = 0; i < height.size(); i++){            while(!st.empty() && height[i] > height[st.top()]){                int mid = st.top();                st.pop();                if(!st.empty()){                    int h = min(height[i], height[st.top()]) - height[mid];                    int w = i - st.top() - 1;                    result += h*w;                }            }            st.push(i);        }        return result;    }};</code></pre><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">力扣题目链接(opens new window)</a></p><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/20210803220437.png" alt="img"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 找右边第一个比当前值小的class Solution {public:    int largestRectangleArea(vector<int>& heights) {        int result = 0;        stack<int> st;        heights.insert(heights.begin(), 0); // 数组头部加入元素0        heights.push_back(0); // 数组尾部加入元素0        st.push(0);        // 第一个元素已经入栈，从下标1开始        for (int i = 1; i < heights.size(); i++) {            if (heights[i] > heights[st.top()]) { // 情况一                st.push(i);            } else if (heights[i] == heights[st.top()]) { // 情况二                st.pop(); // 这个可以加，可以不加，效果一样，思路不同                st.push(i);            } else { // 情况三                while (!st.empty() && heights[i] < heights[st.top()]) { // 注意是while                    int mid = st.top();                    st.pop();                    if (!st.empty()) {                        int left = st.top();                        int right = i;                        int w = right - left - 1;                        int h = heights[mid];                        result = max(result, w * h);                    }                }                st.push(i);            }        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">单调栈基础
什么时候用单调栈：
通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。

单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

关于单调栈的顺序给大家一个总结： 739. 每日温度 (opens new window)中求一个元素右边第一个更大元素，单调栈就是递增的，84.柱状图中最大的矩形 (opens new window)求一个元素右边第一个更小元素，单调栈就是递减的。

739. 每日温度
力扣题目链接(opens ne</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-05-31T02:43:24.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. 数组中重复的数字</h2><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3</code></pre><p><strong>我的（hash）：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        // hash        vector<int> hash(nums.size(),0);        for(int i = 0; i < nums.size(); i++){            if(hash[nums[i]] == 0) hash[nums[i]]++;            else return nums[i];        }        return 0;    }};</code></pre><p>法二（原地交换）：</p><p>题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/1618146573-bOieFQ-Picture0.png" alt="Picture0.png" style="zoom:50%;"></p><p>遍历中，第一次遇到数字 x时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x]=x ，此时即可得到一组重复数字。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        int i = 0;        while(i < nums.size()) {            if(nums[i] == i) {                i++;                continue;            }            if(nums[nums[i]] == nums[i])                return nums[i];            swap(nums[i],nums[nums[i]]);        }        return -1;    }};</code></pre><p>想了一个比较好理解方法2方式</p><p>这个原地交换法就相当于分配工作，每个索引代表一个工作岗位，每个岗位必须专业对口，既0索引必须0元素才能上岗。而我们的目的就是找出溢出的人才，既0索引岗位有多个0元素竞争。</p><p>我们先从0索引岗位开始遍历，首先我们看0索引是不是已经专业对口了，如果已经专业对口既nums[0]=0，那我们就跳过0岗位看1岗位。如果0索引没有专业对口，那么我们看现在0索引上的人才调整到他对应的岗位上，比如num[0]=2，那我们就把2这个元素挪到他对应的岗位上既num[2]，这个时候有两种情况:1、num[2]岗位上已经有专业对口的人才了，既num[2]=2，这就说明刚刚那个在num[0]上的2是溢出的人才，我们直接将其返回即可。2、num[2]上的不是专业对口的人才，那我们将num[0]上的元素和num[2]上的元素交换，这样num[2]就找到专业对口的人才了。之后重复这个过程直到帮num[0]找到专业对口的人才，然后以此类推帮num[1]找人才、帮num[2]找人才，直到找到溢出的人才。</p><h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h2><p>在一个 n <em> m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <em>*非递减</em></em> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><pre><code>[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>代码：</strong></p><p>如果真从左上角开始的话，就会发现无论向右还是向下走，元素大小都会增加，那么到底向右还是向下？不确定，那只好用类似 <a href="https://labuladong.github.io/article/fname.html?fname=动态规划详解进阶">动态规划算法</a> 的思路穷举了。</p><p>但实际上不用这么麻烦，我们不要从左上角开始，而是<strong>从右上角开始</strong>，规定只能向左或向下移动。</p><p>如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和 <code>target</code> 的相对大小来判断应该往哪移动，不断接近从而找到 <code>target</code> 的位置。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {        int n = matrix.size();        if(n == 0) return false; //防止输入[]        int m = matrix[0].size();        int i = 0;        int j = m - 1;        while(i < n && j >= 0){            if(matrix[i][j] < target){                i++;            }else if(matrix[i][j] > target){                j--;            }else return true;        }        return false;    }};</code></pre><h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = "We are happy."输出："We%20are%20happy."</code></pre><p>另外开辟一个字符串来存，空间复杂度O(n)：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        string result;        for(auto c:s){            if(c == ' ') result += "%20";            else result += c;        }        return result;    }};</code></pre><p>双指针，优化空间复杂度：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        int length = s.size();        for(int i = 0; i < s.size(); i++){            if(s[i] == ' '){                length = length + 2;            }        }        int left = s.size() - 1;        int right = length - 1;        s.resize(length);        while(left >= 0){            if(s[left] == ' '){                s[right] = '0';                s[right-1] = '2';                s[right-2] = '%';                right = right - 3;            }else{                s[right] = s[left];                right--;             }            left--;        }        return s;    }};</code></pre><h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p>栈：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> reversePrint(ListNode* head) {        stack<int> s;        vector<int> result;        while(head){            s.push(head->val);            head = head->next;        }        while(!s.empty()){            result.push_back(s.top());            s.pop();        }        return result;    }};</code></pre><p>双指针 翻转链表：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> reversePrint(ListNode* head) {        ListNode* temp;        ListNode* cur = head;        ListNode* pre = NULL;        while(cur){            temp = cur->next;            cur->next = pre;             pre = cur;             cur = temp;        }        vector<int> r;        while(pre){            r.push_back(pre->val);            pre = pre->next;        }        return  r;    }   };</code></pre><h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树*"></a>07. 重建二叉树*</h2><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/tree.jpg" alt="img"></p><pre><code>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    unordered_map<int, int> index;public:    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {        if (preorder_left > preorder_right) {            return nullptr;        }        // 前序遍历中的第一个节点就是根节点        int preorder_root = preorder_left;        // 在中序遍历中定位根节点        int inorder_root = index[preorder[preorder_root]];        // 先把根节点建立出来        TreeNode* root = new TreeNode(preorder[preorder_root]);        // 得到左子树中的节点数目        int size_left_subtree = inorder_root - inorder_left;        // 递归地构造左子树，并连接到根节点        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        // 递归地构造右子树，并连接到根节点        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        int n = preorder.size();        // 构造哈希映射，帮助我们快速定位根节点        for (int i = 0; i < n; ++i) {            index[inorder[i]] = i;        }        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    }};作者：力扣官方题解链接：https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solutions/103063/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> preorder;    unordered_map<int, int> map;    TreeNode* traversal(int root, int left, int right){        if(left > right) return nullptr;        // root为前序根节点的位置，left为中序的左边界位置，right为中序的右边界位置        TreeNode* node = new TreeNode(preorder[root]);        int i = map[preorder[root]];        node->left = traversal(root + 1, left, i - 1);        node->right = traversal(root + (i - left) + 1, i + 1, right);        return node;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        int n = preorder.size();        this->preorder = preorder;        for(int i = 0; i < n; i++){            map[inorder[i]] = i;        }        return traversal(0, 0, n-1);    }};作者：Krahets链接：https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solutions/100091/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/</code></pre><pre><code>root + (i - left) + 1 含义为  根节点索引 + 左子树长度 + 1</code></pre><p><strong>切片方法</strong> 这个方法最直接：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 切片的方式    TreeNode* traversal(vector<int> preorder, vector<int> inorder){        if(preorder.size() == 0 || inorder.size() == 0) return nullptr;         TreeNode* node = new TreeNode(preorder[0]);        if(preorder.size() == 1) return node;         int i; //根据pre找根节点的值，根据这个值在in中找坐标        for(int j = 0; j < preorder.size(); j++){            if(inorder[j] == preorder[0]) {                i = j;                break;            }        }        //切片操作是左闭右开的   begin指向0，end指向n        vector<int> l_p(preorder.begin() + 1, preorder.begin() + i + 1);        vector<int> l_i(inorder.begin(), inorder.begin() + i);        vector<int> r_p(preorder.begin() + i + 1, preorder.end());        vector<int> r_i(inorder.begin() + i + 1, inorder.end());        node->left = traversal(l_p, l_i);        node->right = traversal(r_p, r_i);        return node;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        return traversal(preorder,inorder);    }};</code></pre><h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a>09. 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><pre><code>输入：["CQueue","appendTail","deleteHead","deleteHead","deleteHead"][[],[3],[],[],[]]输出：[null,null,3,-1,-1]</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class CQueue {private:    stack<int> st1, st2;public:    CQueue() {    }    void appendTail(int value) {        st2.push(value);    }    int deleteHead() {        if(st1.empty() && st2.empty()){            return -1;        }        if(st1.empty()){            while(!st2.empty()){                st1.push(st2.top());                st2.pop();            }        }        int res = st1.top();        st1.pop();        return res;    }};</code></pre><h2 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a>10- II. 青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要<strong>取模</strong> 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp问题class Solution {public:    int numWays(int n) {        uint64_t mod = 1000000007;        if(n <= 1) return 1;        vector<uint64_t> dp(n+1);         dp[0] = 1;        dp[1] = 1;         for(int i = 2; i <= n; i++){            dp[i] = (dp[i-1]+dp[i-2]) % mod;        }        return dp[n] ;    }};</code></pre><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：numbers = [3,4,5,1,2]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numbers = [2,2,2,0,1]输出：0</code></pre><p>我的暴力解法：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minArray(vector<int>& numbers) {        if(numbers.size() == 1) return numbers[0];        int last = numbers[0];        for(int i = 1; i < numbers.size(); i++){            if(numbers[i] >= last) last = numbers[i];            else return numbers[i];        }        return numbers[0];    }};</code></pre><p>此题考虑是升序数组，可以使用二分法来减少时间复杂度（左闭右开）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minArray(vector<int>& numbers) {        int low = 0;        int high = numbers.size() - 1;        while(low < high){            int mid = low + (high - low) / 2;            if(numbers[mid] > numbers[high]) low = mid + 1;            else if (numbers[mid] < numbers[high]) high = mid;            else high--;        }        return numbers[low];    }};</code></pre><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/</a></p><h2 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a>10- I. 斐波那契数列</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><pre><code>F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        vector<int> dp(n+1);        if(n <= 1) return n;        dp[0] = 0;        dp[1] = 1;        for(int i = 2; i <= n; i++){            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007;        }        return dp[n];    }};</code></pre><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径*"></a>12. 矩阵中的路径*</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/word2.jpg" alt="img"></p><p><strong>回溯的函数中，传参不加引用 会克隆一个新board并赋值然后供check()使用 这样会大大增加时间复杂度</strong>！！</p><p><strong>示例 1：</strong></p><pre><code>输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"输出：true</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 回溯算法用于递归查找子集    // 回溯    // 设函数 check(i,j,k) 表示判断以网格的 (i,j)位置出发，能否搜索到单词 word[k..](以k开头的后缀子串)    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, string& s, int k) {        // 这个board怎么不用引用就不行了呢？        // 因为不加引用 会克隆一个新board并赋值然后供check()使用 这样会大大增加时间复杂度        if (board[i][j] != s[k]) {            return false;        } else if (k == s.length() - 1) {            return true;        }        visited[i][j] = true;        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};        bool result = false;        for (auto dir: directions) {            int newi = i + dir.first, newj = j + dir.second;            if(newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size()){                if(!visited[newi][newj]){                    bool flag = check(board, visited, newi, newj, s, k + 1);                    if(flag){                        result = true;                        break;                    }                }            }        }        visited[i][j] = false;        return result;    }    bool exist(vector<vector<char>>& board, string word) {        int h = board.size(), w = board[0].size();        vector<vector<int>> visited(h, vector<int>(w));        for (int i = 0; i < h; i++) {            for (int j = 0; j < w; j++) {                bool flag = check(board, visited, i, j, word, 0);                if (flag) {                    return true;                }            }        }        return false;    }};</code></pre><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h2><p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/?favorite=xb9nqhhg">剑指 Offer 13. 机器人的运动范围 - 力扣（Leetcode）</a></p><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><pre><code>输入：m = 2, n = 3, k = 1输出：3</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // dfs遍历    int m;    int n;    int k;    int res = 0;    void dfs(int i, int j, vector<vector<bool>>& visited){ // i,j 表示当前位置         if(i >= m || j >=  n || i < 0 || j < 0) return;        if(i%10 + i/10 + j%10 + j/10 > k) return;        if(visited[i][j]) return;        visited[i][j] = true;        res++;        dfs(i-1, j, visited);        dfs(i+1, j, visited);        dfs(i, j-1, visited);        dfs(i, j+1, visited);    }    int movingCount(int m, int n, int k) {        this->m = m;        this->n = n;        this->k = k;        vector<vector<bool>> visited(m, vector<bool>(n, false));        dfs(0,0,visited);        return res;    }};</code></pre><h2 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a>14- I. 剪绳子</h2><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><pre><code>输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 动规    // dp[i] 长度为i的绳子的最大乘积    // 拆成两个还是拆成两个及以上？    // dp[i] = max((i-j)*j, dp[i - j]*j, dp[i])    int cuttingRope(int n) {        vector<int> dp(n+1);        dp[1] = 1;        dp[2] = 1;        for(int i = 2; i <= n; i++){            for(int j = 1; j < i; j++){                dp[i] = max(dp[i],max((i-j)*j, dp[i - j] * j));            }        }        return dp[n];    }};</code></pre><h2 id="15-二进制中1的个数——用n-amp-n-1-消除二进制最后一个1"><a href="#15-二进制中1的个数——用n-amp-n-1-消除二进制最后一个1" class="headerlink" title="15. 二进制中1的个数——用n &amp; (n-1)消除二进制最后一个1"></a>15. 二进制中1的个数——用n &amp; (n-1)消除二进制最后一个1</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 <a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</code></pre><p><code>n &amp; (n-1)</code> 这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1：</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/1.png" alt="img" style="zoom: 50%;"></p><p>不断消除数字 <code>n</code> 中的 1，直到 <code>n</code> 变为 0。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int hammingWeight(uint32_t n) {        int res = 0;        while (n != 0) {            n = n & (n - 1);            res++;        }        return res;    }};</code></pre><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方*"></a>16. 数值的整数次方*</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/shu-xue-yu-659f1/ru-he-gao--15bdf/">如何高效进行模幂运算 :: labuladong的算法小抄</a></p><p>我的：（会存在超时 ac:301/304）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    double myPow(double x, int n) {        double res = 1.0;        if(x == 1) return 1;        if(n > 0){            for(int i = 0; i < n; i++){                res = res*x;            }        }else if(n < 0){            x = 1/x;            n = -n;            for(int i = 0; i < n; i++){                res = res*x;            }        }else res = 1;        return res;    }};</code></pre><p>题解方法：快速幂 + 递归</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230411214203507.png" alt="image-20230411214203507"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    double quickMul(double x, long long N) {        if (N == 0) {            return 1.0;        }        double y = quickMul(x, N / 2);        return N % 2 == 0 ? y * y : y * y * x;    }    double myPow(double x, int n) {        long long N = n;        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);    }};</code></pre><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h2><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><pre><code>输入: n = 1输出: [1,2,3,4,5,6,7,8,9]</code></pre><p><strong>考虑大数问题</strong>！！（leetcode上没考虑，直接暴力就完事了)</p><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solutions/278565/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/">剑指 Offer 17. 打印从1到最大的n位数 - 力扣（Leetcode）</a></p><p><strong>用字符串模拟加法</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> res;    vector<int> printNumbers(int n) {        for(int i = 1; i <= n; i++)            for(int j = 1; j <= 9; j++)                dfs(1, i, to_string(j)); //dfs从1开始，因为第0位已经确定了        return res;    }    void dfs(int k, int len, string s) // k表示第k位数字，len表示要打印的长度    {        if(k==len)        {            res.push_back(stoi(s));            return;        }        for(int i = 0; i < 10; i++){            dfs(k + 1, len, s + to_string(i));        }    }};</code></pre><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><pre><code>输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//虚拟头节点的定义和使用，防止头节点要另外操作class Solution {public:    ListNode* deleteNode(ListNode* head, int val) {        ListNode* dummyhead = new ListNode(-1);        dummyhead->next = head;        ListNode* cur = dummyhead;        while(cur->next){            if(cur->next->val != val){                cur = cur->next;            }else {                cur->next = cur->next->next;                return dummyhead->next;            }        }        return dummyhead->next;    }};</code></pre><h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19. 正则表达式匹配*"></a>19. 正则表达式匹配*</h2><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/?favorite=xb9nqhhg">剑指 Offer 19. 正则表达式匹配 - 力扣（Leetcode）</a></p><p>请实现一个函数用来匹配包含<code>'. '</code>和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>"aaa"</code>与模式<code>"a.a"</code>和<code>"ab*ac*a"</code>匹配，但与<code>"aa.a"</code>和<code>"ab*a"</code>均不匹配。</p><p><strong>示例 1:</strong></p><pre><code>输入:s = "aa"p = "a"输出: false解释: "a" 无法匹配 "aa" 整个字符串。</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public://dp 函数的定义如下：// dp[i,j] 表示 s 的前i 个字符与p 的前 j 个字符是否能够匹配 (末尾下标分别对应i-1，j-1)// 递推：分两种情况，p[j-1] == 'x*?  不等于的很简单，下面只写等于的// 如果 p 的第 j 个字符是 *，那么就表示我们可以对 p 的第 j−1个字符匹配任意自然数次。在匹配0次的情况下，我们有// dp[i][j]=dp[i][j−2] ,也就是我们「浪费」了一个字符 + 星号的组合，没有匹配任何 s 中的字符。// 匹配 s 末尾的一个字符，将该字符扔掉，而该字符 + 星号组合还可以继续进行匹配；(dp[i-1][j] && match_sig(i,j-1))// 初始化：dp[0][0]  i从0遍历，因为s长度为0，p为a*也能匹配,需要计算得出    string S,P;    bool match_sig(int i, int j){        if(i != 0 && (S[i-1] == P[j-1] || P[j-1] == '.' )) return true;        else return false;    }    bool isMatch(string s, string p) {        S = s;        P = p;        vector<vector<int>> dp(s.size() + 1,vector<int>(p.size() + 1, 0));        dp[0][0] = true;        // i != 0 ; j == 0 的情况都为false        for(int i = 0; i <= s.size(); i++){            for(int j = 1; j <= p.size(); j++){                if(p[j - 1] == '*') {                    dp[i][j] = (match_sig(i,j-1) && dp[i-1][j]) || dp[i][j-2];                }else{                    dp[i][j] = match_sig(i,j) && dp[i-1][j-1];                }            }        }        int a;        return dp[s.size()][p.size()];    }};</code></pre><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h2><p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">剑指 Offer 20. 表示数值的字符串 - 力扣（Leetcode）</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 此题考查状态机写法,太麻烦了。。。// 抄下面的方法：// ‘.’出现正确情况：只出现一次，且在e的前面// ‘e’出现正确情况：只出现一次，且出现前有数字// ‘+’‘-’出现正确情况：只能在开头和e后一位class Solution {public:    bool isNumber(string s) {        //去掉首尾空格        int i = 0;        while (i < s.size() && s[i] == ' ')            i++;        s = s.substr(i);        while (s.back() == ' ')            s.pop_back();        bool numFlag = false;        bool dotFlag = false;        bool eFlag = false;        for (int i = 0; i < s.size(); i++) {            // 判定为数字，则标记numFlag            if (isdigit(s[i])) {                numFlag = true;            }            // 判定为'.'需要没出现过'.'并且没出现过'e'            else if (s[i] == '.' && !dotFlag && !eFlag) {                dotFlag = true;            }            // 判定为'e'，需要没出现过'e'，并且出现过数字            else if ((s[i] == 'e' || s[i] == 'E') && !eFlag && numFlag) {                eFlag = true;                numFlag = false; // 'e'后面必须跟着一个整数，所以出现'e'之后就标志为false            }            // 判定为'+''-'符号，只能出现在第一位或者紧接'e'后面            else if ((s[i] == '+' || s[i] == '-') && (i == 0 || s[i - 1] == 'e' || s[i - 1] == 'E')) {            }             // 其他情况，都是非法的            else {                return false;            }        }        return numFlag;    }};</code></pre><h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h2><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/?favorite=xb9nqhhg">剑指 Offer 25. 合并两个排序的链表 - 力扣（Leetcode）</a></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1 == nullptr) return l2;        if(l2 == nullptr) return l1;        ListNode* left = l1;        ListNode* right = l2;        ListNode* dummy = new ListNode(-1);        ListNode* cur = dummy;        while(left && right){            if(left->val <= right->val) {                cur->next = left;                left = left->next;            }else{                cur->next = right;                right = right->next;            }            cur = cur->next;        }         if(left) cur->next = left;        if(right) cur->next = right;        return dummy->next;    }};</code></pre><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h2><p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/?favorite=xb9nqhhg">剑指 Offer 26. 树的子结构 - 力扣（Leetcode）</a></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 回溯      // 注意：约定空树不是任意一个树的子结构    // 判定同根节点的树B是否是A的子树    bool dfs(TreeNode* A, TreeNode* B){        if(!B) return true; // 当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true        if(!A) return false; //当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false        return A->val == B->val && dfs(A->left, B->left) && dfs(A->right, B->right);    }      // 切换不同子节点作为A的根节点和B比较    bool isSubStructure(TreeNode* A, TreeNode* B) {        if(!B || !A) return false;        return dfs(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);    }};</code></pre><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h2><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/?favorite=xb9nqhhg">剑指 Offer 27. 二叉树的镜像 - 力扣（Leetcode）</a></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* mirrorTree(TreeNode* root) {        if(!root) return nullptr;        TreeNode* res = new TreeNode(root->val);        res->left = mirrorTree(root->right);        res->right = mirrorTree(root->left);        return res;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//这个方法更直观，且占用的额外空间更少class Solution {public:    TreeNode* mirrorTree(TreeNode* root) {        if(root == NULL) return root;        TreeNode* temp = root->left;        root->left = mirrorTree(root->right);        root->right = mirrorTree(temp);         return root;    }};</code></pre><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h2><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/description/?favorite=xb9nqhhg">剑指 Offer 28. 对称的二叉树 - 力扣（Leetcode）</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230417164040752.png" alt="image-20230417164040752"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt="Picture1.png" style="zoom: 33%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool dfs(TreeNode* L, TreeNode* R){        if(!L && !R) return true;        else if(!L || !R) return false;        if(L->val == R->val) return dfs(L->left, R->right) && dfs(L->right, R->left);        else return false;    }    bool isSymmetric(TreeNode* root) {        if(!root) return true;        return dfs(root->left,root->right);    }};</code></pre><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h2><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/?favorite=xb9nqhhg">剑指 Offer 30. 包含min函数的栈 - 力扣（Leetcode）</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.</code></pre><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/155.jpeg" alt="img" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 空间换时间 用一个额外的栈 minStk 来记录栈中每个元素下面（到栈底）的最小元素是多少class MinStack {public:    stack<int> st;    stack<int> min_st;    /** initialize your data structure here. */    MinStack() {    }    void push(int x) {        if(st.empty()) {            min_st.push(x);        }else{            if(x <= min_st.top()){                min_st.push(x);            } else{                min_st.push(min_st.top());            }           }        st.push(x);      }    void pop() {        if(!st.empty()){            st.pop();            min_st.pop();        }    }    int top() {        return st.top();    }    int min() {        return min_st.top();    }};</code></pre><h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 新建一个栈模拟该过程，    // popped[i] != s.top()   s.push(pushed[j])    // popped[i] == s.top()   s.pop()    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {        stack<int> s;        for(int i = 0, j = 0; i < popped.size(); i++){            // 注意最开始第一个直接入栈            while( s.empty() || (popped[i] != s.top() && j < pushed.size())){                s.push(pushed[j]);                j++;            }            if(popped[i] == s.top()) {                s.pop();            }        }        return s.empty();    }};</code></pre><h2 id="32-二叉树层序遍历"><a href="#32-二叉树层序遍历" class="headerlink" title="32. 二叉树层序遍历"></a>32. 二叉树层序遍历</h2><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/?favorite=xb9nqhhg</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 二叉树层序遍历 迭代    vector<int> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<int> res;        while(!que.empty()){            TreeNode* cur = que.front();            res.push_back(cur->val);            if (cur->left) que.push(cur->left);            if (cur->right) que.push(cur->right);            que.pop();        }        return res;    }};</code></pre><p>结果分层打印，如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<vector<int>> res;        while(!que.empty()){            int length = que.size();            vector<int> temp;            for(int i = 0; i < length; i++){                TreeNode* cur = que.front();                temp.push_back(cur->val);                if (cur->left) que.push(cur->left);                if (cur->right) que.push(cur->right);                que.pop();            }            res.push_back(temp);        }        return res;    }};</code></pre><h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。（字符串中可能存在重复字符）</p><p>你可以以任意顺序返回这个字符串数组，但里面<strong>不能有重复</strong>元素。</p><p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/description/">剑指 Offer 38. 字符串的排列 - 力扣（Leetcode）</a></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230516165808685.png" alt="image-20230516165808685"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:// 全排列问题，回溯算法// 排序去重！ 树层去重效率更高    vector<string> res;    string path;    void dfs(string& s, vector<bool>& used){        if(path.size() == s.size()){            res.push_back(path);            return;        }        for(int i = 0; i < s.size(); i++){            if(used[i]) continue;            // used[i - 1] == false，说明同一树层nums[i - 1]使用过            // 如果同一树层nums[i - 1]使用过则直接跳过            if (i > 0 && s[i] == s[i - 1] && used[i - 1] == false) {                continue;            }            used[i] = true;            path += s[i];            dfs(s,used);            used[i] = false;            path.pop_back();        }    }public:    vector<string> permutation(string s) {        vector<bool> used(s.size(), false);        sort(s.begin(), s.end()); // 排序        dfs(s, used);        return res;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:// 全排列问题，回溯算法// uset去重！    vector<string> res;    string path;    void dfs(string& s, vector<bool>& used){        if(path.size() == s.size()){            res.push_back(path);            return;        }        unordered_set<char> uset;        for(int i = 0; i < s.size(); i++){            if(used[i]) continue;            if (uset.find(s[i]) != uset.end()) {                continue;            }            uset.insert(s[i]); // 记录元素            used[i] = true;            path += s[i];            dfs(s,used);            used[i] = false;            path.pop_back();        }    }public:    vector<string> permutation(string s) {        vector<bool> used(s.size(), false);        dfs(s, used);        return res;    }};</code></pre><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p> <a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/?favorite=xb9nqhhg">剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（Leetcode）</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//解法一：排序取中位数//时间O(nlogn)，空间O(1)class Solution {public:    int majorityElement(vector<int>& nums) {        sort(nums.begin(), nums.end());        return nums[nums.size()/2];    }};//解法二：建立哈希表法//时间O(n)，空间O(n/2)class Solution {public:    int majorityElement(vector<int>& nums) {        unordered_map<int,int> hash;        int len = nums.size();        for(int i = 0; i < len; i++){            hash[nums[i]]++;            //不必等到哈希表完全建立再进行此判断             if(hash[nums[i]] > len/2) return nums[i];          }        return 0;    }};//解法三：摩尔投票法//也可以理解成混战极限一换一，不同的两者一旦遇见就同归于尽，最后活下来的值都是相同的，即要求的结果//时间O(n)，空间O(1)class Solution {public:    int majorityElement(vector<int>& nums) {        int res = 0, count = 0;        for(int i = 0; i < nums.size(); i++){            if(count == 0){                res = nums[i];                count++;            }            else                res==nums[i] ? count++:count--;        }        return res;    }};</code></pre><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h2><p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/description/?favorite=xb9nqhhg">剑指 Offer 42. 连续子数组的最大和 - 力扣（Leetcode）</a></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:/*dp 数组的含义：以 nums[i] 为结尾的「最大子数组和」为 dp[i]。dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。在这两种选择中择优，就可以计算出最大子数组，dp[i] = max(dp[i-1] + nums[i], nums[i])注意返回值不是dp[n] 而是最大的dp[i]*/    int maxSubArray(vector<int>& nums) {        vector<int> dp(nums.size());        dp[0] = nums[0];        int res = dp[0];        for(int i = 1; i < nums.size(); i++){            dp[i] = max(dp[i-1] + nums[i], nums[i]);            res = max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h2><p><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/?favorite=xb9nqhhg">剑指 Offer 46. 把数字翻译成字符串 - 力扣（Leetcode）</a></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><pre><code>输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"</code></pre><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230518164846771.png" alt="image-20230518164846771"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230518165739691.png" alt="image-20230518165739691"></p><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int translateNum(int num) {        string s = to_string(num);        if(s.size() == 0) return 0;        vector<int> dp(s.size()+1,0);        // dp[i]表示以第i-1位结尾的前缀传翻译的方案数        dp[0] = 1;        dp[1] = 1;        for(int i = 2; i <= s.size(); i++){            string tmp = s.substr(i-2,2);            if(stoi(tmp) <= 25 && stoi(tmp) >= 10){                dp[i] = dp[i-1] + dp[i-2];            }else{                dp[i] = dp[i-1];            }        }        return dp[s.size()];    }};</code></pre><p>空间优化：</p><p>滚动数组代替dp</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int translateNum(int num) {        string s = to_string(num);        if(s.size() == 0) return 0;        vector<int> dp(s.size()+1,0);        // dp[i]表示以第i-1位结尾的前缀传翻译的方案数        int a = 1;        int b = 1;        int c = 0;        for(int i = 2; i <= s.size(); i++){            string tmp = s.substr(i-2,2);            if(stoi(tmp) <= 25 && stoi(tmp) >= 10){                c = b + a;            }else{                c = b;            }            a = b;            b = c;        }        return b;    }};</code></pre><h2 id="57-II-和为s的连续正数序列"><a href="#57-II-和为s的连续正数序列" class="headerlink" title="57 - II. 和为s的连续正数序列*"></a>57 - II. 和为s的连续正数序列*</h2><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：target = 9输出：[[2,3,4],[4,5]]</code></pre><p>法一暴力：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>> res;        for(int i = 1; i <= target/2; i++){            int sum = 0;            vector<int> temp;            for(int j = i; j < target && sum <= target; j++){                if(sum == target){                    res.push_back(temp);                    break;                }                sum += j;                temp.push_back(j);            }        }        return res;    }};</code></pre><p>方法二：枚举 + 数学优化</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211105743.png" alt="image-20230522211105743"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211727462.png" alt="image-20230522211727462" style="zoom:50%;"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211735296.png" alt="image-20230522211735296" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>> res;        vector<int> vec;        int sum = 0, limit = (target - 1) / 2; // (target - 1) / 2 等效于 target / 2 下取整        for (int x = 1; x <= limit; ++x) {            long long delta = 1 - 4 * (x - 1ll * x * x - 2 * target); // 1ll是为了把int类型转为long long            if (delta < 0) {                continue;            }            // int delta_sqrt = (int)sqrt(delta + 0.5); // 开根号之后是double，直接转int会有损失，所以往回补点            int delta_sqrt = (int)sqrt(delta); //不加0.5也行，此处没有这种极端情况            if (1ll * delta_sqrt * delta_sqrt == delta && (delta_sqrt-1) % 2 == 0) {                int y = (-1 + delta_sqrt) / 2; // 另一个解(-1-delta_sqrt)/2必然小于0，不用考虑                if (x < y) {                    vec.clear();                    for (int i = x; i <= y; ++i) {                        vec.emplace_back(i);                    }                    res.emplace_back(vec);                }            }        }        return res;    }};</code></pre><p>法三：双指针（这个最好）</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522215007347.png" alt="image-20230522215007347"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>>vec;        vector<int> res;        for (int l = 1, r = 2; l < r;){            int sum = (l + r) * (r - l + 1) / 2;            if (sum == target) {                res.clear();                for (int i = l; i <= r; ++i) {                    res.emplace_back(i);                }                vec.emplace_back(res);                l++;            } else if (sum < target) {                r++;            } else {                l++;            }        }        return vec;    }};</code></pre>]]></content>
    
    
    <summary type="html">03. 数组中重复的数字
找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3


我的（hash）：

class Solution {
public:
    int findRepeatNumber(vector&lt;int&gt;&amp;amp; nums) {
        // hash
        vector&lt;int&gt; hash(nums.size(),0&lt;/int&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-03T01:24:07.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划基础知识"><a href="#动态规划基础知识" class="headerlink" title="动态规划基础知识"></a>动态规划基础知识</h2><p>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动规是由前一个状态推导出来的，而贪心是局部直接选最优的</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        if(n == 0) return 0;        if(n == 1) return 1;        return fib(n-1) + fib(n-2);    }};</code></pre><p>题解动规：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int N) {        if (N <= 1) return N;        vector<int> dp(N + 1);        dp[0] = 0;        dp[1] = 1;        for (int i = 2; i <= N; i++) {            dp[i] = dp[i - 1] + dp[i - 2];        }        return dp[N];    }};</code></pre><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>用递归和回溯都超出时间限制</strong></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int climbStairs(int n) {        if (n <= 2) return n;        vector<int> dp(n+1);        dp[1] = 1;        dp[2] = 2;        for (int i = 3; i <= n; i++) {            dp[i] = dp[i - 1] + dp[i - 2];//关键        }        return dp[n];    }};</code></pre><p>还可以用完全背包，求排列（先遍历背包，再遍历物体）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int climbStairs(int n) {        vector<int> dp(n + 1, 0);        dp[0] = 1;        for (int i = 1; i <= n; i++) { // 遍历背包            for (int j = 1; j <= m; j++) { // 遍历物品                if (i - j >= 0) dp[i] += dp[i - j];            }        }        return dp[n];    }};</code></pre><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minCostClimbingStairs(vector<int>& cost) {        vector<int> dp(cost.size() + 1);        dp[0] = 0; // 默认第一步都是不花费体力的        dp[1] = 0;        for (int i = 2; i <= cost.size(); i++) {            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);        }        return dp[cost.size()];    }};</code></pre><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePaths(int m, int n) {        vector<vector<int>> dp(m, vector<int>(n, 0));        //初始化，最好吧初始化和逻辑处理分开写，比较明了        for (int i = 0; i < m; i++) dp[i][0] = 1;        for (int j = 0; j < n; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        int m = obstacleGrid.size(); //！！记住这里的方式        int n = obstacleGrid[0].size();        vector<vector<int>> dp(m, vector<int>(n, 0));        /* 这块的判断写复杂了        int sig = 1;        for (int i = 0; i < m; i++) {            if(obstacleGrid[i][0] == 1) {                dp[i][0] = 0;                sig = 0;            }            if(sig) dp[i][0] = 1;        }        sig = 1;        for (int j = 0; j < n; j++) {            if(obstacleGrid[0][j] == 1) {                dp[0][j] = 0;                sig = 0;            }            if(sig) dp[0][j] = 1;        }        */        //题解的初始化判断        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;                else dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>思路：遍历，比较<code>dp[i - j] * j, (i - j) * j</code>大小，即比较拆成两个和拆成两个以上的乘积大小。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int integerBreak(int n) {        vector<int> dp(n+1);        dp[2] = 1;        for(int i = 3; i <= n; i++){            for (int j = 2; j < i; j++){                dp[i] = max(dp[i],max(dp[i - j] * j, (i - j) * j));            }        }        return dp[n];    }};</code></pre><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接(opens new window)</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的<strong>二叉搜索树</strong>有多少种？</p><p>思路：</p><p><img src="/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230310111953290.png" alt="image-20230310111953290"> </p><p>dp[3] = dp[0]dp[2] + dp[1]dp[1]+dp[2]dp[0];</p><p>节点的数值其实关系不大，只要每个值不一样就行；</p><p>dp[i] += dp[j - 1] * dp[i - j];</p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numTrees(int n) {        vector<int> dp(n+1);        dp[0] = 1;        dp[1] = 1;        for(int i = 2; i <= n; i++){            for(int j = 1; j <= i; j++){                dp[i] += dp[j - 1] * dp[i - j];            }        }        return dp[n];    }};</code></pre><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有N件物品和⼀个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p><p>例：</p><p>背包最⼤重量为4。<br>              重量    价值<br>物品0      1          15<br>物品1      3          20<br>物品2      4          30</p><p>思路：</p><h4 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h4><p>对于背包问题，有⼀种写法， 是使⽤<strong>⼆维数组</strong>，即<code>dp[i] [j]</code> 表⽰从下标为<code>[0-i]</code>的物品⾥任意取，放进容量为<code>j</code>的背包，价值总和最⼤是多少。</p><p>不放物品i:  <code>dp[i-1] [j]</code></p><p>放物品i:<code>dp[i-1] * [j - weight[ i ]] + value[ i ]</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//测试代码void test_2_wei_bag_problem1() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    int bagweight = 4;    // 二维数组    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));    // 初始化    for (int j = weight[0]; j <= bagweight; j++) {        dp[0][j] = value[0];    }    // weight数组的大小 就是物品个数    for(int i = 1; i < weight.size(); i++) { // 遍历物品        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量            if (j < weight[i]) dp[i][j] = dp[i - 1][j];            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);        }    }    cout << dp[weight.size() - 1][bagweight] << endl;}int main() {    test_2_wei_bag_problem1();}</code></pre><h4 id="一维dp数组——用物品去遍历不同重量的背包"><a href="#一维dp数组——用物品去遍历不同重量的背包" class="headerlink" title="一维dp数组——用物品去遍历不同重量的背包"></a>一维dp数组——用物品去遍历不同重量的背包</h4><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[ i-1 ] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p><strong>所以递归公式为：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></pre><p>一维dp数组<strong>遍历顺序</strong>比较固定：</p><ul><li>物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历</li></ul><p>注意：</p><ul><li>若先遍历重量，则每个重量的背包只放了一个物品</li><li>若正序遍历重量，则存在物品被放置多次的现象</li></ul><p>代码如下：</p><pre class=" language-lang-text"><code class="language-lang-text">for(int i = 0; i < weight.size(); i++) { // 遍历物品    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);    }}</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_1_wei_bag_problem() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    int bagWeight = 4;    // 初始化    vector<int> dp(bagWeight + 1, 0);    for(int i = 0; i < weight.size(); i++) { // 遍历物品        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);        }    }    cout << dp[bagWeight] << endl;}int main() {    test_1_wei_bag_problem();}</code></pre><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接(opens new window)</a></p><p>题目难易：中等</p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100， 数组的大小不会超过 200</p><p>示例 1:</p><ul><li>输入: [1, 5, 11, 5]</li><li>输出: true</li><li>解释: 数组可以分割成 [1, 5, 5] 和 [11].</li></ul><p>转换：</p><p>背包最⼤重量为11。<br>              重量    价值<br>物品0      1          1<br>物品1      5          5<br>物品2     11        11<br>物品3      5          5</p><p>思路：</p><p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为target = sum / 2</li><li>背包要放入的商品（集合里的元素）<strong>重量为 元素的数值</strong>，<strong>价值也为元素的数值</strong></li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。即寻找dp[target] == target</li><li>背包中每一个元素是不可重复放入。</li></ul><p>我的：</p><p>背包能放的最大价值（等价于最大重量），就是刚好放满</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canPartition(vector<int>& nums) {        int sum = 0;        // dp[j]容量为j的背包，所背的物品价值可以最大为dp[j]。        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了        vector<int> dp(10001, 0);        for (int i = 0; i < nums.size(); i++) {            sum += nums[i];        }        // 也可以使用库函数一步求和        // int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum % 2 == 1) return false;        int target = sum / 2;        // 开始 01背包        for(int i = 0; i < nums.size(); i++) {            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);                if (dp[target] == target) return true;            }        }        // // 集合中的元素正好可以凑成总和target        // if (dp[target] == target) return true;        return false;    }};</code></pre><h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h2><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接(opens new window)</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；</p><p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例：</p><ul><li>输入：[2,7,4,1,8,1]</li><li>输出：1</li></ul><p>解释：</p><ul><li><p>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</p></li><li><p>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</p></li><li><p>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</p></li><li><p>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p></li></ul><p>思路：</p><p>本题其实就是<strong>尽量</strong>让石头<strong>分成重量相同的两堆</strong>，相撞之后剩下的石头最小</p><ol><li><p>dp数组含义：dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背的最大重量</p></li><li><p>递推公式：<strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li>初始化： dp的size初始化为最大重量，value初始化为0；<code>vector&lt;int&gt; dp(15001, 0);</code></li><li>确定遍历顺序：同01背包</li><li>举例推导dp数组</li></ol><p>最后dp[target]里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。<strong>target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>所以<code>return sum - dp[target] - dp[target];</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int lastStoneWeightII(vector<int>& stones) {        vector<int> dp(15001,0);        int sum = 0;        for (int i = 0; i < stones.size(); i++) {            sum += stones[i];        }        int target = sum / 2;        //先遍历物品，再遍历容量        for(int i = 0; i < stones.size(); i++){            for(int j = target; j >= stones[i]; j--){                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);            }        }        return sum - dp[target] - dp[target];    }};</code></pre><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接(opens new window)</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><ul><li>输入：nums: [1, 1, 1, 1, 1], S: 3</li><li>输出：5</li></ul><p>解释：</p><ul><li>-1+1+1+1+1 = 3</li><li>+1-1+1+1+1 = 3</li><li>+1+1-1+1+1 = 3</li><li>+1+1+1-1+1 = 3</li><li>+1+1+1+1-1 = 3</li></ul><p>思路：</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = target</p><p>x = (target + sum) / 2</p><ol><li>dp数组含义：dp[j]表示填满容积为j的背包，有多少种组合</li><li></li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findTargetSumWays(vector<int>& nums, int S) {        int sum = 0;        for (int i = 0; i < nums.size(); i++) sum += nums[i];        if (abs(S) > sum) return 0; // 此时没有方案        if ((S + sum) % 2 == 1) return 0; // 此时没有方案        int bagSize = (S + sum) / 2;        vector<int> dp(bagSize + 1, 0);        dp[0] = 1;        for (int i = 0; i < nums.size(); i++) {            for (int j = bagSize; j >= nums[i]; j--) {                dp[j] += dp[j - nums[i]];            }        }        return dp[bagSize];    }};</code></pre><p>记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] += dp[j - nums[i]];</code></pre><h2 id="474-一和零——二维背包"><a href="#474-一和零——二维背包" class="headerlink" title="474.一和零——二维背包"></a>474.一和零——二维背包</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 ：</p><ul><li>输入：strs = [“10”, “0”, “1”], m = 1, n = 1</li><li>输出：2</li><li>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</li></ul><p><strong>思路：</strong></p><p>二维背包</p><ol><li>dp：<strong>最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]</strong>。</li><li>递推公式：dp [i] [j] 可以由前一个strs里的字符串推导出来，当前str里的字符串有zeroNum个0，oneNum个1（其实就相当于重量）。dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</li><li>初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</li><li><strong>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历</strong></li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findMaxForm(vector<string>& strs, int m, int n) {        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0        for (string str : strs) { // 遍历物品            int oneNum = 0, zeroNum = 0;            for (char c : str) {                if (c == '0') zeroNum++;                else oneNum++;            }            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！                for (int j = n; j >= oneNum; j--) {                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);                }            }        }        return dp[m][n];    }};</code></pre><h2 id="动态规划：完全背包理论基础"><a href="#动态规划：完全背包理论基础" class="headerlink" title="动态规划：完全背包理论基础"></a>动态规划：完全背包理论基础</h2><p>完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 先遍历物品，再遍历背包（这个顺序可以调换，但是有区别）for(int i = 0; i < weight.size(); i++) { // 遍历物品    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);    }}</code></pre><h2 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a>518.零钱兑换II</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">力扣题目链接(opens new window)</a></p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><ul><li>输入: amount = 5, coins = [1, 2, 5]</li><li>输出: 4</li></ul><p>解释: 有四种方式可以凑成总金额:</p><ul><li>5=5</li><li>5=2+2+1</li><li>5=2+1+1+1</li><li>5=1+1+1+1+1</li></ul><p>思路：</p><p>背包容量为5，要刚好装满；硬币面额相当于物体重量</p><ol><li>dp[j]：背包容量为j，能装满的<strong>最大方式数</strong></li><li>递推公式   dp[j] += dp[j-coins[i]]</li><li>初始化</li><li>遍历顺序</li></ol><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int change(int amount, vector<int>& coins) {        vector<int> dp(amount + 1,0);        dp[0] = 1;        for(int i = 0; i < coins.size(); i++){            for(int j = coins[i]; j <= amount; j++){                dp[j] += dp[j-coins[i]];            }        }        return dp[amount];    }};</code></pre><p><strong>注意：</strong></p><p>本题要求凑成总和的<strong>组合数</strong>，元素之间明确要求<strong>没有顺序</strong>。纯完全背包是能凑成总和就行，不用管怎么凑的。</p><p>所以本题要 ：<strong>先遍历物品再遍历容量，计算的是组合数</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 0; i < coins.size(); i++) { // 遍历物品    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量        dp[j] += dp[j - coins[i]];    }}</code></pre><p>而先遍历容量再遍历物体，计算的是<strong>排列数</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int j = 0; j <= amount; j++) { // 遍历背包容量    for (int i = 0; i < coins.size(); i++) { // 遍历物品        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];    }}</code></pre><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">力扣题目链接(opens new window)</a></p><p>难度：中等</p><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><ul><li>nums = [1, 2, 3]</li><li>target = 4</li></ul><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7</p><p><strong>思路：</strong></p><p>多重背包问题，求排列数</p><ol><li>dp[j]  :  刚好装满容量为j的背包的最大排列数</li><li>dp[j] += dp[j - nums[i]]</li><li>dp[0] = 1</li><li>先遍历背包，再遍历物品</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int combinationSum4(vector<int>& nums, int target) {        vector<int> dp(target + 1, 0);        dp[0] = 1;        for(int j = 0; j <= target; j++){            for(int i = 0; i < nums.size(); i++){// C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[j] < INT_MAX - dp[j - nums[i]]。这里省去了。ps：数量类型改成longlong还是会超                if (j - nums[i] >= 0) dp[j] += dp[j - nums[i]];            }        }        return dp[target];    }};</code></pre><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">力扣题目链接(opens new window)</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><ul><li>输入：coins = [1, 2, 5], amount = 11</li><li>输出：3</li><li>解释：11 = 5 + 5 + 1</li></ul><p>思路：</p><p>完全背包，求<strong>最少</strong>硬币数</p><p><strong>本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓</strong></p><p>dp[j] 装满背包容量为j的最少硬币数 </p><p>凑足总金额为0所需钱币的个数一定是0，那么<strong>dp[0] = 0;</strong> (为什么不是和求最大数量一样dp[0]=1)</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int coinChange(vector<int>& coins, int amount) {        vector<int> dp(amount + 1, INT_MAX);        dp[0] = 0;        for (int i = 0; i < coins.size(); i++) { // 遍历物品            for (int j = coins[i]; j <= amount; j++) { // 遍历背包                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过,因为+1会溢出，而且最小值还是不变                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);                }            }        }        if (dp[amount] == INT_MAX) return -1;        return dp[amount];    }};</code></pre><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">力扣题目链接(opens new window)</a></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1：</p><ul><li>输入：n = 12</li><li>输出：3</li><li>解释：12 = 4 + 4 + 4</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numSquares(int n) {        vector<int> dp(n+1, INT_MAX);        dp[0] = 0;        for(int i = 1; i <= n; i++){ // i=0也可以，但是没有意义，不会改变结果            for(int j = i*i; j <= n; j++){                if(dp[j - i*i] != INT_MAX){                    dp[j] = min(dp[j], dp[j - i*i] + 1);                }            }        }        //if (dp[n] == INT_MAX) return -1; 由于该问题一定有解，所以加不加这个都行        return dp[n];    }};</code></pre><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">力扣题目链接(opens new window)</a></p><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1：</p><ul><li>输入: s = “leetcode”, wordDict = [“leet”, “code”]</li><li>输出: true</li><li>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</li></ul><p>思路：</p><p>完全背包求排列，先遍历背包再遍历物品      单词就是物品，字符串s就是背包</p><p>dp[j]: 长度为j的背包s刚好能被单词装满</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool wordBreak(string s, vector<string>& wordDict) {        unordered_set <string> wordSet(wordDict.begin(), wordDict.end());        vector<bool> dp(s.size() + 1, false);        dp[0] = true;        for (int i = 1; i <= s.size(); i++) {   // 遍历背包            for (int j = 0; j < i; j++) {       // 遍历物品                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)                if (wordSet.find(word) != wordSet.end() && dp[j] == true) {                    dp[i] = true;                }            }        }        return dp[s.size()];    }};</code></pre><p>or 可以把unordered_set改成用find()函数</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool wordBreak(string s, vector<string>& wordDict) {        int n = s.size();        vector<bool> dp(n + 1, false);        dp[0] = true;        for (int i = 1; i <= n; i++) {            for (int j = 0; j < i; j++) {                if (dp[j] && find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {                    dp[i] = true;                    break;                }            }        }        return dp[n];    }};</code></pre><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>每种物品数量有限(1&lt;= 数量 &lt; 无穷)</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_multi_pack() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    vector<int> nums = {2, 3, 2};    int bagWeight = 10;    vector<int> dp(bagWeight + 1, 0);    for(int i = 0; i < weight.size(); i++) { // 遍历物品        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量            // 以上为01背包，然后加一个遍历个数 ！！！            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);            }        }        // 打印一下dp数组        for (int j = 0; j <= bagWeight; j++) {            cout << dp[j] << " ";        }        cout << endl;    }    cout << dp[bagWeight] << endl;}int main() {    test_multi_pack();}</code></pre><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/">力扣题目链接(opens new window)</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li>示例 1：</li><li>输入：[1,2,3,1]</li><li>输出：4</li></ul><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。</p><p>思路：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p><ol><li>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</li><li>dp[0] = nums[0]   dp[1]  = max(nums[1], nums[0])</li><li>从前向后遍历</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(vector<int>& nums) {        if (nums.size() == 0) return 0;        if (nums.size() == 1) return nums[0];        vector<int> dp(nums.size(), 0);        dp[0] = nums[0];        dp[1] = max(nums[0],nums[1]);        for (int i = 2; i < nums.size(); i++){            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);        }        return dp[nums.size() - 1];    }};</code></pre><h2 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h2><p><a href="https://leetcode.cn/problems/house-robber-ii/">力扣题目链接</a></p><p>相对上一题添加条件： 房间成环，即第一个房间和最后一个房间挨着</p><p>思路:</p><p>考虑两种情况：考虑包含首元素，不包含尾元素；  考虑包含尾元素，不包含首元素</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(vector<int>& nums) {        if (nums.size() == 0) return 0;        if (nums.size() == 1) return nums[0];        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三        return max(result1, result2);    }    // 198.打家劫舍的逻辑    int robRange(vector<int>& nums, int start, int end) {        if (end == start) return nums[start];        vector<int> dp(nums.size());        dp[start] = nums[start];        dp[start + 1] = max(nums[start], nums[start + 1]);        for (int i = start + 2; i <= end; i++) {            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);        }        return dp[end];    }};</code></pre><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h2><p><a href="https://leetcode.cn/problems/house-robber-iii/">力扣题目链接</a></p><p>这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>思路：</p><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p><p>关键是要讨论当前节点抢还是不抢。如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子</p><ol><li><p>确定递归函数的参数和返回值</p><p> 参数为当前节点，代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> vector<int> robTree(TreeNode* cur) {</code></pre><p> 其实这里的返回数组就是dp数组。</p><p> 所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p></li><li><p>终止条件<code>if (cur == NULL) return vector&lt;int&gt;{0, 0};</code></p></li><li><p>确定遍历顺序</p><p> 首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p> 通过递归左节点，得到左节点偷与不偷的金钱。</p><p> 通过递归右节点，得到右节点偷与不偷的金钱。</p><p> 代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> // 下标0：不偷，下标1：偷 vector<int> left = robTree(cur->left); // 左 vector<int> right = robTree(cur->right); // 右 // 中</code></pre></li><li><p>确定单层递归的逻辑</p><p> 当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷 int val1 = cur->val + left[0] + right[0]; //偷 return {val0,val1};</code></pre></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(TreeNode* root) {        vector<int> result = robTree(root);        return max(result[0],result[1]);    }    vector<int> robTree(TreeNode* cur) {        if (cur == NULL) return vector<int>{0, 0};        vector<int> left = robTree(cur->left);        vector<int> right = robTree(cur->right);        int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷        int val1 = cur->val + left[0] + right[0]; //偷        return {val0,val1};    }};</code></pre><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">力扣题目链接(opens new window)</a></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>思路：</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p> dp[i] [0] 表示第i天持有股票所得最多现金 </p><p> dp[i] [1] 表示第i天不持有股票所得最多现金</p></li><li><p>确定递推公式</p><p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li><p>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</p><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p></li><li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p></li><li><p>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p><p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p></li></ul></li><li><p>初始化</p><p> dp[0] [0]  = - prices[0]</p><p> dp[0] [1] = 0</p></li><li><p>遍历顺序从前到后</p><p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        if(prices.size() == 1) return 0;        vector<vector<int>> dp(prices.size(),vector<int>(2)); //注意vector<int>(2) ！        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i < prices.size(); i++){            dp[i][0] = max(dp[i - 1][0], -prices[i]);            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        }        return dp[prices.size()-1][1];    }};</code></pre><p>用滚动数组优化，节省空间复杂度：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本二class Solution {public:    int maxProfit(vector<int>& prices) {        int len = prices.size();        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组        dp[0][0] -= prices[0];        dp[0][1] = 0;        for (int i = 1; i < len; i++) {            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);        }        return dp[(len - 1) % 2][1];    }};</code></pre><h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接(opens new window)</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>思路:</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p> dp[i] [0] 表示第i天持有股票所得最多现金 </p><p> dp[i] [1] 表示第i天不持有股票所得最多现金</p></li><li><p>确定递推公式</p><p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li><p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</p></li><li><p>第i-1天不持有股票，第i天买入股票，<strong>所得现金就是买入今天股票花的钱加上之前赚的钱</strong>：    </p><p>  <strong>dp[i - 1] [1]</strong> - prices[i]</p><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], <strong>dp[i - 1] [1]</strong> - prices[i]); </p><p><strong>！！！加粗部分为和上一题唯一的不同</strong></p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p></li><li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p></li><li><p>第i-1天持有股票，第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p><p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p></li></ul></li><li><p>初始化</p><p> dp[0] [0]  = - prices[0]</p><p> dp[0] [1] = 0</p></li><li><p>遍历顺序从前到后</p><p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        if(prices.size() == 1) return 0;        vector<vector<int>> dp(prices.size(),vector<int>(2));        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i < prices.size(); i++){            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]-prices[i]); // 唯一不同            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        }        return dp[prices.size()-1][1];    }};</code></pre><h2 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">力扣题目链接(opens new window)</a></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。</p><p>思路：</p><ol><li><p>确定dp数组以及下标的含义</p><p> 一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态）</li><li>第一次持有股票</li><li>第一次不持有股票</li><li>第二次持有股票</li><li><p>第二次不持有股票</p><p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j所剩最大现金。</p></li></ol></li><li><p>确定递推公式</p></li></ol><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [1] = dp[i-1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] = dp[i - 1] [1]</li></ul><p>一定是选最大的，所以 dp[i] [1] = max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        int len = prices.size();        if(len == 1) return 0;        vector<vector<int>> dp(len,vector<int>(5));        dp[0][0] = 0;        dp[0][1] = -prices[0];        dp[0][2] = 0;        dp[0][3] = -prices[0];        dp[0][4] = 0;        for(int i = 1; i < len; i++){            dp[i][0] = dp[i - 1][0]; //这个其实一直是0            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); //第一次不买or买            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); //第一次不卖or卖            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);        }        return dp[len-1][4];    }};</code></pre><h2 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">力扣题目链接</a></p><p>最多可以完成K笔交易</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(int k, vector<int>& prices) {        if (prices.size() == 0) return 0;        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));        for (int j = 1; j < 2 * k; j += 2) {            dp[0][j] = -prices[0];        }        for (int i = 1;i < prices.size(); i++) {            for (int j = 0; j < 2 * k - 1; j += 2) {                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);            }        }        return dp[prices.size() - 1][2 * k];    }};</code></pre><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例:</p><ul><li>输入: [1,2,3,0,2]</li><li>输出: 3</li><li>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li></ul><p>思路：</p><ol><li><p>确定dp数组以及下标的含义</p><p> dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p><p> 具体可以区分出如下四个状态：</p></li></ol><ul><li>状态0：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态1：结束冷冻期的状态（前一天是冷冻期。或者是前几天是冷冻期）</li><li>状态2：今天卖出股票</li></ul></li><li>状态3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        int n = prices.size();        if (n == 0) return 0;        vector<vector<int>> dp(n, vector<int>(4, 0));        dp[0][0] -= prices[0]; // 持股票        for (int i = 1; i < n; i++) {            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);            dp[i][2] = dp[i - 1][0] + prices[i];            dp[i][3] = dp[i - 1][2];        }        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));    }};</code></pre><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>思路：</p><p>dp[i] [j]</p><p>0: 持有股票 dp[i] [0] :  dp [i-1] [0]     dp[i-1] [1] - prices[i] </p><p>1：不持有股票 dp[i] [1]: dp[i-1] [1]     dp[i-1] [0] + prices[i] - fee  卖出的时候再扣手续费</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices, int fee) {        int n = prices.size();        if (n == 0) return 0;        vector<vector<int>> dp(n, vector<int>(2, 0));        dp[0][0] -= prices[0]; // 持股票        for (int i = 1; i < n; i++) {            dp[i][0] = max(dp [i-1][0], dp[i-1][1] - prices[i]);            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]- fee);        }        return dp[n-1][1];//题解这里用的max(dp[n - 1][0], dp[n - 1][1]);感觉不太对，一定是不持股的时候钱多；    }};</code></pre><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">力扣题目链接(opens new window)</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><ul><li>输入：nums = [10,9,2,5,3,7,101,18]</li><li>输出：4</li><li>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</li></ul><p><strong>子序列问题是动态规划的一个重要系列</strong></p><p>思路：</p><ol><li><p>dp[i]的定义</p><p> dp[i]表示以<strong>nums[i]结尾</strong>的最长递增子序列的长度</p><p> 因为比较递增，那么一定是比较最后一个数字的大小</p></li><li><p>状态转移方程</p><p> 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p> 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p></li><li><p>dp[i]的初始化</p><p> 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p></li><li><p>确定遍历顺序</p><p> 从前向后遍历。</p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int lengthOfLIS(vector<int>& nums) {        if (nums.size() <= 1) return nums.size();        vector<int> dp(nums.size(), 1);        int result = 0;        for (int i = 1; i < nums.size(); i++) {            for (int j = 0; j < i; j++) {                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);            }            result = max(result, dp[i]); // 取长的子序列        }        return result;    }};</code></pre><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">力扣题目链接(opens new window)</a></p><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1：</p><ul><li>输入：nums = [1,3,5,4,7]</li><li>输出：3</li><li>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findLengthOfLCIS(vector<int>& nums) {        if(nums.size() == 0) return 0;        int n = nums.size();        int result = 1;        vector<int> dp(n, 1);        for(int i = 1; i < n; i++){            if(nums[i] > nums[i - 1]){                dp[i] = dp[i-1] + 1;            }            result = max(result,dp[i]);        }        return result;    }};</code></pre><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">力扣题目链接(opens new window)</a></p><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例：</p><p>输入：</p><ul><li>A: [1,2,3,2,1]</li><li>B: [3,2,1,4,7]</li><li>输出：3</li><li>解释：长度最长的公共子数组是 [3, 2, 1] 。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] ：以下标i为结尾的A，和以下标j为结尾的B，最长重复子数组长度为dp[i][j]//if(nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;//dp[0][j] class Solution {public:    int findLength(vector<int>& nums1, vector<int>& nums2) {        int n1 = nums1.size();        int n2 = nums2.size();        int result = 0;        vector<vector<int>> dp(n1,vector<int>(n2,0));        // 要对第一行，第一列经行初始化        for (int i = 0; i < nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;        for (int j = 0; j < nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1;        for (int i = 0; i < nums1.size(); i++) {            for (int j = 0; j < nums2.size(); j++) {                if(nums1[i] == nums2[j] && i > 0 && j >0) dp[i][j] = dp[i-1][j-1] + 1;                result = max(result,dp[i][j]);            }        }        return result;    }};</code></pre><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]//if(text1[i-1] == text2[i-1])  dp[i][j] = dp[i-1][j-1] + 1;//else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);class Solution {public:    int longestCommonSubsequence(string text1, string text2) {        int n1 = text1.size();        int n2 = text2.size();        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));        for (int i = 1; i <= text1.size(); i++) {            for (int j = 1; j <= text2.size(); j++) {                if (text1[i - 1] == text2[j - 1]) {                    dp[i][j] = dp[i - 1][j - 1] + 1;                } else {                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);                }            }        }        return dp[n1][n2];    }};</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxSubArray(vector<int>& nums) {        int n = nums.size();        vector<int> dp(n);        dp[0] = nums[0];        int result = dp[0];        for(int i = 1; i < n; i++){            dp[i] = max(dp[i - 1] + nums[i], nums[i]);            result = max(result, dp[i]);         }        return result;    }};</code></pre><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h2><p><a href="https://leetcode.cn/problems/is-subsequence/">力扣题目链接(opens new window)</a></p><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p><p>示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false</p><p>可以发现和 <a href="https://programmercarl.com/1143.最长公共子序列.html">1143.最长公共子序列 (opens new window)</a>的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isSubsequence(string s, string t) {        int n1 = s.size();        int n2 = t.size();        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));        for (int i = 1; i <= n1; i++) {            for (int j = 1; j <= n2; j++) {                if (s[i - 1] == t[j - 1]) {                    dp[i][j] = dp[i - 1][j - 1] + 1;                } else {                    dp[i][j] = dp[i][j-1];                }            }        }        return dp[n1][n2] == n1;    }};</code></pre><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。class Solution {public:    int numDistinct(string s, string t) {        int n1 = s.size();        int n2 = t.size();        vector<vector<uint64_t>> dp(n1+1,vector<uint64_t> (n2+1,0));        for (int i = 0; i <= n1; i++) dp[i][0] = 1;        for(int i = 1; i <= n1; i++){            for(int j = 1; j <= n2; j++){                // dp[i-1][j] 不用 s的最后一位 来匹配                // dp[i-1][j-1]表示s和t最后一位已经匹配，                if(s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j];                else dp[i][j] = dp[i-1][j];            }        }        return dp[n1][n2];       }};</code></pre><h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h2><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">力扣题目链接(opens new window)</a></p><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><p>示例：</p><ul><li>输入: “sea”, “eat”</li><li>输出: 2</li><li>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//求最长公共子序列class Solution {public:    int minDistance(string word1, string word2) {        int n1 = word1.size();        int n2 = word2.size();        vector<vector<int>> dp(n1 + 1, vector<int> (n2 + 1, 0));        for(int i = 1; i <= n1; i++){            for(int j = 1; j <= n2; j++){                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            }         }        return n1+n2-2*dp[n1][n2];    }};</code></pre><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p><a href="https://leetcode.cn/problems/edit-distance/">力扣题目链接(opens new window)</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 长度为i的word1 转换成 长度为j的word2 所使用的最少操作数// 插：word2删1  删：word1删1  换：都删1class Solution {public:    int minDistance(string word1, string word2) {        int l1 = word1.size();        int l2 = word2.size();        vector<vector<int>> dp(l1 + 1, vector<int>(l2 + 1, 0));        for(int i = 0; i <= l1; i++) dp[i][0] = i;        for(int j = 0; j <= l2; j++) dp[0][j] = j;        for (int i = 1; i <= l1; i++) {            for (int j = 1; j <= l2; j++) {                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];                else {                    int n1 = dp[i-1][j] + 1;                    int n2 = dp[i][j-1] + 1;                    int n3 = dp[i-1][j-1] + 1;                    dp[i][j] = min(min(n1,n2),n3);                }            }        }        return dp[l1][l2];    }};</code></pre><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><ul><li>输入：”abc”</li><li>输出：3</li><li>解释：三个回文子串: “a”, “b”, “c”</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。//dp[i + 1][j - 1] 在 dp[i][j]的左下角 ,要从左下开始遍历，顺序是从下到上，从左到右。class Solution {public:    int countSubstrings(string s) {        int n = s.size();        int result = 0;        vector<vector<int>> dp(n,vector<int>(n,0));        // dp[0][0] = 1;        for(int i = n-1; i >= 0; i--){            for(int j = i; j < n; j++){                if(s[i] != s[j]) dp[i][j] = 0;                else{                    if(i == j) {                        dp[i][j] = 1;                        result++;                    }                    else if(j-i == 1) {                        dp[i][j] = 1;                        result++;                    }                    else {                        if(dp[i+1][j-1]){                            dp[i][j] = 1;                            result++;                        }                    }                }            }        }        return result;    }};</code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p><p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 表示s[i,j] 最长的回文子串//画图理解  i表示行，j表示列class Solution {public:    int longestPalindromeSubseq(string s) {        int n = s.size();        int result = 0;        vector<vector<int>> dp(n,vector<int>(n,0));        for(int i = n-1; i >= 0; i--){            for(int j = i; j < n; j++){                if(s[i] == s[j]) {                    if(i == j) dp[i][j] = 1;                    else if(j-i == 1) dp[i][j] = 2;                    else dp[i][j] = dp[i+1][j-1] + 2;                }else{                    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);                }            }        }        return dp[0][n-1];    }};</code></pre>]]></content>
    
    
    <summary type="html">动态规划基础知识
动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

动规五部曲：

 1. 确定dp数组（dp table）以及下标的含义
 2. 确定递推公式
 3. dp数组如何初始化
 4. 确定遍历顺序
 5. 举例推导dp数组

509. 斐波那契数
力扣题目链接(opens new window)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:57.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverseString(vector<char>& s) {        char temp;        int left = 0;        int right = s.size() - 1;        while(left < right){            temp = s[right];            s[right] = s[left];            s[left] = temp;            left++;            right--;        }    }};</code></pre><p>解析答案：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void reverseString(vector<char>& s) {    for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {        swap(s[i],s[j]); //注意何时使用库函数    }}</code></pre><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseStr(string s, int k) {        for(int i = 0; i < s.size(); i = i + 2*k){            if(i + k > s.size()) reverse(s.begin()+i,s.end());            else reverse(s.begin()+i,s.begin()+i+k);        }        return s;    }    //也可自己构造reverse,但要记住官方的reverse是左闭右开    // void reverse_me(string& s, int start, int end) {    //     for (int i = start, j = end+1; i < j; i++, j--) {    //         swap(s[i], s[j-1]);    //     }    // }};</code></pre><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>思路：</strong></p><p>首先扩充数组到每个空格替换成”%20”之后的大小。</p><p>然后从后向前替换空格，也就是双指针法</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        int length = s.size();        for(int i = 0; i < s.size(); i++){            if(s[i] == ' '){                length = length + 2;            }        }        int left = s.size() - 1;        int right = length - 1;        s.resize(length);        while(left >= 0){            if(s[left] == ' '){                s[right] = '0';                s[right-1] = '2';                s[right-2] = '%';                right = right - 3;            }else{                s[right] = s[left];                right--;             }            left--;        }        return s;    }};</code></pre><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词*"></a>翻转字符串里的单词*</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><strong>思路：</strong></p><p>若要不额外占用空间，首先去除多余空格，再翻转整个字符串，再用双指针翻转每个单词</p><p><strong>我的：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseWords(string s) {        //双指针去除多余空格        int a = 0,b = 0;        while(a == 0 && s[b] == ' ') b++;        for(;b < s.size(); b++){            if(s[b] == ' ' && (s[b+1] == ' ' || b+1 >= s.size())) continue;             else {                s[a] = s[b];                a++;            }        }        s.resize(a);        //翻转字符串        reverse(s,0,s.size());        //双指针翻转每个单词        for(int c = 0,d = 0; d <= s.size(); d++){            if(s[d] == ' '|| d == s.size()){                reverse(s,c,d);                c = d + 1;            }        }        return s;    }    //左闭右开    void reverse(string& s, int start, int end) {        for (int i = start, j = end-1; i < j; i++, j--) {            swap(s[i], s[j]);        }    }};</code></pre><p><strong>题解：</strong></p><p><a href="https://www.cnblogs.com/zou-ma/p/16162731.html">https://www.cnblogs.com/zou-ma/p/16162731.html</a> </p><p>在 for 循环中，<code>i++</code>和 <code>++i</code>是一样一样的，但是<code>++i</code>的循环耗时短。</p><p>使用<code>++i</code>是一定程度上的系统优化</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []        for (int i = start, j = end; i < j; i++, j--) {            swap(s[i], s[j]);        }    }    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html        for (int i = 0; i < s.size(); ++i) { //            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。                    s[slow++] = s[i++];                }            }        }        s.resize(slow); //slow的大小即为去除多余空格后的大小。    }    string reverseWords(string s) {        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。        reverse(s, 0, s.size() - 1);        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。        for (int i = 0; i <= s.size(); ++i) {            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。                start = i + 1; //更新下一个单词的开始下标start            }        }        return s;    }};</code></pre><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><p><strong>题解：</strong></p><p>整体反转+局部反转就可以实现反转单词顺序的目的</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseLeftWords(string s, int n) {        reverse(s.begin(),s.end());        reverse(s.begin(),s.end()-n);        reverse(s.end()-n,s.end());        return s;    }};</code></pre><h2 id="实现-strStr-——KMP算法"><a href="#实现-strStr-——KMP算法" class="headerlink" title="实现 strStr()——KMP算法"></a>实现 strStr()——KMP算法</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">力扣题目链接(opens new window)</a></p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h4 id="kmp算法："><a href="#kmp算法：" class="headerlink" title="kmp算法："></a>kmp算法：</h4><p>那么使用KMP可以解决两类经典问题：</p><ol><li>匹配问题：<a href="https://programmercarl.com/0028.实现strStr.html">28. 实现 strStr()(opens new window)</a></li><li>重复子串问题：<a href="https://programmercarl.com/0459.重复的子字符串.html">459.重复的子字符串</a></li></ol><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>文本串：aabaabaaf</p><p>模式串：aabaaf</p><p>next数组就是一个前缀表（prefix table），即最长相等前后缀</p><p>前缀：包含首字母，不包含尾字母的所有子串</p><p>后缀：包含尾字母，不包含首字母的所有子串</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>前缀表的求法：</p><p><img src="/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230212143008343.png" alt="image-20230212143008343" style="zoom: 25%;"></p><p>遇见冲突后找冲突的前一位所对应的前缀表，再从前缀表所对下标处继续匹配</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p>初始化： j 指向前缀末尾位置（也是当前公共前后缀的长度）   i 指向后缀末尾位置</p><p>前后缀不相同</p><p>前后缀相同</p><p>更新next数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext(int* next, const string& s) {        //初始化        int j = 0;        next[0] = 0;        // 相等就加（(i 和 j 都得加，而j加1后刚好等于当前i对应的next)，不相等就回溯;先考虑不相等的情况        for(int i = 1; i < s.size(); i++) {            while (j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if (s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    int strStr(string haystack, string needle) {        if (needle.size() == 0) {            return 0;        }        int next[needle.size()];        getNext(next, needle);        int j = 0;        for (int i = 0; i < haystack.size(); i++) {            while(j > 0 && haystack[i] != needle[j]) {                j = next[j - 1];            }            if (haystack[i] == needle[j]) {                j++;            }            if (j == needle.size() ) {                return (i - needle.size() + 1);            }        }        return -1;    }};</code></pre><h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><p><strong>思路：</strong></p><p>字符串s：abcabc</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt="图二"></p><p>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>我的思路：可用上题的strStr()找</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">    bool repeatedSubstringPattern(string s) {        string t = s + s;        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾        if(strStr(t,s) != -1) return true;        return false;    }</code></pre><p>用KMP算法：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728212157.png" alt="图四" style="zoom:50%;"></p><p>如果len % (len - (next[len - 1])) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext (int* next, const string& s){        next[0] = 0;        int j = 0;        for(int i = 1;i < s.size(); i++){            while(j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if(s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    bool repeatedSubstringPattern(string s) {        int len = s.size();        int next[len];        getNext(next, s);        if(next[len - 1] != 0 && len % (len - (next[len - 1])) == 0) return true;        else return false;    }};</code></pre>]]></content>
    
    
    <summary type="html">反转字符串
力扣题目链接(opens new window)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：[“h”,”e”,”l”,”l”,”o”]
输出：[“o”,”l”,”l”,”e”,”h”]

示例 2：
输入：[“H”,”a”,”n”,”n”,”a”,”h”]
输出：[“h”,”a”,”n”,”n”,”a”,”H”]

class Solutio</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E6%95%B0%E7%BB%84/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-08T11:02:21.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>坚持<strong>左闭右闭or左闭又开</strong><ul><li>while(left &lt;= right)  or  while(left &lt; right)</li></ul></li><li>比较left、middle和right三个值</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本一class Solution {public:    int search(vector<int>& nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] > target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] < target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本二class Solution {public:    int search(vector<int>& nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <            int middle = left + ((right - left) >> 1);            if (nums[middle] > target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] < target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};</code></pre><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><p><strong>双指针法（快慢指针法</strong>）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><ul><li>快指针：寻找不等于有目标元素的值 （通常快指针就是for循环里面的索引）</li><li>慢指针：指向新数组最后一个下标的位置</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">        for (int fast=0;fast<nums.size();fast++){            if (nums[fast] != val){                nums[slow] = nums[fast];                slow++;            }        }</code></pre><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。<br>示例：<br>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组</p></blockquote><p><strong>滑动窗口</strong>：不断的调节子序列的起始位置和终止位置。其实算是双指针法的一种，一个指向滑动窗口起始位置，一个指向末端。</p><p>滑动窗口主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p><img src="/2023/02/01/cpp/%E6%95%B0%E7%BB%84/209.长度最小的子数组.gif" alt="209.长度最小的子数组"></p>]]></content>
    
    
    <summary type="html">二分查找
 * 坚持左闭右闭or左闭又开 * while(left &amp;lt;= right) or while(left &amp;lt; * 比较left、middle和right三个值 版本一 class solution { public: int search(vector&lt;int&gt;&amp;amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left &lt;!--=--&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:58.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806194529815.png" alt="链表1"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单链表struct ListNode {    int val;  // 节点上存储的元素    ListNode *next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL};</code></pre><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/image-20221218173554982.png" alt="image-20221218173554982"></p><p>删除节点和添加节点：</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195114541.png" alt="链表-删除节点"></p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195134331.png" alt="链表-添加节点"></p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195200276.png" alt="链表-链表与数据性能对比"></p><p>使用C，C++编程语言的话，不要忘了还要从<strong>内存中删除</strong>被移除的节点</p><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>为了使用一种统一的逻辑来移除链表的节点，我们可以设置<strong>虚拟头节点</strong></p><p>最后在题目中，return 头结点的时候，需要 <code>return dummyNode-&gt;next;</code></p><h3 id="新建虚拟头节点："><a href="#新建虚拟头节点：" class="headerlink" title="新建虚拟头节点："></a>新建虚拟头节点：</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">ListNode* dummyHead = new ListNode(-1);</code></pre><p>注：当需要避免对头节点的情况进行特殊处理时，采用虚拟头节点</p><p><a href="https://blog.csdn.net/qq_54182926/article/details/119193250">(63条消息) C++之new的使用_软硬兼施的程序员的博客-CSDN博客_c++ new</a></p><p>一、new的使用。<br>new+数据类型（初值），返回值为申请空间的对应数据类型的地址。<br>1.使用new申请一个对象</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *p = new int(10);//申请了一个初值为10的整型数据</code></pre><p>2.使用new申请数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *arr = new int[10];//申请了能存放10个整型数据元素的数组，其首地址为arr</code></pre><p>二、delete运算符的使用。<br>new运算符通常搭配delete元素安抚来使用，new用来动态申请存储空间，delete用于释放new申请的空间。<br>语法格式如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">delete p；delete[] arr;//注意要删除数组时，需要加[]，以表示arr为数组。</code></pre><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>双指针法</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>双指针法：fast先走n+1步，slow再和fast同时走。注意使用虚拟头节点</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img" style="zoom:50%;"></p><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>思路：相交部分长度相同，交点处指针相等。即先将长度对齐，再比较指针是否相同。</p><p>注：<strong>判断链表结束是看是否指向NULL，</strong>而不是0。没有使用虚拟头节点的话，判断如下<code>while(curA != NULL)</code>,不需要用curA-&gt;next</p><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p><strong>判断环内相遇</strong>：双指针，慢指针每走一步，快指针走两步，如果两指针相遇，则表明有环。</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/141.环形链表.gif" alt="141.环形链表"></p><p><strong>找到环的入口：</strong>（快指针可能走N圈才会和慢的相遇）</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/142.环形链表II（求入口）.gif" alt="142.环形链表II（求入口）"></p><p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>]]></content>
    
    
    <summary type="html">链表理论基础


// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL
};




删除节点和添加节点：







使用C，C++编程语言的话，不要忘了还要从内存中删除被移除的节点

移除链表元素
为了使用一种统一的逻辑来移除链表的节点，我们可以设置虚拟头节点

最后在题目中，return 头结点的时候，需要 retu</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-03T01:24:08.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法理论基础"><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接(opens new window)</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>思路：排序后遍历，将最大的饼干喂给能喂饱的胃口最大的孩子。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findContentChildren(vector<int>& g, vector<int>& s) {        sort(g.begin(), g.end());        sort(s.begin(), s.end());        int index = s.size() - 1; // 饼干数组的下标        int result = 0;        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口             if (index >= 0 && s[index] >= g[i]) { // 遍历饼干                 result++;                index--;            }        }        return result;    }};</code></pre><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/">力扣题目链接(opens new window)</a></p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>思路：</p><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int candy(vector<int>& ratings) {        vector<int> candyVec(ratings.size(), 1);        // 从前向后        for (int i = 1; i < ratings.size(); i++) {            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;        }        // 从后向前        for (int i = ratings.size() - 2; i >= 0; i--) {            if (ratings[i] > ratings[i + 1] ) {                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);            }        }        // 统计结果        int result = 0;        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];        return result;    }};</code></pre><h3 id="BM96-主持人调度（二）"><a href="#BM96-主持人调度（二）" class="headerlink" title="BM96 主持人调度（二）"></a><strong>BM96</strong> <strong>主持人调度（二）</strong></h3><h2 id="方法二（排序-贪心）"><a href="#方法二（排序-贪心）" class="headerlink" title="方法二（排序+贪心）"></a>方法二（排序+贪心）</h2><h4 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1.解题思路"></a>1.解题思路</h4><ul><li>首先建立两个数组分别存储开始时间（记为start）和结束时间（记为end）。</li><li>然后分别对start和end数组进行排序。</li><li>接着遍历start数组，判断当前开始时间是否大于等于最小的结束时间，如果是，则说明当前主持人就可以搞定（对应当前最小的结束时间的那个活动）；如果否，则需要新增一个主持人，并将end数组下标后移（表示对应的活动已经有人主持）。</li></ul><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">public class Solution {    public int minmumNumberOfHost (int n, int[][] startEnd) {        //初始化两个数组，分别记录开始时间和结束时间 ， 用vector也可以        int[] start=new int[n];        int[] end=new int[n];        //将活动的开始和结束时间赋值道start和end数组        for(int i=0;i<n;i++){            start[i]=startEnd[i][0];            end[i]=startEnd[i][1];        }        //按从小到大的顺序对start和end数组排序        Arrays.sort(start);        Arrays.sort(end);        int res=0,index=0;        for(int i=0;i<n;i++){            //如果大于等于当前最小的结束时间，说明当前主持人可以搞定 ????why？？？            if(start[i]>=end[index]){                index++;            }            //否则，需要新增主持人            else{                res++;            }        }        return res;    }}</code></pre><h4 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h4><ul><li>时间复杂度：需要进行排序，排序接口的时间复杂度是<script type="math/tex">O(nlogn)</script>，所以时间复杂度为<script type="math/tex">O(nlogn)</script></li><li>空间复杂度：需要额外大小为n的start和end数组，所以空间复杂度为<script type="math/tex">O(n)</script>。</li></ul><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列 *"></a>376. 摆动序列 *</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接(opens new window)</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int wiggleMaxLength(vector<int>& nums) {        if (nums.size() <= 1) return nums.size();        int curDiff = 0; // 当前一对差值        int preDiff = 0; // 前一对差值        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值        for (int i = 0; i < nums.size() - 1; i++) {            curDiff = nums[i + 1] - nums[i];            // 出现峰值            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {                result++;                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff             }        }        return result;    }};</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><ul><li>输入: [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出: 6</li><li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxSubArray(vector<int>& nums) {        int n = nums.size();        int result = INT32_MIN;        int count = 0;        for(int i = 0; i < n; i++){            count += nums[i];            result = max(result,count);            if(count <= 0) count = 0;        }        return result;    }};</code></pre><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p><a href="https://leetcode.cn/problems/jump-game/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: true</li><li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 跳跃覆盖范围究竟可不可以覆盖到终点class Solution {public:    bool canJump(vector<int>& nums) {        int n = nums.size();        if (n == 1) return true;        int cover = 0;        for(int i = 0; i <= cover; i++){            cover = max(cover, i + nums[i]);            if(cover >= n - 1) return true;        }        return false;    }};</code></pre><h2 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h2><p><a href="https://leetcode.cn/problems/jump-game-ii/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: 2</li><li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li></ul><p>说明: 假设你总是可以到达数组的最后一个位置</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//当指针走到cover1的边界时，就需要增加步数，进入cover2阶段class Solution {public:    int jump(vector<int>& nums) {        int cover1 = 0;        int cover2 = 0;        int n = nums.size();        int count = 0;        for(int i = 0; i <= cover1; i++){            if(cover1 >= n-1) break;            cover2 = max(cover2, i + nums[i]);            if(i == cover1 && i < n){                count++;                cover1 = cover2;            }        }        return count;    }};</code></pre><h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A = [4,2,3], K = 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 无序的数组可以先排序 sort可以自定义比较函数/*第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小(因为有些负数翻转后比原本最小的正数小)第二步：从前向后遍历，遇到负数将其变为正数，同时K--第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完第四步：求和*/class Solution {    //注意这里必须用static boolstatic bool cmp(int a, int b) {    return abs(a) > abs(b);}public:    int largestSumAfterKNegations(vector<int>& A, int K) {        sort(A.begin(), A.end(), cmp);       // 第一步        for (int i = 0; i < A.size(); i++) { // 第二步            if (A[i] < 0 && K > 0) {                A[i] *= -1;                K--;            }        }        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步        int result = 0;        for (int a : A) result += a;        // 第四步        return result;    }};</code></pre><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/">力扣题目链接(opens new window)</a></p><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p>示例 1: 输入:</p><ul><li>gas = [1,2,3,4,5]</li><li>cost = [3,4,5,1,2]</li></ul><p>输出: 3 解释:</p><ul><li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</li><li>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</li><li>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</li><li>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</li><li>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</li><li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li><li>因此，3 可为起始索引。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。 （相当于从0往前一站看）*/class Solution {public:    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {        int curSum = 0;        int minsum = INT_MAX;        for (int i = 0; i < gas.size(); i++) {            int rest = gas[i]-cost[i];            curSum += rest;            minsum = min(minsum,curSum);        }        if(curSum < 0) return -1;        if(minsum >= 0) return 0;        else {            for (int i = gas.size() - 1; i >= 0; i--) {                int rest = gas[i] - cost[i];                minsum += rest;                if (minsum >= 0) {                    return i;                }            }        }        return -1;    }};</code></pre><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2><p><a href="https://leetcode.cn/problems/lemonade-change/">力扣题目链接(opens new window)</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool lemonadeChange(vector<int>& bills) {        vector<int> save(3, 0); //分别记录我有每种钱的数量         if(bills[0] != 5) return false;        for(int i = 0; i < bills.size(); i++){            if(bills[i] == 5) save[0]++;            else if(bills[i] == 10){                   if(save[0]){                    save[0]--;                    save[1]++;                }else return false;            }else{                if(save[1] && save[0]){                    save[1]--;                    save[0]--;                    save[2]++;                }else if(save[0] >= 3){                    save[0] = save[0] - 3;                    save[2]++;                }else return false;            }        }        return true;    }};</code></pre><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">力扣题目链接(opens new window)</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</li><li>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。// 按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面// 按照k为下标重新插入队列// 插入操作很多可以换成链表,代码会用到迭代器来找插入位置class Solution {public:    static bool cmp(const vector<int>& A, const vector<int>& B){        if(A[0] == B[0]) return A[1] < B[1]; //身高相同的话则k小的站前面        return A[0] > B[0]; // 身高一定是从大到小排    }    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {        sort(people.begin(), people.end(), cmp);         vector<vector<int>> que;        for (int i = 0; i < people.size(); i++) {            int position = people[i][1];            que.insert(que.begin() + position, people[i]);        }        return que;    }};</code></pre><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接(opens new window)</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><ul><li>输入：points = [[10,16],[2,8],[1,6],[7,12]]</li><li>输出：2</li><li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 先排序，若后一个气球和前一个重叠，则直接把边界拉成两个气球的最小右边界class Solution {public:    static bool cmp(vector<int>& a, vector<int>& b) {        return a[0] < b[0];    }    int findMinArrowShots(vector<vector<int>>& points) {        sort(points.begin(),points.end(),cmp);        int result = 1;        for(int i = 1; i < points.size(); i++){            if(points[i][0] > points[i-1][1]){ //不重叠                result++;            }else{                points[i][1] = min(points[i][1], points[i-1][1]);            }        }        return result;    }};</code></pre><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接(opens new window)</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 按右边界从小到大排序// 当前左边界没有超过end，就更新end为当前右边界；如果左边界超了end，就result++class Solution {public:    static bool cmp (const vector<int>& a, const vector<int>& b) {        return a[1] < b[1];    }    int eraseOverlapIntervals(vector<vector<int>>& intervals) {        sort(intervals.begin(), intervals.end(), cmp);        int end = intervals[0][1];        int result = 0;        for (int i = 1; i < intervals.size(); i++) {            if(intervals[i][0] >= end) end = intervals[i][1];            else result++;        }        return result;    }};</code></pre><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><p><a href="https://leetcode.cn/problems/partition-labels/">力扣题目链接(opens new window)</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S = “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 统计每一个字符最后出现的位置// 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点class Solution {public:    vector<int> partitionLabels(string S) {        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置        for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置            hash[S[i] - 'a'] = i;        }        vector<int> result;        int left = 0;        int right = 0;        for (int i = 0; i < S.size(); i++) {            right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界            if (i == right) {                result.push_back(right - left + 1);                left = i + 1;            }        }        return result;    }};</code></pre><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接(opens new window)</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    static bool cmp(vector<int>& a, vector<int>& b) {        return a[0] < b[0];    }    vector<vector<int>> merge(vector<vector<int>>& intervals) {        sort(intervals.begin(), intervals.end(), cmp);        int begin = intervals[0][0];        int end = intervals[0][1];        vector<vector<int>> result;        for(int i = 1; i < intervals.size(); i++){            if(intervals[i][0] <= end){                end = max(end, intervals[i][1]);            }else{                result.push_back(vector<int>{begin,end}); //注意这里的初始化方法 如[1,6] vector<int>{1，6}                begin = intervals[i][0];                end = intervals[i][1];            }        }        result.push_back(vector<int>{begin,end});        return result;    }};</code></pre><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//flag 记录降1的位置，后面的全变成9class Solution {public:    int monotoneIncreasingDigits(int n) {        string strNum = to_string(n);        int flag = 0;        for(int i = 1; i < strNum.size(); i++){            if(strNum[i] > strNum[i-1]) flag = i;            else if(strNum[i] < strNum[i-1]){                strNum[flag] = strNum[flag] - 1;                while(flag < strNum.size() - 1){                    flag++;                    strNum[flag] = '9';                }                break;            }        }        return stoi(strNum);    }};</code></pre><h1 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20230401212319522.png" alt="image-20230401212319522" style="zoom:33%;"></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！// 0：该节点无覆盖// 1：本节点有摄像头// 2：本节点有覆盖class Solution {private:    int result;    int traversal(TreeNode* cur) {        // 空节点，该节点有覆盖        if (cur == NULL) return 2;        int left = traversal(cur->left);    // 左        int right = traversal(cur->right);  // 右        // 情况1        // 左右节点都有覆盖        if (left == 2 && right == 2) return 0;        // 情况2 左右节点至少有一个无覆盖的情况        // left == 0 && right == 0 左右节点无覆盖        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头        // left == 0 && right == 2 左节点无覆盖，右节点覆盖        // left == 2 && right == 0 左节点覆盖，右节点无覆盖        if (left == 0 || right == 0) {            result++;            return 1;        }        // 情况3 左右节点至少有一个有摄像头        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头        // left == 1 && right == 1 左右节点都有摄像头        // 其他情况前段代码均已覆盖        if (left == 1 || right == 1) return 2;        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解        // 这个 return -1 逻辑不会走到这里。        return -1;    }public:    int minCameraCover(TreeNode* root) {        result = 0;        // 情况4        if (traversal(root) == 0) { // root 无覆盖            result++;        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">贪心算法理论基础
贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

有同学问了如何验证可不可以用贪心算法呢？

最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。

455.分发饼干
力扣题目链接(opens new window)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:57.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>当我们需要<strong>查询一个元素是否出现过，或者一个元素是否在集合里的时候</strong>，就要第一时间想到哈希法。</p><p><strong>拉链法</strong></p><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235015226.png" alt="哈希表4"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p><strong>线性探测法</strong></p><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235109950.png" alt="哈希表5"></p><p>常见的哈希结构：数组、set（集合）、map（映射）</p><blockquote><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p></blockquote><p><strong>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</strong></p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，不过给我们的使用方式，还是哈希法的使用方式，即key和value。map同理。</p><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><blockquote><p>数组就是简单的哈希表，但是数组的大小可不是无限开辟的</p></blockquote><p>本题使用数组模拟哈希表，数组大小为26，元素值代表字母出现的次数</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/242.有效的字母异位词.gif" alt="242.有效的字母异位词"></p><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20200818193523911.png" alt="349. 两个数组的交集"></p><p>本题结果是无重复的，且没有限制数组的长度，且无需排序，因此使用<strong>unordered_set</strong></p><blockquote><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的长度。</strong>而这道题目没有限制数值的长度，就无法使用数组来做哈希表了。</p><p>（用vector代替数组是否能解决限制长度的问题）</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p></blockquote><p><a href="https://blog.csdn.net/qq_40286920/article/details/124731777">c++ unordered<em>set详细操作</em>好人好事代表nxx的博客-CSDN博客_unordered_set</a></p><p><strong>使用迭代器构造</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">unordered_set<int> set3(set1.begin(), set1.end());</code></pre><p><strong>find()函数——查找</strong><br>//查找2，找到返回迭代器，失败返回end()</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">set1.find(2);</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {        unordered_set<int> result_set;        unordered_set<int> nums_set(nums1.begin(),nums1.end());        for(int num:nums2){            if (nums_set.find(num) != nums_set.end()) {                result_set.insert(num);            }        }        return vector<int>(result_set.begin(), result_set.end()); //注意返回值类型    }};</code></pre><p>注：</p><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int getSum(int n){        int sum = 0;        //取数值各个位上的单数操作        while(n){            sum += (n % 10) * (n % 10); //不可使用^2表示平方            n = n/10;        }        return sum;    }    bool isHappy(int n) {        unordered_set<int> sums_set;        while(1){            int sum = getSum(n);            if(sum == 1) return true;            if(sums_set.find(sum) != sums_set.end()) return false;            sums_set.insert(sum);            n = sum;        }    }};</code></pre><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p><strong>思路：</strong></p><p>每次遍历时要看这个<strong>元素</strong>之前是否出现过–&gt;考虑用哈希</p><p>同时要存元素和下表两个值–&gt;用map–&gt;元素对应key，下标对应value</p><p><strong>题解：</strong></p><p><a href="https://blog.csdn.net/zyc2018/article/details/93591189">(73条消息) C++之auto的使用<em>Waldeinsamkeit</em>的博客-CSDN博客_auto iter</a></p><p><a href="https://blog.csdn.net/u010112268/article/details/81153034">(73条消息) C++中pair的用法_淼淼1111的博客-CSDN博客_pair</a></p><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        std::unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map.insert(pair<int, int>(nums[i], i));//可用此用法            }        }        return {};    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map[nums[i]]=i;  //可用此用法            }        }        return {};    }};</code></pre><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>思路：</strong></p><p>HashMap 存一个数组，如 A。然后计算三个数组之和，如 BCD。时间复杂度为：O(n)+O(n^3)，得到 O(n^3).<br>HashMap 存三个数组之和，如 ABC。然后计算一个数组，如 D。时间复杂度为：O(n^3)+O(n)，得到 O(n^3).<br>HashMap 存两个数组之和，如AB。然后计算两个数组之和，如 CD。时间复杂度为：O(n^2) + O(n^2)，得到 O(n^2).</p><p>要存a+b的所有可能，以及出现的次数</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {        std::unordered_map <int,int> map12;        int sum12;        int sum34;        int num=0;        for(int i = 0; i < nums1.size(); i++){            for(int j = 0; j < nums2.size(); j++){                map12[nums1[i]+nums2[j]]++;            }        }        for(int i = 0; i < nums3.size(); i++){            for(int j = 0; j < nums4.size(); j++){                sum34 = nums3[i]+nums4[j];                if(map12.find(-sum34) != map12.end()){                    num = num + map12[-sum34];                }            }        }        return num;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中        for (int a : A) {   // 注意这种特殊用法            for (int b : B) {                umap[a + b]++;            }        }        int count = 0; // 统计a+b+c+d = 0 出现的次数        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。        for (int c : C) {            for (int d : D) {                if (umap.find(0 - (c + d)) != umap.end()) {                    count += umap[0 - (c + d)];                }            }        }        return count;    }};</code></pre><p>后面大概还剩150道题</p><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        unordered_map <int,int> map;        for(int i = 0; i < magazine.size(); i++){            map[magazine[i]]++;        }        for(int i = 0; i < ransomNote.size(); i++){            if(map.find(ransomNote[i]) != map.end()){                if(map[ransomNote[i]]>0){                    map[ransomNote[i]]--;                }else{                    return false;                }            }else{                return false;            }        }        return true;    }};</code></pre><p><strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 时间复杂度: O(n)// 空间复杂度：O(1)class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int record[26] = {0};        //add        if (ransomNote.size() > magazine.size()) {            return false;        }        for (int i = 0; i < magazine.length(); i++) {            // 通过recode数据记录 magazine里各个字符出现次数            record[magazine[i]-'a'] ++;        }        for (int j = 0; j < ransomNote.length(); j++) {            // 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-'a']--;            // 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-'a'] < 0) {                return false;            }        }        return true;    }};</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中<strong>不可以包含重复</strong>的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p><strong>思考：</strong></p><p>哈希法C++代码:（此题不宜使用哈希法，去重比较复杂）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> result;        sort(nums.begin(), nums.end());        // 找出a + b + c = 0        // a = nums[i], b = nums[j], c = -(a + b)        for (int i = 0; i < nums.size(); i++) {            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组            if (nums[i] > 0) {                break;            }            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重                continue;            }            unordered_set<int> set;            for (int j = i + 1; j < nums.size(); j++) {                if (j > i + 2                        && nums[j] == nums[j-1]                        && nums[j-1] == nums[j-2]) { // 三元组元素b去重                    continue;                }                int c = 0 - (nums[i] + nums[j]);                if (set.find(c) != set.end()) {                    result.push_back({nums[i], nums[j], c});                    set.erase(c);// 三元组元素c去重                } else {                    set.insert(nums[j]);                }            }        }        return result;    }};</code></pre><p>使用双指针法更高效：</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/15.三数之和.gif" alt="15.三数之和"></p><p>遇事不决先排序，两边逼近双指针</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int i = 0; i < nums.size(); i++){            if(nums[i] > 0) break;            //a去重            if(i>0 && nums[i] == nums[i-1]) continue;            //定义双指针            int left = i + 1;            int right = nums.size() - 1;            while(right > left){                int sum = nums[i]+nums[left]+nums[right];                if(sum > 0) right--;                else if(sum <0) left++;                else{                    results.push_back(vector<int>{nums[i],nums[left],nums[right]});                    //去重                    while (right > left && nums[right] == nums[right - 1]) right--;                    while (right > left && nums[left] == nums[left + 1]) left++;                    right--;                    left++;                }            }        }        return results;    }};</code></pre><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接(opens new window)</a></p><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> fourSum(vector<int>& nums, int target) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int j = 0; j < nums.size(); j++){            if(j>0 && nums[j] == nums[j-1]) continue;            for(int i = j + 1; i < nums.size(); i++){                //a去重                if(i>j+1 && nums[i] == nums[i-1]) continue;                //定义双指针                int left = i + 1;                int right = nums.size() - 1;                while(right > left){                    //此处需要强制转换为long，否则会溢出                    long sum =(long) nums[j]+nums[i]+nums[left]+nums[right];                    if(sum > target) right--;                    else if(sum <target) left++;                    else{                        results.push_back(vector<int>{nums[j],nums[i],nums[left],nums[right]});                        //去重                        while (right > left && nums[right] == nums[right - 1]) right--;                        while (right > left && nums[left] == nums[left + 1]) left++;                        right--;                        left++;                    }                }            }        }        return results;    }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在两数之和中map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>map是一种<code>&lt;key, value&gt;</code>的结构，两数之和可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p>]]></content>
    
    
    <summary type="html">哈希表理论基础
哈希表是根据关键码的值而直接进行访问的数据结构。

当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

拉链法

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了



（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-05-30T13:04:19.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h2><p>回溯是递归的副产品，只要有递归就会有回溯。在下文中，<strong>回溯函数也就是递归函数，指的都是一个函数</strong></p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>回溯三部曲：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void backtracking(参数){    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}</code></pre><p>labuladong里面的看法：</p><p>回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝 or 路径」，DFS 算法是在遍历「节点」</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// DFS 算法，关注点在节点void traverse(TreeNode* root) {    if (root == nullptr) return;    printf("进入节点 %s", root); // 处理节点    for (TreeNode* child : root->children) {        traverse(child);    }    printf("离开节点 %s", root); //回溯节点}// 回溯算法，关注点在树枝void backtrack(TreeNode *root) {    if (root == nullptr) return;    for (TreeNode* child : root->children) {        // 做选择        printf("从 %s 到 %s", root, child);        backtrack(child);        // 撤销选择        printf("从 %s 到 %s", child, root);    }}</code></pre><p>我认为dfs和回溯也没啥区别，还是可以用回溯的方式做，只不过要把根节点提前加到路径罢了，不过按这个写更清晰</p><h2 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h2><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接(opens new window)</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><p>思路：</p><p>把组合问题抽象为如下树形结构：</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201123195223940-16777567027868.png" alt="77.组合" style="zoom:33%;"></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        for(int i = startIndex; i <=n; i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><p>剪枝优化题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        // n-i+1 >= k-path.size() 大多数回溯算法的剪枝操作，都是改这里i的范围        for(int i = startIndex; i <= n + 1 - k + path.size(); i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><h2 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接(opens new window)</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><p>思路：</p><p>k是树的深度，n是树的宽度</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9; i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><p>剪枝后：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(sum > targetSum) return;        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9 + 1 - k + path.size(); i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/2020102916424043.png" alt="17.电话号码的字母组合"></p><p>思路：</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    const string letterMap[10] = {        "", // 0        "", // 1        "abc", // 2        "def", // 3        "ghi", // 4        "jkl", // 5        "mno", // 6        "pqrs", // 7        "tuv", // 8        "wxyz", // 9    };    vector<string> result;    string s;    void backtracking(string digits, int index){        if (index == digits.size()) {            result.push_back(s);            return;        }        int digit = digits[index] - '0'; // 将index指向的数字转为int        string letters = letterMap[digit];        for (int i = 0; i < letters.size(); i++) {            s.push_back(letters[i]);            backtracking(digits,index + 1); // 递归            s.pop_back();        }    }    vector<string> letterCombinations(string digits) {        if(digits == "") return result;        backtracking(digits, 0);        return result;    }};</code></pre><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong></p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201223170730367.png" alt="39.组合总和"></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> results;    vector<int> path;    void backtracking(vector<int> candidates, int target, int index, int sum){        if(sum == target){            results.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = index; i < candidates.size(); i++) {            path.push_back(candidates[i]);            backtracking(candidates, target, i, sum + candidates[i]); // 递归            path.pop_back();        }    }    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {        backtracking(candidates, target, 0, 0);        return  results;    }};</code></pre><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接(opens new window)</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：数组candidates中会出现重复数字，需要<strong>排序后去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {        if (sum == target) {            result.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = startIndex; i < candidates.size(); i++) {            // 要对同一树层使用过的元素进行跳过，这是本题的关键            if (i > startIndex && candidates[i] == candidates[i - 1]) {                continue;            }            path.push_back(candidates[i]);            backtracking(candidates, target, sum + candidates[i], i + 1); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            path.pop_back();        }    }public:    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {        path.clear();        result.clear();        // 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0);        return result;    }};</code></pre><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串    bool isPalindrome(const string& s, int start, int end) {        for (int i = start, j = end; i < j; i++, j--) {            if (s[i] != s[j]) {                return false;            }        }        return true;    }    vector<vector<string>> result;    vector<string> path; // 放已经回文的子串    void backtracking (const string& s, int startIndex) {        if (startIndex >= s.size()) {            result.push_back(path);            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isPalindrome(s, startIndex, i)) { // 是回文子串                // 获取[startIndex,i]在s中的子串                string str = s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            } else {                // 如果不是则直接跳过                continue;            }            backtracking(s, i + 1); // 寻找i+1为起始位置的子串            path.pop_back();        // 回溯过程，弹出本次已经填在的子串        }    }    vector<vector<string>> partition(string s) {        backtracking(s, 0);        return result;    }};</code></pre><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接(opens new window)</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,”255.255.111.35”]</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法    bool isValid(const string& s, int start, int end) {        if (start > end) {            return false;        }        if (s[start] == '0' && start != end) { // 0开头的数字不合法                return false;        }        int num = 0;        for (int i = start; i <= end; i++) {            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法                return false;            }            num = num * 10 + (s[i] - '0');            if (num > 255) { // 如果大于255了不合法                return false;            }        }        return true;    }    vector<string> result;// 记录结果    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量    void backtracking(string& s, int startIndex, int pointNum){        if (pointNum == 3) { // 逗点数量为3时，分隔结束            // 判断第四段子字符串是否合法，如果合法就放进result中            if (isValid(s, startIndex, s.size() - 1)) {                result.push_back(s);            }            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点                pointNum++;                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2                pointNum--;                         // 回溯                s.erase(s.begin() + i + 1);         // 回溯删掉逗点            } else break; // 不合法，直接结束本层循环        }    }    vector<string> restoreIpAddresses(string s) {        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了        backtracking(s, 0, 0);        return result;    }};</code></pre><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接(opens new window)</a></p><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><p><strong>子集是收集树形结构中树的所有节点的结果</strong>。<strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int> nums, int index){        result.push_back(path);// 重点！不管到没到最后都要收集结果        //下面这个可要可不要,因为在for循环中给出了判断        if (index >= nums.size()) {            //不是在这里才收集结果            return;        }        for (int i = index; i < nums.size(); i++) {            path.push_back(nums[i]);            backtracking(nums, i + 1); // 递归            path.pop_back();        }    }    vector<vector<int>> subsets(vector<int>& nums) {        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p><p>给定一个可能包含<strong>重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p>思路：</p><p>本题就是在上一题的基础上加上了<strong>去重</strong>，通过<strong>排序去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        result.push_back(path);        //if (startIndex >= nums.size()) {        //    return;        //}        for (int i = startIndex; i < nums.size(); i++) {            //跳过重复元素            if (i > startIndex && nums[i] == nums[i - 1]) {                continue;            }            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> subsetsWithDup(vector<int>& nums) {        sort(nums.begin(), nums.end()); // 去重需要排序        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><ul><li>输入: [4, 6, 7, 7]</li><li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li></ul><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><p>思路：</p><p>不可对原数组进行重排，而且重复的数字不一定挨着出现，所以可以使用哈希表来判断数字是否用过</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        if (path.size() > 1) {            result.push_back(path);            // 注意这里不要加return，要取树上的节点        }        unordered_set<int> uset; // 使用set对本层元素进行去重        for (int i = startIndex; i < nums.size(); i++) {            //若当前数比上一个小（注意上一个是path.back），或者使用过，则跳过            if ((!path.empty() && nums[i] < path.back())                    || uset.find(nums[i]) != uset.end()) {                    continue;            }            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> findSubsequences(vector<int>& nums) {        result.clear();        path.clear();        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接(opens new window)</a></p><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><ul><li>输入: [1,2,3]</li><li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li></ul><p>思路：</p><p>用used数组，用过的记为1</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        // 此时说明找到了一组        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        for (int i = 0; i < nums.size(); i++) {            if (used[i] == true) continue; // path里已经收录的元素，直接跳过            used[i] = true;            path.push_back(nums[i]);            backtracking(nums, used);            path.pop_back();            used[i] = false;        }    }    vector<vector<int>> permute(vector<int>& nums) {        result.clear();        path.clear();        vector<bool> used(nums.size(), false);//注意vector的初始化方式        backtracking(nums, used);        return result;    }};</code></pre><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>可包含重复</strong>数字的序列 nums ，按任意顺序返回所有<strong>不重复</strong>的全排列。</p><p>思路：</p><p>我的：used+set （复杂度很高）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复        for (int i = 0; i < nums.size(); i++) {            if (uset.find(nums[i]) != uset.end()) {                continue;            }            if (used[i] == false) {  //控制同一树枝不重复                uset.insert(nums[i]); // 记录元素                used[i] = true;                path.push_back(nums[i]);                backtracking(nums, used);                path.pop_back();                used[i] = false;            }        }    }public:    vector<vector<int>> permuteUnique(vector<int>& nums) {        result.clear();        path.clear();        // sort(nums.begin(), nums.end()); // 无需排序        vector<bool> used(nums.size(), false);        backtracking(nums, used);        return result;    }};</code></pre><p>题解：</p><p>used+ 排序（用排序来去重）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        // 此时说明找到了一组        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        for (int i = 0; i < nums.size(); i++) {            // used[i - 1] == true，说明同一树支nums[i - 1]使用过            // used[i - 1] == false，说明同一树层nums[i - 1]使用过            // 如果同一树层nums[i - 1]使用过则直接跳过            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {                continue;            }            if (used[i] == false) {                used[i] = true;                path.push_back(nums[i]);                backtracking(nums, used);                path.pop_back();                used[i] = false;            }        }    }public:    vector<vector<int>> permuteUnique(vector<int>& nums) {        result.clear();        path.clear();        sort(nums.begin(), nums.end()); // 排序        vector<bool> used(nums.size(), false);        backtracking(nums, used);        return result;    }};</code></pre><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后*"></a>51. N皇后*</h2><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或<strong>同一斜线</strong>！上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>题解：</p><p>重点是 isValid函数的逻辑</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:vector<vector<string>> result;// n 为输入的棋盘大小// row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector<string>& chessboard) {    if (row == n) {        result.push_back(chessboard);        return;    }    for (int col = 0; col < n; col++) {        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放            chessboard[row][col] = 'Q'; // 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] = '.'; // 回溯，撤销皇后        }    }}bool isValid(int row, int col, vector<string>& chessboard, int n) {    // 检查列    for (int i = 0; i < row; i++) { // 这是一个剪枝        if (chessboard[i][col] == 'Q') {            return false;        }    }    // 检查 45度角是否有皇后    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    // 检查 135度角是否有皇后    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    return true;}public:    vector<vector<string>> solveNQueens(int n) {        result.clear();        vector<string> chessboard(n, string(n, '.'));        backtracking(n, 0, chessboard);        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">回溯算法理论基础
回溯是递归的副产品，只要有递归就会有回溯。在下文中，回溯函数也就是递归函数，指的都是一个函数

回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。

回溯三部曲：

void backtracking(参数){
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); //</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
</feed>
