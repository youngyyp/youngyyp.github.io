<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>young&#39;s blog</title>
  
  <subtitle>慢慢来，比较快</subtitle>
  <link href="https://youngyyp.github.io/atom.xml" rel="self"/>
  
  <link href="https://youngyyp.github.io/"/>
  <updated>2023-03-11T04:36:17.200Z</updated>
  <id>https://youngyyp.github.io/</id>
  
  <author>
    <name>young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/</id>
    <published>2023-03-11T04:36:17.161Z</published>
    <updated>2023-03-11T04:36:17.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冻结模型"><a href="#冻结模型" class="headerlink" title="冻结模型"></a>冻结模型</h2><p><a href="https://www.zhihu.com/question/311095447/answer/589307812">https://www.zhihu.com/question/311095447/answer/589307812</a></p><pre class=" language-lang-python"><code class="language-lang-python"># 冻结model.fc1.weight.requires_grad = Falseoptimizer = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=0.1)# # compute loss # loss.backward()# optmizer.step()# 解冻model.fc1.weight.requires_grad = Trueoptimizer.add_param_group({'params': model.fc1.parameters()})</code></pre><p><strong>终极方法代码实现：</strong></p><pre class=" language-lang-python"><code class="language-lang-python">from collections.abc import Iterabledef set_freeze_by_names(model, layer_names, freeze=True):    if not isinstance(layer_names, Iterable):        layer_names = [layer_names]    for name, child in model.named_children():        if name not in layer_names:            continue        for param in child.parameters():            param.requires_grad = not freezedef freeze_by_names(model, layer_names):    set_freeze_by_names(model, layer_names, True)def unfreeze_by_names(model, layer_names):    set_freeze_by_names(model, layer_names, False)def set_freeze_by_idxs(model, idxs, freeze=True):    if not isinstance(idxs, Iterable):        idxs = [idxs]    num_child = len(list(model.children()))    idxs = tuple(map(lambda idx: num_child + idx if idx < 0 else idx, idxs))    for idx, child in enumerate(model.children()):        if idx not in idxs:            continue        for param in child.parameters():            param.requires_grad = not freezedef freeze_by_idxs(model, idxs):    set_freeze_by_idxs(model, idxs, True)def unfreeze_by_idxs(model, idxs):    set_freeze_by_idxs(model, idxs, False)</code></pre><pre class=" language-lang-python"><code class="language-lang-python"># 冻结第一层freeze_by_idxs(model, 0)# 冻结第一、二层freeze_by_idxs(model, [0, 1])#冻结倒数第一层freeze_by_idxs(model, -1)# 解冻第一层unfreeze_by_idxs(model, 0)# 解冻倒数第一层unfreeze_by_idxs(model, -1)# 冻结 em层freeze_by_names(model, 'em')# 冻结 fc1, fc3层freeze_by_names(model, ('fc1', 'fc3'))# 解冻em, fc1, fc3层unfreeze_by_names(model, ('em', 'fc1', 'fc3'))</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;冻结模型&quot;&gt;&lt;a href=&quot;#冻结模型&quot; class=&quot;headerlink&quot; title=&quot;冻结模型&quot;&gt;&lt;/a&gt;冻结模型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/311095447/answer/589307812&quot;&gt;https://www.zhihu.com/question/311095447/answer/589307812&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot; language-lang-python&quot;&gt;&lt;code class=&quot;language-lang-python&quot;&gt;# 冻结
model.fc1.weight.requires_grad = False
optimizer = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=0.1)
# 
# compute loss 
# loss.backward()
# optmizer.step()

# 解冻
model.fc1.weight.requires_grad = True
optimizer.add_param_group({&#39;params&#39;: model.fc1.parameters()})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;终极方法代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot; language-lang-python&quot;&gt;&lt;code class=&quot;language-lang-python&quot;&gt;from collections.abc import Iterable

def set_freeze_by_names(model, layer_names, freeze=True):
    if not isinstance(layer_names, Iterable):
        layer_names = [layer_names]
    for name, child in model.named_children():
        if name not in layer_names:
            continue
        for param in child.parameters():
            param.requires_grad = not freeze

def freeze_by_names(model, layer_names):
    set_freeze_by_names(model, layer_names, True)

def unfreeze_by_names(model, layer_names):
    set_freeze_by_names(model, layer_names, False)

def set_freeze_by_idxs(model, idxs, freeze=True):
    if not isinstance(idxs, Iterable):
        idxs = [idxs]
    num_child = len(list(model.children()))
    idxs = tuple(map(lambda idx: num_child + idx if idx &lt; 0 else idx, idxs))
    for idx, child in enumerate(model.children()):
        if idx not in idxs:
            continue
        for param in child.parameters():
            param.requires_grad = not freeze

def freeze_by_idxs(model, idxs):
    set_freeze_by_idxs(model, idxs, True)

def unfreeze_by_idxs(model, idxs):
    set_freeze_by_idxs(model, idxs, False)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot; language-lang-python&quot;&gt;&lt;code class=&quot;language-lang-python&quot;&gt;# 冻结第一层
freeze_by_idxs(model, 0)
# 冻结第一、二层
freeze_by_idxs(model, [0, 1])
#冻结倒数第一层
freeze_by_idxs(model, -1)
# 解冻第一层
unfreeze_by_idxs(model, 0)
# 解冻倒数第一层
unfreeze_by_idxs(model, -1)


# 冻结 em层
freeze_by_names(model, &#39;em&#39;)
# 冻结 fc1, fc3层
freeze_by_names(model, (&#39;fc1&#39;, &#39;fc3&#39;))
# 解冻em, fc1, fc3层
unfreeze_by_names(model, (&#39;em&#39;, &#39;fc1&#39;, &#39;fc3&#39;))
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%85%B6%E4%BB%96/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%85%B6%E4%BB%96/</id>
    <published>2023-03-11T04:35:51.071Z</published>
    <updated>2023-03-11T04:35:51.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zotero"><a href="#zotero" class="headerlink" title="zotero"></a>zotero</h2><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>在数据目录中，将 zotero.sqlite 重命名为 zotero.sqlite.old，将其中一个原始.bak文件（基于时间戳）重命名为 zotero.sqlite，然后重新启动 Zotero。现在，您应该会看到库的备份版本。</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>latex公式<a href="https://github.com/windingwind/zotero-better-notes/releases">https://github.com/windingwind/zotero-better-notes/releases</a> （其实zotero自带latex，但是公式后要多加一个空格，这个插件是一个笔记插件）</p><p>zotero-citationcounts：用于从各种来源自动获取引用计数 </p><p>zotero-tag ：加标签</p><h2 id="windows软链接"><a href="#windows软链接" class="headerlink" title="windows软链接"></a>windows软链接</h2><p><a href="https://blog.csdn.net/m0_51977577/article/details/125416891">(54条消息) windows创建软链接_六点零六的博客-CSDN博客_windows 软连接</a></p><p>win + R，输入cmd，不要直接按回车键，按ctrl + shift + enter进入命令操作窗口；（进入管理员模式）</p><p><img src="/2023/03/11/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%85%B6%E4%BB%96/image-20221111101710227.png" alt="image-20221111101710227"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;zotero&quot;&gt;&lt;a href=&quot;#zotero&quot; class=&quot;headerlink&quot; title=&quot;zotero&quot;&gt;&lt;/a&gt;zotero&lt;/h2&gt;&lt;h4 id=&quot;数据恢复&quot;&gt;&lt;a href=&quot;#数据恢复&quot; class=&quot;headerlink&quot; title=&quot;数据恢复&quot;&gt;&lt;/a&gt;数据恢复&lt;/h4&gt;&lt;p&gt;在数据目录中，将 zotero.sqlite 重命名为 zotero.sqlite.old，将其中一个原始.bak文件（基于时间戳）重命名为 zotero.sqlite，然后重新启动 Zotero。现在，您应该会看到库的备份版本。&lt;/p&gt;
&lt;h4 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h4&gt;&lt;p&gt;latex公式&lt;a href=&quot;https://github.com/windingwind/zotero-better-notes/releases&quot;&gt;https://github.com/windingwind/zotero-better-notes/releases&lt;/a&gt; （其实zotero自带latex，但是公式后要多加一个空格，这个插件是一个笔记插件）&lt;/p&gt;
&lt;p&gt;zotero-citationcounts：用于从各种来源自动获取引用计数 &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-03-11T04:35:43.808Z</published>
    <updated>2023-03-11T04:35:43.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>目标检测究竟发展到了什么程度? | CVHub带你聊一聊目标检测发展的这22年<a href="https://mp.weixin.qq.com/s/tZztakvzU9kl0nPbl8oCww">https://mp.weixin.qq.com/s/tZztakvzU9kl0nPbl8oCww</a></p><p>视频学习：<a href="https://space.bilibili.com/18161609/channel/seriesdetail?sid=244160">https://space.bilibili.com/18161609/channel/seriesdetail?sid=244160</a></p><h1 id="目标检测综述"><a href="#目标检测综述" class="headerlink" title="目标检测综述"></a>目标检测综述</h1><p><strong>Anchor based</strong>方法(一阶段，二阶段)和<strong>Anchor free</strong>方法</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/640.jpeg" alt="图片"></p><h2 id="传统算法"><a href="#传统算法" class="headerlink" title="传统算法"></a>传统算法</h2><h3 id="HOG"><a href="#HOG" class="headerlink" title="HOG"></a>HOG</h3><p>HOG (Histogram of Oriented Gradients，方向梯度直方图) </p><p>1）主要思想：</p><p>在一副图像中，局部目标的表象和形状能够被梯度或边缘的方向密度分布很好地描述。其本质为：梯度的统计信息，而梯度主要存在于边缘的地方。</p><p>Hog+SVM做行人识别</p><p>2）实现方法：</p><p>把样本图像分割为若干个像素的单元，把梯度方向平均划分为多个区间，在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计。最后把这些直方图组合起来，就可以构成特征描述符。</p><h3 id="传统方法的缺点"><a href="#传统方法的缺点" class="headerlink" title="传统方法的缺点"></a>传统方法的缺点</h3><p>1）基于滑动窗口的区域选择策略没有针对性,时间复杂度高,窗口冗余</p><p>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="二阶段anchor-based-RCNN系列"><a href="#二阶段anchor-based-RCNN系列" class="headerlink" title="二阶段anchor based - RCNN系列"></a>二阶段anchor based - RCNN系列</h2><p>二阶段检测算法主要分为以下两个阶段<br><strong>Stage1</strong>：从图像中生成region proposals<br><strong>Stage2</strong>：从region proposals生成最终的物体边框。</p><p>[RCNN系列]<a href="https://zhuanlan.zhihu.com/p/383167028">https://zhuanlan.zhihu.com/p/383167028</a></p><h3 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/v2-2ebc675f93f886e008c222880200a274_1440w.webp" alt="img"></p><p>RCNN首先通过选择性搜索算法Selective Search从一组对象候选框中选择可能出现的对象框，然后将这些选择出来的对象框中的图像resize到某一固定尺寸的图像，并喂入到CNN模型和svm模型</p><h3 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h3><p>Fast R-CNN与R-CNN相比主要有以下几点不同：</p><ol><li>不再是对每一个候选区域单独提取特征，而是在提取整个图像的特征后，将每一个候选区域映射到特征图上</li><li>在R-CNN中为了统一输入使用了暴力缩放的方法，但在Fast R-CNN中，使用了RoI Pooling</li><li>使用了多任务的损失函数来简化R-CNN中的多阶段训练</li></ol><p>Fast RCNN不足：</p><ul><li><ul><li>候选区域的选取还是通过selective search，并且只能在CPU中运行这个算法，所以这个阶段浪费了大量时间。（这也是Faster RCNN改进的点）</li></ul></li></ul><h3 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h3><p>Faster RCNN就是RPN+Fast RCNN，具体算法步骤如下</p><ol><li>输入图像到特征提取器中，得到整张图片的feature map。</li><li>使用RPN生成候选框，并投影到feature map上，得到每一个候选区域的特征矩阵。</li><li>将每一个特征矩阵经过ROI Pooling缩放到7*7大小，然后经过展平处理后通过全连接层获得预测的分类以及候选区域位置偏移信息。</li></ol><p>Faster RCNN有三个部分需要训练，分别是特征提取器VGG16，RPN以及RoIHead</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/v2-23115fb3ba6ff0cdd2fc2c51b354bc49_r.jpg" alt="img"></p><p>问：为什么要生成一堆anchor，再对它们进行修正，而不是一开始直接预测anchor的坐标？</p><p>答：其实YOLO v1就是没有使用anchor，直接对候选区域的坐标进行预测，但作者发现，效果并不好，主要是因为网络很难收敛，训练难度较大，所以YOLO的作者后来就将Faster RCC的RPN进行了相关的修改，加入到了YOLO v2中，效果有了显著的提高。</p><h2 id="一阶段anchor-based-YOLO系列"><a href="#一阶段anchor-based-YOLO系列" class="headerlink" title="一阶段anchor based - YOLO系列"></a>一阶段anchor based - YOLO系列</h2><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4cee39e6039ca5ee032f7c488c4b21f7.png" alt="img" style="zoom:50%;"></p><p>backbone <a href="https://blog.csdn.net/qq_38668236/article/details/127378254">https://blog.csdn.net/qq_38668236/article/details/127378254</a></p><p>neck <a href="https://blog.csdn.net/qq_38668236/article/details/127400899">https://blog.csdn.net/qq_38668236/article/details/127400899</a></p><p>head <a href="https://ac.nowcoder.com/discuss/1031260?type=0&amp;order=0&amp;page=1&amp;channel=-1">https://ac.nowcoder.com/discuss/1031260?type=0&amp;order=0&amp;page=1&amp;channel=-1</a></p><p>通俗易懂的YOLO系列（从V1到V5）模型解读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0NjgzMDIxMQ==&amp;mid=2247579969&amp;idx=3&amp;sn=2c4d437570b83b62bdc268cc94aab3ce&amp;chksm=fb545badcc23d2bb5185f4d5131dac466abc75abbd7022d1910916cc44cb9d1d1417173371cb&amp;scene=27">https://mp.weixin.qq.com/s?__biz=MzU0NjgzMDIxMQ==&amp;mid=2247579969&amp;idx=3&amp;sn=2c4d437570b83b62bdc268cc94aab3ce&amp;chksm=fb545badcc23d2bb5185f4d5131dac466abc75abbd7022d1910916cc44cb9d1d1417173371cb&amp;scene=27</a></p><p>总结：</p><p><strong>YOLO v1：直接回归位置。</strong></p><p><strong>YOLO v2：全流程多尺度方法。</strong></p><p><strong>YOLO v3：多尺度检测头，resblock darknet53</strong></p><p><strong>YOLO v4：cspdarknet53，spp，panet，tricks</strong></p><h3 id="YOLO-V1"><a href="#YOLO-V1" class="headerlink" title="YOLO V1"></a>YOLO V1</h3><p>YOLO的作者当时是这么想的：你分类器输出一个one-hot vector，那我把它换成(x,y,w,h,c)，c表示confidence置信度，把问题转化成一个回归问题，直接回归出Bounding Box的位置不就好了吗？</p><p>YOLOv1的缺陷：</p><ol><li>由于YOLOv1每个网格的检测框只有2个，对于密集型目标检测和小物体检测都不能很好适用。 </li><li>Inference时，当同一类物体出现的不常见的长宽比时泛化能力偏弱。 </li><li>由于损失函数的问题，定位误差是影响检测效果的主要原因，尤其是大小物体的处理上，还有待加强。</li></ol><h3 id="YOLO-V2"><a href="#YOLO-V2" class="headerlink" title="YOLO V2"></a>YOLO V2</h3><p>从<strong>直接预测位置</strong>改为<strong>预测一个偏移量</strong>，基于<strong>Anchor框的宽和高</strong>和<strong>grid的先验位置</strong>的<strong>偏移量</strong>，得到最终目标的位置，这种方法也叫作<strong>location prediction</strong>。</p><p>直接预测位置会导致神经网络在一开始训练时不稳定，使用偏移量会使得训练过程更加稳定</p><p>YOLO v2先对每个区域得到了5个anchor作为参考，这些anchor是通过GT聚类得到的</p><h3 id="YOLO-V3"><a href="#YOLO-V3" class="headerlink" title="YOLO V3"></a>YOLO V3</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/640-167817488587921.jpeg" alt="图片" style="zoom: 80%;"></p><p>分出了3个分支，分别为<strong>32倍下采样，16倍下采样，8倍下采样</strong>，分别取预测<strong>大，中，小目标</strong></p><h3 id="YOLO-V4"><a href="#YOLO-V4" class="headerlink" title="YOLO V4"></a>YOLO V4</h3><p>loss做了很多改进</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230307154723215.png" alt="image-20230307154723215" style="zoom:50%;"></p><p>YOLO v4对输入端进行了改进，主要包括<strong>数据增强Mosaic、cmBN、SAT自对抗训练</strong>，使得在卡不是很多时也能取得不错的结果。</p><p>YOLO v4具有极大的工程意义，将近年来深度学习领域最新研究的tricks都引入到了YOLO v4做验证测试</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/640-167817537029823.jpeg" alt="图片" style="zoom:67%;"></p><p>为什么一代比一代检测头更加复杂呢？答案是：因为它们的提特征网络更加强大了，能够支撑起检测头做更加复杂的操作</p><h2 id="Anchor-Free-系列"><a href="#Anchor-Free-系列" class="headerlink" title="Anchor-Free 系列"></a>Anchor-Free 系列</h2><p>基于Anchor的检测算法由于Anchor太多导致计算复杂，及其所带来的大量超参数都会影响模型性能。近年的Anchor free技术则摒弃Anchor，通过确定关键点的方式来完成检测，大大减少了网络超参数的数量。</p><p> <strong>CornerNet</strong>是Anchor free技术路线的开创之作，该网络提出了一种新的对象检测方法，将网络对目标边界框的检测转化为一对关键点的检测(即左上角和右下角)，通过将对象检测为成对的关键点，而无需设计Anchor box作为先验框。</p><h2 id="基于transformer的目标检测"><a href="#基于transformer的目标检测" class="headerlink" title="基于transformer的目标检测"></a>基于transformer的目标检测</h2><h3 id="DETR"><a href="#DETR" class="headerlink" title="DETR"></a>DETR</h3><p>DETR 是 Facebook 团队于 2020 年提出的基于 Transformer 的端到端目标检测，没有非极大值抑制 NMS 后处理步骤、没有 anchor 等先验知识和约束，整个由网络实现端到端的目标检测实现，大大简化了目标检测的 pipeline</p><h2 id="目标检测常见指标"><a href="#目标检测常见指标" class="headerlink" title="目标检测常见指标"></a>目标检测常见指标</h2><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230307102437011-167815588021814.png" alt="image-20230307102437011"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/70.png" alt="在这里插入图片描述"></p><p>precision高可能会漏检，recall高可能出现很多冗余框</p><p>通过调整不同的confidence阈值来构造PR曲线；对于recall相同的点，只取precision最高的。如下：</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230307104915451.png" alt="image-20230307104915451"></p><h2 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h2><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201020204029755.png#pic_center" alt="img" style="zoom:50%;"></p><p>我们可以看到，在图中对狗检测的有很多个框，0.9(a)，0.8(b)，0.7(c)，还有一个对猫的0.9(d)。 NMS极大值抑制就是在不影响猫的框的情况下去除对狗检测的其它得分小的框。 设置阈值th，用a分别对b,c,d,计算IOU值，将IOU值大于th的框都去除。</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/v2-4e9fab45f2fd1a862dbb656296a6ae85_1440w.webp" alt="img" style="zoom:50%;"></p><p>面试的时候会问这样一个问题：NMS的适用情况是什么？</p><p>答：1图多目标检测时用NMS。</p><h2 id="遥感目标检测"><a href="#遥感目标检测" class="headerlink" title="遥感目标检测"></a>遥感目标检测</h2><p>近年来，随着遥感图像分辨率的提高，遥感图像目标检测(如飞机、船舶、油罐等的检测)成为研究热点，遥感图像目标检测具有广泛的应用，如军事侦查、灾害救援、城市交通管理等等。</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/640-167817795102025.png" alt="图片" style="zoom:80%;"></p><p>遥感目标检测任务中存在的难点与挑战可简要概括为如下四点：</p><ol><li><p>遥感图像分辨率巨大<br> 如上图8-5(a)所示，由于遥感图像分辨率巨大，因此如何快速准确的检测出遥感目标仍然是一个挑战性的问题。</p></li><li><p>目标遮挡问题<br> 如上图8-5(b)所示，超过50%的目标被云雾所遮挡，因此目标遮挡问题也是遥感图像目标检测所面临的一个挑战。</p></li><li><p>域适应问题<br> 由不同传感器所捕获的遥感图像仍然存在很大差异。</p></li><li><p>目标小而密集，且任意旋转角</p></li></ol><p>不同传感器所捕获的遥感图像可能会出现以下差异：</p><ul><li><a href="https://www.zhihu.com/question/60276621">光谱差异：不同传感器的波长范围和波段数量可能不同，导致遥感图像的光谱信息和分辨率有所区别</a><a href="https://www.zhihu.com/question/60276621">1</a><a href="https://zhuanlan.zhihu.com/p/428385850">2</a>。</li><li><a href="https://zhuanlan.zhihu.com/p/428385850">空间差异：不同传感器的观测角度和分辨元大小可能不同，导致遥感图像的空间信息和分辨率有所区别</a><a href="https://zhuanlan.zhihu.com/p/428385850">2</a><a href="https://baike.baidu.com/item/多源遥感/22042704">3</a>。</li><li><a href="https://zhuanlan.zhihu.com/p/428385850">辐射差异：不同传感器的响应特性和校正方法可能不同，导致遥感图像的辐射信息和准确度有所区别</a><a href="https://zhuanlan.zhihu.com/p/428385850">2</a>。</li></ul><p><a href="https://www.zhihu.com/question/60276621">因此，在使用多源遥感图像进行分析时，需要进行一定的预处理，如配准、归一化、投影变换等，以消除或减小这些差异对结果的影响</a><a href="https://www.zhihu.com/question/60276621">1</a><a href="https://zhuanlan.zhihu.com/p/428385850">2</a>。</p><h2 id="领域自适应的目标检测"><a href="#领域自适应的目标检测" class="headerlink" title="领域自适应的目标检测"></a>领域自适应的目标检测</h2><p>任何目标检测算法的训练过程本质上都可以看成数据在独立同分布(i.i.d.)下的似然估计过程，而对于不满足(i.i.d.)的目标检测数据(特别是对于一些现实世界的应用程序)仍然是一个挑战，GAN在领域自适应方面已经显示出 了强大的效果，这对于目标检测技术来讲应该具有很大的促进作用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;目标检测究竟发展到了什么程度? | CVHub带你聊一聊目标检测发展的这22年&lt;a href=&quot;https://mp.weixin.qq.com/s/tZztakvzU9kl0nPbl8oCww&quot;&gt;https://mp.weixin.qq.com/s/tZztakvzU9kl0nPbl8oCww&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频学习：&lt;a href=&quot;https://space.bilibili.com/18161609/channel/seriesdetail?sid=244160&quot;&gt;https://space.bilibili.com/18161609/channel/seriesdetail?sid=244160&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;目标检测综述&quot;&gt;&lt;a href=&quot;#目标检测综述&quot; class=&quot;headerlink&quot; title=&quot;目标检测综述&quot;&gt;&lt;/a&gt;目标检测综述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Anchor based&lt;/strong&gt;方法(一阶段，二阶段)和&lt;strong&gt;Anchor free&lt;/strong&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/640.jpeg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/</id>
    <published>2023-03-11T04:35:42.330Z</published>
    <updated>2023-03-11T04:35:42.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/image-20230209151850229.png" alt="image-20230209151850229"></p><p>Domain Generalization (DG):  source data √     target data ×</p><p>Domain Adaptation (DA) —-&gt; Unsupervised DA (UDA) —-&gt; Source-free UDA (SFUDA) —-&gt; Online/Offline SFUDA </p><p>online—数据只见一次—-tent</p><p>offline—shot</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/image-20230209152435394.png" alt="image-20230209152435394"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/image-20230209151850229.png&quot; alt=&quot;image-20230209151850229&quot;&gt;&lt;/p&gt;
&lt;p&gt;Domain Generalization (DG):  source data √     target data ×&lt;/p&gt;
&lt;p&gt;Domain Adaptation (DA) —-&amp;gt; Unsupervised DA (UDA) —-&amp;gt; Source-free UDA (SFUDA) —-&amp;gt; Online/Offline SFUDA &lt;/p&gt;
&lt;p&gt;online—数据只见一次—-tent&lt;/p&gt;
&lt;p&gt;offline—shot&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E5%88%86%E7%B1%BB/image-20230209152435394.png&quot; alt=&quot;image-20230209152435394&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%90%86%E8%A7%A3BN/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%90%86%E8%A7%A3BN/</id>
    <published>2023-03-11T04:35:41.908Z</published>
    <updated>2023-03-11T04:35:41.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/85bab1e5493a4f74a97b8e7b473ad406.jpeg#pic_center" alt="在这里插入图片描述"></p><ul><li><p>BN和Dropout在训练和测试时的差别</p><p>  (<a href="https://www.zhihu.com/people/hai-chen-wei">https://www.zhihu.com/people/hai-chen-wei</a>)</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/61725100">https://zhuanlan.zhihu.com/p/61725100</a></p></li><li><p>我们<strong>在训练和推理过程中BatchNorm有不同的行为</strong>。在训练中，我们记录均值和方差的指数移动平均值，以供以后在推理时使用。其原因是，在训练期间处理批次时，我们可以获得输入随时间变化的均值和方差的更好估计，然后将其用于推理。在推理过程中使用输入批次的平均值和方差将不太准确，因为其大小可能比训练中使用的小得多，大数定律在这里发挥了作用。</p></li><li><p>即model.train()模式下会计算统计参数</p></li><li><p>BN在训练时是在每个batch上计算均值和方差来进行归一化，每个batch的样本量都不大，所以每次计算出来的均值和方差就存在差异。预测时一般传入一个样本，所以不存在归一化，其次哪怕是预测一个batch，但batch计算出来的均值和方差是偏离总体样本的，所以通常是通过滑动平均结合训练时所有batch的均值和方差来得到一个总体均值和方差。</p></li><li><p>Dropout在训练时会随机丢弃一些神经元，这样会导致输出的结果变小。而预测时往往关闭dropout，保证预测结果的一致性（不关闭dropout可能同一个输入会得到不同的输出，不过输出会服从某一分布。另外有些情况下可以不关闭dropout，比如文本生成下，不关闭会增大输出的多样性）。</p></li></ul><p><a href="https://blog.csdn.net/qq_40728667/article/details/121865517">（Pytorch）BatchNorm中的track_running_stats参数_Think@的博客-CSDN博客_track_running_stats</a></p>]]></content>
    
    
    <summary type="html">* BN和Dropout在训练和测试时的差别
   
    (https://www.zhihu.com/people/hai-chen-wei)
   
   
 * https://zhuanlan.zhihu.com/p/61725100
   
   
 * 我们在训练和推理过程中BatchNorm有不同的行为。在训练中，我们记录均值和方差的指数移动平均值，以供以后在推理时使用。其原因是，在训练期间处理批次时，我们可以获得输入随时间变化的均值和方差的更好估计，然后将其用于推理。在推理过程中使用输入批次的平均值和方差将不太准确，因为其大小可能比训练中使用的小得多，大数定律在这里发挥了作</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E6%80%9D%E8%80%83/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E6%80%9D%E8%80%83/</id>
    <published>2023-03-11T04:35:41.603Z</published>
    <updated>2023-03-11T04:35:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>测试时会出现大量样本为无效样本的情况，如何筛选出这些样本？</p><p>置信度高的样本，熵值很小，如何利用？    而置信度小的样本又容易导致偏差</p><h2 id="最优微调策略"><a href="#最优微调策略" class="headerlink" title="最优微调策略"></a>最优微调策略</h2><p>模拟退火算法(Simulated Annealing)是一种元启发式算法，其灵感来自于固体物质的退火过程。它可以在搜索过程中接受一定的劣解，以避免局部最优解，并且可以在搜索过程中逐渐减小搜索空间，以加快搜索速度。</p><p>粒子群算法(Particle Swarm Optimization)是一种基于群体智能的优化算法，其灵感来自于鸟群或鱼群的集体行为。在该算法中，优化问题被看作是在搜索空间中的多个粒子的位置和速度的优化问题。每个粒子在搜索过程中通过与群体中其他粒子的交互来逐渐优化其位置和速度，以找到最优解。</p><p>遗传算法，模拟退火算法，粒子群算法，神经网络等智能算法的作用？<a href="https://www.zhihu.com/question/29762576?sort=created">https://www.zhihu.com/question/29762576?sort=created</a></p><h2 id="自动停止策略"><a href="#自动停止策略" class="headerlink" title="自动停止策略"></a>自动停止策略</h2><h4 id="最大均值差异"><a href="#最大均值差异" class="headerlink" title="最大均值差异"></a>最大均值差异</h4><p><a href="https://blog.csdn.net/a529975125/article/details/81176029">您好，这是Bing。我可以帮您找到一些最大均值差异的域适应算法和相关论文。根据网络搜索结果</a><a href="https://blog.csdn.net/a529975125/article/details/81176029">1</a><a href="https://www.csdn.net/tags/NtzaEg2sODYzNTUtYmxvZwO0O0OO0O0O.html">2</a><a href="https://blog.csdn.net/hy592070616/article/details/122401205">3</a>，最大均值差异（Maximum Mean Discrepancy，MMD）是迁移学习，尤其是域适应（Domain Adaptation）中使用最广泛的一种损失函数，主要用来度量两个不同但相关的分布的距离。以下是一些相关论文的标题和摘要：</p><ul><li>A Kernel Method for the Two-Sample-Problem. Arthur Gretton, Karsten M. Borgwardt, Malte J. Rasch, Bernhard Schölkopf and Alexander Smola. Advances in Neural Information Processing Systems 19 (NIPS 2006). 摘要：我们提出了一种新的非参数假设检验方法，用于判断两组观测是否来自相同的分布。我们的方法基于最大均值差异（MMD）统计量，它是一个简单易计算的核函数下两组样本均值之间的距离。我们证明了在合适选择核函数后，MMD统计量能够检测出任意两个分布之间的差异，并且给出了一个基于矩阵特征值分解和bootstrap方法的显著性检验过程。</li><li>Domain Adaptation via Transfer Component Analysis. Sinno Jialin Pan, Ivor Wai-Hung Tsang and Qiang Yang. IEEE Transactions on Neural Networks (TNN), Vol. 22(2), pp. 199-210, February 2011. 摘要：域适应（domain adaptation）是迁移学习（transfer learning）中一个重要且具有挑战性的问题。在域适应中，目标域数据通常很少或没有标签信息，而源域数据则有充足的标签信息。因此，在目标域上训练一个有效分类器变得困难。为了解决这个问题，我们提出了一种新颖且有效的机器学习技术——转移成分分析（transfer component analysis，TCA）。TCA试图通过寻找一个特征子空间来减少源域和目标域之间最大均值差异（maximum mean discrepancy），从而实现跨域知识转移。</li><li>Deep Transfer Learning with Joint Adaptation Networks. Mingsheng Long, Han Zhu and Jianmin Wang. Proceedings of the 34th International Conference on Machine Learning (ICML 2017). 摘要：深度神经网络已经在许多视觉识别任务上取得了显著进展，但它们通常需要大量有标注数据来避免过拟合问题。然而，在许多情况下，收集和标注足够数量和质量的数据是不可行或代价高昂的。因此，在缺少充足有标注数据时利用其他领域或任务中已有数据进行知识转移成为了一种自然而有效地解决方案。本文提出了一种新颖且强大地深度迁移学习方法——联合自适应网络（joint adaptation networks），它能够同时利用特征表示、任务关系和分布对齐三个层面进行深度知识转移，并通过最小化多个领域之间最大均值差异（maximum mean discrepancy）实现端到端地优化</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试时会出现大量样本为无效样本的情况，如何筛选出这些样本？&lt;/p&gt;
&lt;p&gt;置信度高的样本，熵值很小，如何利用？    而置信度小的样本又容易导致偏差&lt;/p&gt;
&lt;h2 id=&quot;最优微调策略&quot;&gt;&lt;a href=&quot;#最优微调策略&quot; class=&quot;headerlink&quot; title=&quot;最优微调策略&quot;&gt;&lt;/a&gt;最优微调策略&lt;/h2&gt;&lt;p&gt;模拟退火算法(Simulated Annealing)是一种元启发式算法，其灵感来自于固体物质的退火过程。它可以在搜索过程中接受一定的劣解，以避免局部最优解，并且可以在搜索过程中逐渐减小搜索空间，以加快搜索速度。&lt;/p&gt;
&lt;p&gt;粒子群算法(Particle Swarm Optimization)是一种基于群体智能的优化算法，其灵感来自于鸟群或鱼群的集体行为。在该算法中，优化问题被看作是在搜索空间中的多个粒子的位置和速度的优化问题。每个粒子在搜索过程中通过与群体中其他粒子的交互来逐渐优化其位置和速度，以找到最优解。&lt;/p&gt;
&lt;p&gt;遗传算法，模拟退火算法，粒子群算法，神经网络等智能算法的作用？&lt;a href=&quot;https://www.zhihu.com/question/29762576?sort=created&quot;&gt;https://www.zhihu.com/question/29762576?sort=created&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-03-11T04:35:38.636Z</published>
    <updated>2023-03-11T04:35:38.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划基础知识"><a href="#动态规划基础知识" class="headerlink" title="动态规划基础知识"></a>动态规划基础知识</h2><p>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动规是由前一个状态推导出来的，而贪心是局部直接选最优的</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        if(n == 0) return 0;        if(n == 1) return 1;        return fib(n-1) + fib(n-2);    }};</code></pre><p>题解动规：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int N) {        if (N <= 1) return N;        vector<int> dp(N + 1);        dp[0] = 0;        dp[1] = 1;        for (int i = 2; i <= N; i++) {            dp[i] = dp[i - 1] + dp[i - 2];        }        return dp[N];    }};</code></pre><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>用递归和回溯都超出时间限制</strong></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int climbStairs(int n) {        if (n <= 2) return n;        vector<int> dp(n+1);        dp[1] = 1;        dp[2] = 2;        for (int i = 3; i <= n; i++) {            dp[i] = dp[i - 1] + dp[i - 2];//关键        }        return dp[n];    }};</code></pre><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minCostClimbingStairs(vector<int>& cost) {        vector<int> dp(cost.size() + 1);        dp[0] = 0; // 默认第一步都是不花费体力的        dp[1] = 0;        for (int i = 2; i <= cost.size(); i++) {            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);        }        return dp[cost.size()];    }};</code></pre><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePaths(int m, int n) {        vector<vector<int>> dp(m, vector<int>(n, 0));        //初始化，最好吧初始化和逻辑处理分开写，比较明了        for (int i = 0; i < m; i++) dp[i][0] = 1;        for (int j = 0; j < n; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        int m = obstacleGrid.size(); //！！记住这里的方式        int n = obstacleGrid[0].size();        vector<vector<int>> dp(m, vector<int>(n, 0));        /* 这块的判断写复杂了        int sig = 1;        for (int i = 0; i < m; i++) {            if(obstacleGrid[i][0] == 1) {                dp[i][0] = 0;                sig = 0;            }            if(sig) dp[i][0] = 1;        }        sig = 1;        for (int j = 0; j < n; j++) {            if(obstacleGrid[0][j] == 1) {                dp[0][j] = 0;                sig = 0;            }            if(sig) dp[0][j] = 1;        }        */        //题解的初始化判断        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;                else dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>思路：遍历，比较<code>dp[i - j] * j, (i - j) * j</code>大小，即比较拆成两个和拆成两个以上的乘积大小。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int integerBreak(int n) {        vector<int> dp(n+1);        dp[2] = 1;        for(int i = 3; i <= n; i++){            for (int j = 2; j < i; j++){                dp[i] = max(dp[i],max(dp[i - j] * j, (i - j) * j));            }        }        return dp[n];    }};</code></pre><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接(opens new window)</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的<strong>二叉搜索树</strong>有多少种？</p><p>思路：</p><p><img src="/2023/03/11/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230310111953290.png" alt="image-20230310111953290"> </p><p>dp[3] = dp[0]dp[2] + dp[1]dp[1]+dp[2]dp[0];</p><p>节点的数值其实关系不大，只要每个值不一样就行；</p><p>dp[i] += dp[j - 1] * dp[i - j];</p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numTrees(int n) {        vector<int> dp(n+1);        dp[0] = 1;        dp[1] = 1;        for(int i = 2; i <= n; i++){            for(int j = 1; j <= i; j++){                dp[i] += dp[j - 1] * dp[i - j];            }        }        return dp[n];    }};</code></pre><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有N件物品和⼀个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p><p>例：</p><p>背包最⼤重量为4。<br>              重量    价值<br>物品0      1          15<br>物品1      3          20<br>物品2      4          30</p><p>思路：</p><p>对于背包问题，有⼀种写法， 是使⽤<strong>⼆维数组</strong>，即<code>dp[i] [j]</code> 表⽰从下标为<code>[0-i]</code>的物品⾥任意取，放进容量为<code>j</code>的背包，价值总和最⼤是多少。</p><p>不放物品i:  <code>dp[i-1] [j]</code></p><p>放物品i:<code>dp[i-1] * [j - weight[ i ]] + value[ i ]</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//测试代码void test_2_wei_bag_problem1() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    int bagweight = 4;    // 二维数组    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));    // 初始化    for (int j = weight[0]; j <= bagweight; j++) {        dp[0][j] = value[0];    }    // weight数组的大小 就是物品个数    for(int i = 1; i < weight.size(); i++) { // 遍历物品        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量            if (j < weight[i]) dp[i][j] = dp[i - 1][j];            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);        }    }    cout << dp[weight.size() - 1][bagweight] << endl;}int main() {    test_2_wei_bag_problem1();}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;动态规划基础知识&quot;&gt;&lt;a href=&quot;#动态规划基础知识&quot; class=&quot;headerlink&quot; title=&quot;动态规划基础知识&quot;&gt;&lt;/a&gt;动态规划基础知识&lt;/h2&gt;&lt;p&gt;动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。&lt;/p&gt;
&lt;p&gt;动规是由前一个状态推导出来的，而贪心是局部直接选最优的&lt;/p&gt;
&lt;p&gt;动规五部曲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定dp数组（dp table）以及下标的含义&lt;/li&gt;
&lt;li&gt;确定递推公式&lt;/li&gt;
&lt;li&gt;dp数组如何初始化&lt;/li&gt;
&lt;li&gt;确定遍历顺序&lt;/li&gt;
&lt;li&gt;举例推导dp数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;509-斐波那契数&quot;&gt;&lt;a href=&quot;#509-斐波那契数&quot; class=&quot;headerlink&quot; title=&quot;509. 斐波那契数&quot;&gt;&lt;/a&gt;509. 斐波那契数&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2023-03-11T04:35:37.109Z</published>
    <updated>2023-03-11T04:35:37.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><p>队列是先进先出，栈是先进后出。</p><p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong>SGI STL中队列一样是以deque为缺省情况下的底部结构</strong></p><p>STL 栈和队列都不被归类为容器，而被归类为container adapter（ 容器适配器）。</p><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接(opens new window)</a></p><p>使用栈实现队列的下列操作：</p><p>push(x) — 将一个元素放入队列的尾部。<br>pop() — 从队列首部移除元素。<br>peek() — 返回队列首部的元素。<br>empty() — 返回队列是否为空。</p><p>示例:</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek();  // 返回 1queue.pop();   // 返回 1queue.empty(); // 返回 false</code></pre><p>说明:</p><ul><li>你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p><strong>思路：</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2" style="zoom: 67%;"></p><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><p><strong>代码：</strong></p><p>类的构造函数</p><p><a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">https://www.runoob.com/cplusplus/cpp-constructor-destructor.html</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">stack<type> s; // 初始化s.push(value); // 入栈s.pop(); // 出栈，返回voids.empty(); // 判断空否s.top(); // 返回栈顶元素s.size();  // 返回栈元素个数</code></pre><p>在pop()之前要先用top()访问，pop()本身是不返回元素的。这个想法看来还真是有意义的</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class MyQueue {public:    stack<int> stIn;    stack<int> stOut;    MyQueue() {    }    void push(int x) {        stIn.push(x);    }    int pop() {        if(stOut.empty()){            while(!stIn.empty()){                stOut.push(stIn.top());                stIn.pop();            }        }        int result = stOut.top();        stOut.pop();        return result;    }    int peek() {        int res = this->pop(); // 直接使用已有的pop函数        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去        return res;    }    bool empty() {        if(stOut.empty()&&stIn.empty()) return true;        else return false;    }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */</code></pre><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接(opens new window)</a></p><p>使用单向队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p><strong>代码：</strong></p><p>queue操作：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">q.front();        //获取队首q.back();        //获取队尾q.push(x);        //插入元素,x表示要插入的值,什么都行（但是类型必须和定义的相同）q.pop();        //将队头弹出,无返回值q.size();        //返回队列里有多少个元素q.empty();        //如果队列为空，返回true，否则返回false（ 等同于q.size()==0 ）q.swap(q2);        //交换q和q2里面的值(q2需要和q是一个类型)</code></pre><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class MyStack {public:    queue<int> que;    MyStack() {    }    void push(int x) {        que.push(x);    }    int pop() {        int size = que.size();        while(size >1){            que.push(que.front());            que.pop();            size--;        }        int result = que.front();        que.pop();        return result;    }    int top() {        int result = this->pop();        que.push(result);        return result;    }    bool empty() {        return que.empty();    }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</code></pre><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接(opens new window)</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><ul><li>输入: “()”</li><li>输出: true</li></ul><p>示例 2:</p><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><p>示例 3:</p><ul><li>输入: “(]”</li><li>输出: false</li></ul><p>示例 4:</p><ul><li>输入: “([)]”</li><li>输出: false</li></ul><p>示例 5:</p><ul><li>输入: “{[]}”</li><li>输出: true</li></ul><p>我的代码：</p><p>使用单个栈实现</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isValid(string s) {        stack<char> t;        for(int i = 0; i < s.size(); i++){            if(s[i] == '(' or s[i] == '[' or s[i] == '{'){                t.push(s[i]);            }else if(!t.empty()){                if((t.top() == '(' && s[i] == ')') or (t.top() == '[' && s[i] == ']') or (t.top() == '{' && s[i] == '}')) t.pop();                else return false;            }else return false;        }        if(t.size() == 0) return true;        else return false;    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isValid(string s) {        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求        stack<char> st;        for (int i = 0; i < s.size(); i++) {            if (s[i] == '(') st.push(')');            else if (s[i] == '{') st.push('}');            else if (s[i] == '[') st.push(']');            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false            else if (st.empty() || st.top() != s[i]) return false;            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素        }        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true        return st.empty();    }};</code></pre><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接(opens new window)</a></p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：”abbaca”</li><li>输出：”ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string s) {        stack<char> t;        for(int i = 0; i < s.size(); i++){            if(t.empty() || s[i] != t.top()) t.push(s[i]);            else t.pop();        }        string result = "";        while (!t.empty()){            result += t.top(); //注意字符串的+操作            t.pop();        }        reverse (result.begin(), result.end()); // 此时字符串需要反转一下        return result;    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string S) {        stack<char> st;        for (char s : S) {            if (st.empty() || s != st.top()) {                st.push(s);            } else {                st.pop(); // s 与 st.top()相等的情况            }        }        string result = "";        while (!st.empty()) { // 将栈中元素放到result字符串汇总            result += st.top();            st.pop();        }        reverse (result.begin(), result.end()); // 此时字符串需要反转一下        return result;    }};</code></pre><p>还可以拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string S) {        string result;        for(char s : S) {            if(result.empty() || result.back() != s) {                result.push_back(s); //注意字符串操作            }            else {                result.pop_back();//注意字符串操作            }        }        return result;    }};</code></pre><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, “ * “]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><p><strong>代码：</strong></p><p>C++字符串转换(stoi；stol；stoul；stoll；stoull；stof；stod；stold)</p><p><a href="https://blog.csdn.net/weixin_43899069/article/details/110290292?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-110290292-blog-114146606.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">https://blog.csdn.net/weixin_43899069/article/details/110290292?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-110290292-blog-114146606.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int evalRPN(vector<string>& tokens) {        stack<long long> st;         for(int i = 0; i < tokens.size(); i++){            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {                long long num1 = st.top();                st.pop();                long long num2 = st.top();                st.pop();                if (tokens[i] == "+") st.push(num2 + num1);                if (tokens[i] == "-") st.push(num2 - num1);                if (tokens[i] == "*") st.push(num2 * num1);                if (tokens[i] == "/") st.push(num2 / num1);            }else{                st.push(stoll(tokens[i]));            }        }        return st.top();    }};</code></pre><h2 id="239-滑动窗口最大值——单调队列"><a href="#239-滑动窗口最大值——单调队列" class="headerlink" title="239. 滑动窗口最大值——单调队列"></a>239. 滑动窗口最大值——单调队列</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接(opens new window)</a></p><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p><img src="/2023/03/11/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20230216192400940.png" alt="image-20230216192400940" style="zoom:33%;"></p><p><strong>思路：</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2" style="zoom:67%;"></p><p>使用<strong>单调队列</strong>:</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的front元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于<strong>back元素</strong>的数值，那么就将队列front的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p><strong>代码：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    class MyQueue{ //单调队列（从大到小），由于需要访问q.back()和pop_back()，需要用双向的        public:            deque<int> q;            void pop(int x){                if(!q.empty() && x == q.front()) q.pop_front();            }        // 判断非空需要放在前面，如果改为x == q.front() && !q.empty()就会报错            void push(int x){                while(!q.empty() && x > q.back()) {                    q.pop_back();                }                q.push_back(x);            }            int front(){                return q.front();            }    };    vector<int> maxSlidingWindow(vector<int>& nums, int k) {        MyQueue que;        vector<int> results;        for(int i = 0; i < k; i++){            que.push(nums[i]);        }        results.push_back(que.front());        for(int i = k; i < nums.size(); i++){            que.pop(nums[i-k]);            que.push(nums[i]);            results.push_back(que.front());        }        return results;    }};</code></pre><h2 id="347-前-K-个高频元素——优先级队列"><a href="#347-前-K-个高频元素——优先级队列" class="headerlink" title="347.前 K 个高频元素——优先级队列"></a>347.前 K 个高频元素——优先级队列</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣题目链接(opens new window)</a></p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2</li><li>输出: [1,2]</li></ul><p>思路：</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>使用map（key元素  value频率）和小顶堆</p><p>【priority_queue优先队列的基础知识】</p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solutions/1283998/c-xiao-bai-you-hao-you-xian-dui-lie-de-j-53ay/">https://leetcode.cn/problems/top-k-frequent-elements/solutions/1283998/c-xiao-bai-you-hao-you-xian-dui-lie-de-j-53ay/</a></p><p><a href="https://blog.csdn.net/qq_43679351/article/details/124825229">https://blog.csdn.net/qq_43679351/article/details/124825229</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 时间复杂度：O(nlogk)// 空间复杂度：O(n)class Solution {public:    //小顶堆    class mycomparison{    public:        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {            return lhs.second > rhs.second;        }    }; //注意这里的分号    vector<int> topKFrequent(vector<int>& nums, int k) {         // 要统计元素出现频率        unordered_map<int, int> map; // map<nums[i],对应出现的次数>        for (int i = 0; i < nums.size(); i++) {            map[nums[i]]++; //key元素  value频率        }        //上式可以改写为        // for (int i : nums) {        //    map[i]++; //key元素  value频率        //}        // 对频率排序        // 定义一个小顶堆，大小为k        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> q;        // 用固定大小为k的小顶堆，扫描所有频率的数值        for(auto& a:map){            q.push(a);            if(q.size()>k){               q.pop();             }        }        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组        vector<int> result(k);        for (int i = k - 1; i >= 0; i--) {            result[i] = q.top().first;            q.pop();        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;栈与队列理论基础&quot;&gt;&lt;a href=&quot;#栈与队列理论基础&quot; class=&quot;headerlink&quot; title=&quot;栈与队列理论基础&quot;&gt;&lt;/a&gt;栈与队列理论基础&lt;/h2&gt;&lt;p&gt;队列是先进先出，栈是先进后出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGI STL中队列一样是以deque为缺省情况下的底部结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;STL 栈和队列都不被归类为容器，而被归类为container adapter（ 容器适配器）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet50%E7%BB%93%E6%9E%84/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet50%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-11T04:35:26.874Z</published>
    <updated>2023-03-11T04:35:26.905Z</updated>
    
    <content type="html"><![CDATA[<p>ext<br>ext.conv1<br>ext.bn1<br>ext.layer1<br>ext.layer1.0<br>ext.layer1.0.conv1<br>ext.layer1.0.bn1<br>ext.layer1.0.conv2<br>ext.layer1.0.bn2<br>ext.layer1.0.conv3<br>ext.layer1.0.bn3<br>ext.layer1.0.shortcut<br>ext.layer1.0.shortcut.0<br>ext.layer1.0.shortcut.1<br>ext.layer1.1<br>ext.layer1.1.conv1<br>ext.layer1.1.bn1<br>ext.layer1.1.conv2<br>ext.layer1.1.bn2<br>ext.layer1.1.conv3<br>ext.layer1.1.bn3<br>ext.layer1.1.shortcut<br>ext.layer1.2<br>ext.layer1.2.conv1<br>ext.layer1.2.bn1<br>ext.layer1.2.conv2<br>ext.layer1.2.bn2<br>ext.layer1.2.conv3<br>ext.layer1.2.bn3<br>ext.layer1.2.shortcut<br>ext.layer2<br>ext.layer2.0<br>ext.layer2.0.conv1<br>ext.layer2.0.bn1<br>ext.layer2.0.conv2<br>ext.layer2.0.bn2<br>ext.layer2.0.conv3<br>ext.layer2.0.bn3<br>ext.layer2.0.shortcut<br>ext.layer2.0.shortcut.0<br>ext.layer2.0.shortcut.1<br>ext.layer2.1<br>ext.layer2.1.conv1<br>ext.layer2.1.bn1<br>ext.layer2.1.conv2<br>ext.layer2.1.bn2<br>ext.layer2.1.conv3<br>ext.layer2.1.bn3<br>ext.layer2.1.shortcut<br>ext.layer2.2<br>ext.layer2.2.conv1<br>ext.layer2.2.bn1<br>ext.layer2.2.conv2<br>ext.layer2.2.bn2<br>ext.layer2.2.conv3<br>ext.layer2.2.bn3<br>ext.layer2.2.shortcut<br>ext.layer2.3<br>ext.layer2.3.conv1<br>ext.layer2.3.bn1<br>ext.layer2.3.conv2<br>ext.layer2.3.bn2<br>ext.layer2.3.conv3<br>ext.layer2.3.bn3<br>ext.layer2.3.shortcut<br>ext.layer3<br>ext.layer3.0<br>ext.layer3.0.conv1<br>ext.layer3.0.bn1<br>ext.layer3.0.conv2<br>ext.layer3.0.bn2<br>ext.layer3.0.conv3<br>ext.layer3.0.bn3<br>ext.layer3.0.shortcut<br>ext.layer3.0.shortcut.0<br>ext.layer3.0.shortcut.1<br>ext.layer3.1<br>ext.layer3.1.conv1<br>ext.layer3.1.bn1<br>ext.layer3.1.conv2<br>ext.layer3.1.bn2<br>ext.layer3.1.conv3<br>ext.layer3.1.bn3<br>ext.layer3.1.shortcut<br>ext.layer3.2<br>ext.layer3.2.conv1<br>ext.layer3.2.bn1<br>ext.layer3.2.conv2<br>ext.layer3.2.bn2<br>ext.layer3.2.conv3<br>ext.layer3.2.bn3<br>ext.layer3.2.shortcut<br>ext.layer3.3<br>ext.layer3.3.conv1<br>ext.layer3.3.bn1<br>ext.layer3.3.conv2<br>ext.layer3.3.bn2<br>ext.layer3.3.conv3<br>ext.layer3.3.bn3<br>ext.layer3.3.shortcut<br>ext.layer3.4<br>ext.layer3.4.conv1<br>ext.layer3.4.bn1<br>ext.layer3.4.conv2<br>ext.layer3.4.bn2<br>ext.layer3.4.conv3<br>ext.layer3.4.bn3<br>ext.layer3.4.shortcut<br>ext.layer3.5<br>ext.layer3.5.conv1<br>ext.layer3.5.bn1<br>ext.layer3.5.conv2<br>ext.layer3.5.bn2<br>ext.layer3.5.conv3<br>ext.layer3.5.bn3<br>ext.layer3.5.shortcut<br>ext.layer4<br>ext.layer4.0<br>ext.layer4.0.conv1<br>ext.layer4.0.bn1<br>ext.layer4.0.conv2<br>ext.layer4.0.bn2<br>ext.layer4.0.conv3<br>ext.layer4.0.bn3<br>ext.layer4.0.shortcut<br>ext.layer4.0.shortcut.0<br>ext.layer4.0.shortcut.1<br>ext.layer4.1<br>ext.layer4.1.conv1<br>ext.layer4.1.bn1<br>ext.layer4.1.conv2<br>ext.layer4.1.bn2<br>ext.layer4.1.conv3<br>ext.layer4.1.bn3<br>ext.layer4.1.shortcut<br>ext.layer4.2<br>ext.layer4.2.conv1<br>ext.layer4.2.bn1<br>ext.layer4.2.conv2<br>ext.layer4.2.bn2<br>ext.layer4.2.conv3<br>ext.layer4.2.bn3<br>ext.layer4.2.shortcut<br>ext.avgpool<br>head<br>head.fc</p><p>50(没有包括shortcut)</p><p>model for adaptation: ExtractorHead(<br>  (ext): ResNet(<br>    (conv1): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>    (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>    (layer1): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential(<br>          (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>          (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>    )<br>    (layer2): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential(<br>          (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (3): Bottleneck(<br>        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>    )<br>    (layer3): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential(<br>          (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (3): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (4): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (5): Bottleneck(<br>        (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>    )<br>    (layer4): Sequential(<br>      (0): Bottleneck(<br>        (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential(<br>          (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>          (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        )<br>      )<br>      (1): Bottleneck(<br>        (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>      (2): Bottleneck(<br>        (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>        (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (shortcut): Sequential()<br>      )<br>    )<br>    (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))<br>  )<br>  (head): LinearClassifier(<br>    (fc): Linear(in_features=2048, out_features=10, bias=True)<br>  )<br>)</p>]]></content>
    
    
    <summary type="html">ext
ext.conv1
ext.bn1
ext.layer1
ext.layer1.0
ext.layer1.0.conv1
ext.layer1.0.bn1
ext.layer1.0.conv2
ext.layer1.0.bn2
ext.layer1.0.conv3
ext.layer1.0.bn3
ext.layer1.0.shortcut
ext.layer1.0.shortcut.0
ext.layer1.0.shortcut.1
ext.layer1.1
ext.layer1.1.conv1
ext.layer1.1.bn1
ext.layer1.1.conv2
ext.laye</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet26%E7%BB%93%E6%9E%84/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/resnet26%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-11T04:35:24.270Z</published>
    <updated>2023-03-11T04:35:24.284Z</updated>
    
    <content type="html"><![CDATA[<p>module.conv1<br>module.bn1<br>module.layer1<br>module.layer1.0<br>module.layer1.0.conv1<br>module.layer1.0.bn1<br>module.layer1.0.conv2<br>module.layer1.0.bn2<br>module.layer1.0.shortcut<br>module.layer1.1<br>module.layer1.1.conv1<br>module.layer1.1.bn1<br>module.layer1.1.conv2<br>module.layer1.1.bn2<br>module.layer1.1.shortcut<br>module.layer1.2<br>module.layer1.2.conv1<br>module.layer1.2.bn1<br>module.layer1.2.conv2<br>module.layer1.2.bn2<br>module.layer1.2.shortcut<br>module.layer1.3<br>module.layer1.3.conv1<br>module.layer1.3.bn1<br>module.layer1.3.conv2<br>module.layer1.3.bn2<br>module.layer1.3.shortcut<br>module.layer2<br>module.layer2.0<br>module.layer2.0.conv1<br>module.layer2.0.bn1<br>module.layer2.0.conv2<br>module.layer2.0.bn2<br>module.layer2.0.shortcut<br>module.layer2.1<br>module.layer2.1.conv1<br>module.layer2.1.bn1<br>module.layer2.1.conv2<br>module.layer2.1.bn2<br>module.layer2.1.shortcut<br>module.layer2.2<br>module.layer2.2.conv1<br>module.layer2.2.bn1<br>module.layer2.2.conv2<br>module.layer2.2.bn2<br>module.layer2.2.shortcut<br>module.layer2.3<br>module.layer2.3.conv1<br>module.layer2.3.bn1<br>module.layer2.3.conv2<br>module.layer2.3.bn2<br>module.layer2.3.shortcut<br>module.layer3<br>module.layer3.0<br>module.layer3.0.conv1<br>module.layer3.0.bn1<br>module.layer3.0.conv2<br>module.layer3.0.bn2<br>module.layer3.0.shortcut<br>module.layer3.1<br>module.layer3.1.conv1<br>module.layer3.1.bn1<br>module.layer3.1.conv2<br>module.layer3.1.bn2<br>module.layer3.1.shortcut<br>module.layer3.2<br>module.layer3.2.conv1<br>module.layer3.2.bn1<br>module.layer3.2.conv2<br>module.layer3.2.bn2<br>module.layer3.2.shortcut<br>module.layer3.3<br>module.layer3.3.conv1<br>module.layer3.3.bn1<br>module.layer3.3.conv2<br>module.layer3.3.bn2<br>module.layer3.3.shortcut<br>module.linear</p><pre><code>(module): ResNet(  (conv1): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)  (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)  (layer1): Sequential(    (0): BasicBlock(      (conv1): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (1): BasicBlock(      (conv1): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (2): BasicBlock(      (conv1): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (3): BasicBlock(      (conv1): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(16, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )  )  (layer2): Sequential(    (0): BasicBlock(      (conv1): Conv2d(16, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): LambdaLayer()    )    (1): BasicBlock(      (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (2): BasicBlock(      (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (3): BasicBlock(      (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )  )  (layer3): Sequential(    (0): BasicBlock(      (conv1): Conv2d(32, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): LambdaLayer()    )    (1): BasicBlock(      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (2): BasicBlock(      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )    (3): BasicBlock(      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)      (shortcut): Sequential()    )  )  (linear): Linear(in_features=64, out_features=10, bias=True))</code></pre>]]></content>
    
    
    <summary type="html">module.conv1
module.bn1
module.layer1
module.layer1.0
module.layer1.0.conv1
module.layer1.0.bn1
module.layer1.0.conv2
module.layer1.0.bn2
module.layer1.0.shortcut
module.layer1.1
module.layer1.1.conv1
module.layer1.1.bn1
module.layer1.1.conv2
module.layer1.1.bn2
module.layer1.1.shortcut
module.layer</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-03-11T04:35:23.936Z</published>
    <updated>2023-03-11T04:35:23.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806194529815.png" alt="链表1"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单链表struct ListNode {    int val;  // 节点上存储的元素    ListNode *next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL};</code></pre><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/image-20221218173554982.png" alt="image-20221218173554982"></p><p>删除节点和添加节点：</p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806195114541.png" alt="链表-删除节点"></p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806195134331.png" alt="链表-添加节点"></p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806195200276.png" alt="链表-链表与数据性能对比"></p><p>使用C，C++编程语言的话，不要忘了还要从<strong>内存中删除</strong>被移除的节点</p><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>为了使用一种统一的逻辑来移除链表的节点，我们可以设置<strong>虚拟头节点</strong></p><p>最后在题目中，return 头结点的时候，需要 <code>return dummyNode-&gt;next;</code></p><h3 id="新建虚拟头节点："><a href="#新建虚拟头节点：" class="headerlink" title="新建虚拟头节点："></a>新建虚拟头节点：</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">ListNode* dummyHead = new ListNode(-1);</code></pre><p>注：当需要避免对头节点的情况进行特殊处理时，采用虚拟头节点</p><p><a href="https://blog.csdn.net/qq_54182926/article/details/119193250">(63条消息) C++之new的使用_软硬兼施的程序员的博客-CSDN博客_c++ new</a></p><p>一、new的使用。<br>new+数据类型（初值），返回值为申请空间的对应数据类型的地址。<br>1.使用new申请一个对象</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *p = new int(10);//申请了一个初值为10的整型数据</code></pre><p>2.使用new申请数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *arr = new int[10];//申请了能存放10个整型数据元素的数组，其首地址为arr</code></pre><p>二、delete运算符的使用。<br>new运算符通常搭配delete元素安抚来使用，new用来动态申请存储空间，delete用于释放new申请的空间。<br>语法格式如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">delete p；delete[] arr;//注意要删除数组时，需要加[]，以表示arr为数组。</code></pre><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>双指针法</p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>双指针法：fast先走n+1步，slow再和fast同时走。注意使用虚拟头节点</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img" style="zoom:50%;"></p><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>思路：相交部分长度相同，交点处指针相等。即先将长度对齐，再比较指针是否相同。</p><p>注：<strong>判断链表结束是看是否指向NULL，</strong>而不是0。没有使用虚拟头节点的话，判断如下<code>while(curA != NULL)</code>,不需要用curA-&gt;next</p><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p><strong>判断环内相遇</strong>：双指针，慢指针每走一步，快指针走两步，如果两指针相遇，则表明有环。</p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/141.环形链表.gif" alt="141.环形链表"></p><p><strong>找到环的入口：</strong>（快指针可能走N圈才会和慢的相遇）</p><p><img src="/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/142.环形链表II（求入口）.gif" alt="142.环形链表II（求入口）"></p><p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;链表理论基础&quot;&gt;&lt;a href=&quot;#链表理论基础&quot; class=&quot;headerlink&quot; title=&quot;链表理论基础&quot;&gt;&lt;/a&gt;链表理论基础&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806194529815.png&quot; alt=&quot;链表1&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot; language-lang-cpp&quot;&gt;&lt;code class=&quot;language-lang-cpp&quot;&gt;// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/image-20221218173554982.png&quot; alt=&quot;image-20221218173554982&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除节点和添加节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/03/11/cpp/%E9%93%BE%E8%A1%A8/20200806195114541.png&quot; alt=&quot;链表-删除节点&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E6%95%B0%E7%BB%84/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E6%95%B0%E7%BB%84/</id>
    <published>2023-03-11T04:35:21.104Z</published>
    <updated>2023-03-11T04:35:21.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>坚持<strong>左闭右闭or左闭又开</strong><ul><li>while(left &lt;= right)  or  while(left &lt; right)</li></ul></li><li>比较left、middle和right三个值</li></ul><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><p><strong>双指针法（快慢指针法</strong>）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><ul><li>快指针：寻找不等于有目标元素的值 （通常快指针就是for循环里面的索引）</li><li>慢指针：指向新数组最后一个下标的位置</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">        for (int fast=0;fast<nums.size();fast++){            if (nums[fast] != val){                nums[slow] = nums[fast];                slow++;            }        }</code></pre><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。<br>示例：<br>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组</p></blockquote><p><strong>滑动窗口</strong>：不断的调节子序列的起始位置和终止位置。其实算是双指针法的一种，一个指向滑动窗口起始位置，一个指向末端。</p><p>滑动窗口主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p><img src="/2023/03/11/cpp/%E6%95%B0%E7%BB%84/209.长度最小的子数组.gif" alt="209.长度最小的子数组"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;坚持&lt;strong&gt;左闭右闭or左闭又开&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;while(left &amp;lt;= right)  or  while(left &amp;lt; right)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比较left、middle和right三个值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h2&gt;&lt;p&gt;数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双指针法（快慢指针法&lt;/strong&gt;）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快指针：寻找不等于有目标元素的值 （通常快指针就是for循环里面的索引）&lt;/li&gt;
&lt;li&gt;慢指针：指向新数组最后一个下标的位置&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-03-11T04:35:20.159Z</published>
    <updated>2023-03-11T04:35:20.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>CIFAR10-to-CIFAR10C</p><p>CIFAR100-to-CIFAR100C</p><p>ImageNet-to-ImageNetC </p><p> <a href="https://github.com/VisionLearningGroup/taskcv-2017-public/tree/master/classification">VisDA</a> and <a href="https://www.hemanthdv.org/officeHomeDataset.html">Office-Home</a></p><p>语义分割数据集</p><p>Cityscapses-to-ACDC</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>可以直接使用robustbench的预训练模型</p><h2 id="对比方法"><a href="#对比方法" class="headerlink" title="对比方法"></a>对比方法</h2><p>BN </p><p>TENT</p><p>SHOT</p><p>AdaContrast</p><p>CoTTA</p><p>ieee signal processing letter</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="离线非连续目标域适应实验-（无源无监督域适应-source-free-unsupervised-domain-adaptation）"><a href="#离线非连续目标域适应实验-（无源无监督域适应-source-free-unsupervised-domain-adaptation）" class="headerlink" title="离线非连续目标域适应实验 （无源无监督域适应 source-free unsupervised domain adaptation）"></a>离线非连续目标域适应实验 （无源无监督域适应 source-free unsupervised domain adaptation）</h3><ul><li>重置模型</li><li>还可添加与SHOT对比/结合的实验</li></ul><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209144734581.png" alt="image-20230209144734581"></p><p>子空间的mean_entropy下降更慢，error更低</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209191212551.png" alt="image-20230209191212551" style="zoom:50%;"><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209191239040.png" alt="image-20230209191239040" style="zoom:50%;"></p><h2 id="离线非连续目标域适应实验"><a href="#离线非连续目标域适应实验" class="headerlink" title="离线非连续目标域适应实验"></a>离线非连续目标域适应实验</h2><h3 id="在线连续目标域适应实验"><a href="#在线连续目标域适应实验" class="headerlink" title="在线连续目标域适应实验"></a>在线连续目标域适应实验</h3><ul><li>参考cotta论文设置</li><li>不重置模型</li></ul><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209144535655.png" alt="image-20230209144535655"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209144553554.png" alt="image-20230209144553554"></p><h3 id="消融实验和分析"><a href="#消融实验和分析" class="headerlink" title="消融实验和分析"></a>消融实验和分析</h3><h4 id="t-SNE可视化"><a href="#t-SNE可视化" class="headerlink" title="t-SNE可视化"></a>t-SNE可视化</h4><p>例：<img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230209145917834.png" alt="image-20230209145917834"></p><h2 id="测试仅微调前几层和后几层的效果"><a href="#测试仅微调前几层和后几层的效果" class="headerlink" title="测试仅微调前几层和后几层的效果"></a>测试仅微调前几层和后几层的效果</h2><h3 id="resnet-26-conv-all-bn-statistics"><a href="#resnet-26-conv-all-bn-statistics" class="headerlink" title="resnet-26(conv + all bn statistics)"></a>resnet-26(conv + all bn statistics)</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230214161528738.png" alt="image-20230214161528738"></p><p><strong>error rate的变化特点</strong></p><p>仅微调前几层（输入层）的时候，error 一直呈现下降趋势；而仅微调后几层（输出层）时，error 会先下降后上升,很易过拟合</p><p>以下结果lr均为0.001</p><p>微调第一层时的结果</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171207376.png" alt="image-20230217171207376" style="zoom:50%;"></p><p>微调前三层时的结果</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171240694.png" alt="image-20230217171240694" style="zoom:50%;"></p><p>微调前九层时的结果</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171310725.png" alt="image-20230217171310725" style="zoom:50%;"></p><p>微调最后一层时的结果 </p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171032071.png" alt="image-20230217171032071" style="zoom:50%;"></p><p>微调后三层时的结果</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171102632.png" alt="image-20230217171102632" style="zoom:50%;"></p><p>微调后九层时的结果</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171137404.png" alt="image-20230217171137404" style="zoom:50%;"></p><p>微调所有层的结果 </p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171344470.png" alt="image-20230217171344470" style="zoom:50%;"></p><p>tent</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217170947606.png" alt="image-20230217170947606" style="zoom:50%;"></p><p>ldme</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217171413288.png" alt="image-20230217171413288" style="zoom:50%;"></p><h3 id="resnet-26-bn"><a href="#resnet-26-bn" class="headerlink" title="resnet-26(bn)"></a>resnet-26(bn)</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306100121325.png" alt="image-20230306100121325"></p><p>1</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306135337210.png" alt="image-20230306135337210" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306135404338.png" alt="image-20230306135404338" style="zoom:50%;"></p><p>9</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306135622519.png" alt="image-20230306135622519" style="zoom:50%;"></p><p>17</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306140607421.png" alt="image-20230306140607421" style="zoom:50%;"></p><p>23</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306140542547.png" alt="image-20230306140542547" style="zoom:50%;"></p><p>25(tent)</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306140722961.png" alt="image-20230306140722961" style="zoom:50%;"></p><p>单独分析一个域的情况：</p><p>impulse_noise:</p><p>只有更新所有BN层时，error才下降，且此时entropy下降缓慢</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306141814141.png" alt="image-20230306141814141" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306141752113.png" alt="image-20230306141752113" style="zoom:50%;"></p><p>elastic_transform:</p><p>当解冻的BN层越多，entropy下降的越快</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306142548988.png" alt="image-20230306142548988" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306142630463.png" alt="image-20230306142630463" style="zoom:50%;"></p><h3 id="resnet-26-bn-conv"><a href="#resnet-26-bn-conv" class="headerlink" title="resnet-26(bn+conv)"></a>resnet-26(bn+conv)</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306100151951.png" alt="image-20230306100151951"></p><p>1</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306104530197.png" alt="image-20230306104530197" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306104643454.png" alt="image-20230306104643454" style="zoom:50%;"></p><p>误差持续上升的这些域，熵下降的更迅速，tent在这些域对应的误差也较大；可以解释为分布偏差较大的域，仅更新前几层网络可能会导致网络崩溃，越训越差。</p><p>3（与1的情况相似）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306105559189.png" alt="image-20230306105559189" style="zoom:50%;"></p><p>7（误差上升的域数同1，为6个域）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306105735052.png" alt="image-20230306105735052" style="zoom:50%;"></p><p>在误差下降的域，误差值甚至低于tent</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306110018402.png" alt="image-20230306110018402" style="zoom:50%;"></p><p>9（误差上升的类别数为2个域，这两个域在tent中的误差都是最高的，接近40%）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306110306474.png" alt="image-20230306110306474" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306110505956.png" alt="image-20230306110505956" style="zoom:50%;"></p><p>17（误差上升的域为8个，其中3个直接上升，另5个先下降后上升）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306110753164.png" alt="image-20230306110753164" style="zoom:50%;"></p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306111053139.png" alt="image-20230306111053139" style="zoom:50%;"></p><p>23</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306111528991.png" alt="image-20230306111528991" style="zoom:50%;"></p><p>25（这里调整完了所有的BN层，误差全部下降）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306111400245.png" alt="image-20230306111400245" style="zoom:50%;"></p><h3 id="resnet-26-allbn-conv"><a href="#resnet-26-allbn-conv" class="headerlink" title="resnet-26(allbn+conv)"></a>resnet-26(allbn+conv)</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306100227413.png" alt="image-20230306100227413"></p><p>0(tent)</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306103133212.png" alt="image-20230306103133212" style="zoom:50%;"></p><p>1</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306103012687.png" alt="image-20230306103012687" style="zoom:50%;"></p><p>9</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306102713434.png" alt="image-20230306102713434" style="zoom:50%;"></p><p>19</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306102555685.png" alt="image-20230306102555685" style="zoom:50%;"></p><p>all</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306102358797.png" alt="image-20230306102358797" style="zoom:50%;"></p><p>单个域性能分析：</p><p>gaussian（熵严格按照解冻层数越多下降越快）</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230306154146818.png" alt="image-20230306154146818" style="zoom:50%;"></p><h3 id="resnet-50（复现ttt-）"><a href="#resnet-50（复现ttt-）" class="headerlink" title="resnet-50（复现ttt++）"></a>resnet-50（复现ttt++）</h3><p>lr = 0.001</p><p>layer1</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104033394.png" alt="image-20230217104033394" style="zoom:50%;"></p><p>layer4</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104332979.png" alt="image-20230217104332979" style="zoom:50%;"></p><p>layer11</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104210696.png" alt="image-20230217104210696" style="zoom:50%;"></p><p>layer-11</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104051595.png" alt="image-20230217104051595" style="zoom:50%;"></p><p>layer-4(0.01)</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217165904272.png" alt="image-20230217165904272" style="zoom:50%;"></p><p>layer-1</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104425260.png" alt="image-20230217104425260" style="zoom:50%;"></p><p>all</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217165803214.png" alt="image-20230217165803214" style="zoom:50%;"></p><p>tent</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104504987.png" alt="image-20230217104504987" style="zoom:50%;"></p><p>ldme</p><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%AE%9E%E9%AA%8C/image-20230217104609914.png" alt="image-20230217104609914" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据集&quot;&gt;&lt;a href=&quot;#数据集&quot; class=&quot;headerlink&quot; title=&quot;数据集&quot;&gt;&lt;/a&gt;数据集&lt;/h2&gt;&lt;p&gt;CIFAR10-to-CIFAR10C&lt;/p&gt;
&lt;p&gt;CIFAR100-to-CIFAR100C&lt;/p&gt;
&lt;p&gt;ImageNet-to-ImageNetC &lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/VisionLearningGroup/taskcv-2017-public/tree/master/classification&quot;&gt;VisDA&lt;/a&gt; and &lt;a href=&quot;https://www.hemanthdv.org/officeHomeDataset.html&quot;&gt;Office-Home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语义分割数据集&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/</id>
    <published>2023-03-11T04:35:18.743Z</published>
    <updated>2023-03-11T04:35:18.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h2><p>回溯是递归的副产品，只要有递归就会有回溯。在下文中，<strong>回溯函数也就是递归函数，指的都是一个函数</strong></p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>回溯三部曲：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void backtracking(参数){    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}</code></pre><h2 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h2><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接(opens new window)</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><p>思路：</p><p>把组合问题抽象为如下树形结构：</p><p><img src="/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/20201123195223940-16777567027868.png" alt="77.组合" style="zoom:33%;"></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        for(int i = startIndex; i <=n; i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><p>剪枝优化题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        // n-i+1 >= k-path.size() 大多数回溯算法的剪枝操作，都是改这里i的范围        for(int i = startIndex; i <= n + 1 - k + path.size(); i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><h2 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接(opens new window)</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><p>思路：</p><p>k是树的深度，n是树的宽度</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9; i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><p>剪枝后：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(sum > targetSum) return;        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9 + 1 - k + path.size(); i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p><img src="/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/2020102916424043.png" alt="17.电话号码的字母组合"></p><p>思路：</p><p><img src="/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    const string letterMap[10] = {        "", // 0        "", // 1        "abc", // 2        "def", // 3        "ghi", // 4        "jkl", // 5        "mno", // 6        "pqrs", // 7        "tuv", // 8        "wxyz", // 9    };    vector<string> result;    string s;    void backtracking(string digits, int index){        if (index == digits.size()) {            result.push_back(s);            return;        }        int digit = digits[index] - '0'; // 将index指向的数字转为int        string letters = letterMap[digit];        for (int i = 0; i < letters.size(); i++) {            s.push_back(letters[i]);            backtracking(digits,index + 1); // 递归            s.pop_back();        }    }    vector<string> letterCombinations(string digits) {        if(digits == "") return result;        backtracking(digits, 0);        return result;    }};</code></pre><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong></p><p><img src="/2023/03/11/cpp/%E5%9B%9E%E6%BA%AF/20201223170730367.png" alt="39.组合总和"></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> results;    vector<int> path;    void backtracking(vector<int> candidates, int target, int index, int sum){        if(sum == target){            results.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = index; i < candidates.size(); i++) {            path.push_back(candidates[i]);            backtracking(candidates, target, i, sum + candidates[i]); // 递归            path.pop_back();        }    }    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {        backtracking(candidates, target, 0, 0);        return  results;    }};</code></pre><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接(opens new window)</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：数组candidates中会出现重复数字，需要<strong>排序后去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {        if (sum == target) {            result.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = startIndex; i < candidates.size(); i++) {            // 要对同一树层使用过的元素进行跳过，这是本题的关键            if (i > startIndex && candidates[i] == candidates[i - 1]) {                continue;            }            path.push_back(candidates[i]);            backtracking(candidates, target, sum + candidates[i], i + 1); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            path.pop_back();        }    }public:    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {        path.clear();        result.clear();        // 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0);        return result;    }};</code></pre><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串    bool isPalindrome(const string& s, int start, int end) {        for (int i = start, j = end; i < j; i++, j--) {            if (s[i] != s[j]) {                return false;            }        }        return true;    }    vector<vector<string>> result;    vector<string> path; // 放已经回文的子串    void backtracking (const string& s, int startIndex) {        if (startIndex >= s.size()) {            result.push_back(path);            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isPalindrome(s, startIndex, i)) { // 是回文子串                // 获取[startIndex,i]在s中的子串                string str = s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            } else {                // 如果不是则直接跳过                continue;            }            backtracking(s, i + 1); // 寻找i+1为起始位置的子串            path.pop_back();        // 回溯过程，弹出本次已经填在的子串        }    }    vector<vector<string>> partition(string s) {        backtracking(s, 0);        return result;    }};</code></pre><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接(opens new window)</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,”255.255.111.35”]</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法    bool isValid(const string& s, int start, int end) {        if (start > end) {            return false;        }        if (s[start] == '0' && start != end) { // 0开头的数字不合法                return false;        }        int num = 0;        for (int i = start; i <= end; i++) {            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法                return false;            }            num = num * 10 + (s[i] - '0');            if (num > 255) { // 如果大于255了不合法                return false;            }        }        return true;    }    vector<string> result;// 记录结果    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量    void backtracking(string& s, int startIndex, int pointNum){        if (pointNum == 3) { // 逗点数量为3时，分隔结束            // 判断第四段子字符串是否合法，如果合法就放进result中            if (isValid(s, startIndex, s.size() - 1)) {                result.push_back(s);            }            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点                pointNum++;                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2                pointNum--;                         // 回溯                s.erase(s.begin() + i + 1);         // 回溯删掉逗点            } else break; // 不合法，直接结束本层循环        }    }    vector<string> restoreIpAddresses(string s) {        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了        backtracking(s, 0, 0);        return result;    }};</code></pre><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接(opens new window)</a></p><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><p><strong>子集是收集树形结构中树的所有节点的结果</strong>。<strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int> nums, int index){        result.push_back(path);// 重点！不管到没到最后都要收集结果        //下面这个可要可不要,因为在for循环中给出了判断        if (index >= nums.size()) {            //不是在这里才收集结果            return;        }        for (int i = index; i < nums.size(); i++) {            path.push_back(nums[i]);            backtracking(nums, i + 1); // 递归            path.pop_back();        }    }    vector<vector<int>> subsets(vector<int>& nums) {        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p><p>给定一个可能包含<strong>重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p>思路：</p><p>本题就是在上一题的基础上加上了<strong>去重</strong>，通过<strong>排序去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        result.push_back(path);        //if (startIndex >= nums.size()) {        //    return;        //}        for (int i = startIndex; i < nums.size(); i++) {            //跳过重复元素            if (i > startIndex && nums[i] == nums[i - 1]) {                continue;            }            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> subsetsWithDup(vector<int>& nums) {        sort(nums.begin(), nums.end()); // 去重需要排序        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><ul><li>输入: [4, 6, 7, 7]</li><li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li></ul><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><p>思路：</p><p>不可对原数组进行重排，而且重复的数字不一定挨着出现，所以可以使用哈希表来判断数字是否用过</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        if (path.size() > 1) {            result.push_back(path);            // 注意这里不要加return，要取树上的节点        }        unordered_set<int> uset; // 使用set对本层元素进行去重        for (int i = startIndex; i < nums.size(); i++) {            //若当前数比上一个小（注意上一个是path.back），或者使用过，则跳过            if ((!path.empty() && nums[i] < path.back())                    || uset.find(nums[i]) != uset.end()) {                    continue;            }            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> findSubsequences(vector<int>& nums) {        result.clear();        path.clear();        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接(opens new window)</a></p><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><ul><li>输入: [1,2,3]</li><li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li></ul><p>思路：</p><p>用used数组，用过的记为1</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        // 此时说明找到了一组        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        for (int i = 0; i < nums.size(); i++) {            if (used[i] == true) continue; // path里已经收录的元素，直接跳过            used[i] = true;            path.push_back(nums[i]);            backtracking(nums, used);            path.pop_back();            used[i] = false;        }    }    vector<vector<int>> permute(vector<int>& nums) {        result.clear();        path.clear();        vector<bool> used(nums.size(), false);//注意vector的初始化方式        backtracking(nums, used);        return result;    }};</code></pre><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>可包含重复</strong>数字的序列 nums ，按任意顺序返回所有<strong>不重复</strong>的全排列。</p><p>思路：</p><p>排序+used+set</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复        for (int i = 0; i < nums.size(); i++) {            if (uset.find(nums[i]) != uset.end()) {                continue;            }            if (used[i] == false) {  //控制同一树枝不重复                uset.insert(nums[i]); // 记录元素                used[i] = true;                path.push_back(nums[i]);                backtracking(nums, used);                path.pop_back();                used[i] = false;            }        }    }public:    vector<vector<int>> permuteUnique(vector<int>& nums) {        result.clear();        path.clear();        sort(nums.begin(), nums.end()); // 排序        vector<bool> used(nums.size(), false);        backtracking(nums, used);        return result;    }};</code></pre><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后*"></a>51. N皇后*</h2><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或<strong>同一斜线</strong>！上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>题解：</p><p>重点是 isValid函数的逻辑</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:vector<vector<string>> result;// n 为输入的棋盘大小// row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector<string>& chessboard) {    if (row == n) {        result.push_back(chessboard);        return;    }    for (int col = 0; col < n; col++) {        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放            chessboard[row][col] = 'Q'; // 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] = '.'; // 回溯，撤销皇后        }    }}bool isValid(int row, int col, vector<string>& chessboard, int n) {    // 检查列    for (int i = 0; i < row; i++) { // 这是一个剪枝        if (chessboard[i][col] == 'Q') {            return false;        }    }    // 检查 45度角是否有皇后    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    // 检查 135度角是否有皇后    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    return true;}public:    vector<vector<string>> solveNQueens(int n) {        result.clear();        vector<string> chessboard(n, string(n, '.'));        backtracking(n, 0, chessboard);        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;回溯算法理论基础&quot;&gt;&lt;a href=&quot;#回溯算法理论基础&quot; class=&quot;headerlink&quot; title=&quot;回溯算法理论基础&quot;&gt;&lt;/a&gt;回溯算法理论基础&lt;/h2&gt;&lt;p&gt;回溯是递归的副产品，只要有递归就会有回溯。在下文中，&lt;strong&gt;回溯函数也就是递归函数，指的都是一个函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回溯法解决的问题都可以抽象为树形结构&lt;/strong&gt;，因为回溯法解决的都是在集合中递归查找子集，&lt;strong&gt;集合的大小就构成了树的宽度，递归的深度，都构成的树的深度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回溯三部曲：&lt;/p&gt;
&lt;pre class=&quot; language-lang-cpp&quot;&gt;&lt;code class=&quot;language-lang-cpp&quot;&gt;void backtracking(参数){
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;第77题-组合&quot;&gt;&lt;a href=&quot;#第77题-组合&quot; class=&quot;headerlink&quot; title=&quot;第77题. 组合&quot;&gt;&lt;/a&gt;第77题. 组合&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/wideresnet%E7%BB%93%E6%9E%84/"/>
    <id>https://youngyyp.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/wideresnet%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-11T04:35:18.089Z</published>
    <updated>2023-03-11T04:35:18.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WRN-28-10"><a href="#WRN-28-10" class="headerlink" title="WRN-28-10"></a>WRN-28-10</h3><p><img src="/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/wideresnet%E7%BB%93%E6%9E%84/Wide-Residual-Network-WRN-architecture-of-depth-10-and-widen-factor-4-including-7_Q640-16768105930529.jpg" alt="Wide Residual Network (WRN) architecture of depth 10 and widen factor... |  Download Scientific Diagram" style="zoom:33%;"></p><p>conv1<br>block1<br>block1.layer<br>block1.layer.0<br>block1.layer.0.bn1<br>block1.layer.0.relu1<br>block1.layer.0.conv1<br>block1.layer.0.bn2<br>block1.layer.0.relu2<br>block1.layer.0.conv2<br>block1.layer.0.convShortcut<br>block1.layer.1<br>block1.layer.1.bn1<br>block1.layer.1.relu1<br>block1.layer.1.conv1<br>block1.layer.1.bn2<br>block1.layer.1.relu2<br>block1.layer.1.conv2<br>block1.layer.2<br>block1.layer.2.bn1<br>block1.layer.2.relu1<br>block1.layer.2.conv1<br>block1.layer.2.bn2<br>block1.layer.2.relu2<br>block1.layer.2.conv2<br>block1.layer.3<br>block1.layer.3.bn1<br>block1.layer.3.relu1<br>block1.layer.3.conv1<br>block1.layer.3.bn2<br>block1.layer.3.relu2<br>block1.layer.3.conv2<br>block2<br>block2.layer<br>block2.layer.0<br>block2.layer.0.bn1<br>block2.layer.0.relu1<br>block2.layer.0.conv1<br>block2.layer.0.bn2<br>block2.layer.0.relu2<br>block2.layer.0.conv2<br>block2.layer.0.convShortcut<br>block2.layer.1<br>block2.layer.1.bn1<br>block2.layer.1.relu1<br>block2.layer.1.conv1<br>block2.layer.1.bn2<br>block2.layer.1.relu2<br>block2.layer.1.conv2<br>block2.layer.2<br>block2.layer.2.bn1<br>block2.layer.2.relu1<br>block2.layer.2.conv1<br>block2.layer.2.bn2<br>block2.layer.2.relu2<br>block2.layer.2.conv2<br>block2.layer.3<br>block2.layer.3.bn1<br>block2.layer.3.relu1<br>block2.layer.3.conv1<br>block2.layer.3.bn2<br>block2.layer.3.relu2<br>block2.layer.3.conv2<br>block3<br>block3.layer<br>block3.layer.0<br>block3.layer.0.bn1<br>block3.layer.0.relu1<br>block3.layer.0.conv1<br>block3.layer.0.bn2<br>block3.layer.0.relu2<br>block3.layer.0.conv2<br>block3.layer.0.convShortcut<br>block3.layer.1<br>block3.layer.1.bn1<br>block3.layer.1.relu1<br>block3.layer.1.conv1<br>block3.layer.1.bn2<br>block3.layer.1.relu2<br>block3.layer.1.conv2<br>block3.layer.2<br>block3.layer.2.bn1<br>block3.layer.2.relu1<br>block3.layer.2.conv1<br>block3.layer.2.bn2<br>block3.layer.2.relu2<br>block3.layer.2.conv2<br>block3.layer.3<br>block3.layer.3.bn1<br>block3.layer.3.relu1<br>block3.layer.3.conv1<br>block3.layer.3.bn2<br>block3.layer.3.relu2<br>block3.layer.3.conv2<br>bn1<br>relu<br>fc</p><p>[23/02/14 17:17:35] [cifar10c_offline.py:  259]: model for adaptation: WideResNet(<br>  (conv1): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>  (block1): NetworkBlock(<br>    (layer): Sequential(<br>      (0): BasicBlock(<br>        (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(16, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (convShortcut): Conv2d(16, 160, kernel_size=(1, 1), stride=(1, 1), bias=False)<br>      )<br>      (1): BasicBlock(<br>        (bn1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (2): BasicBlock(<br>        (bn1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (3): BasicBlock(<br>        (bn1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(160, 160, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>    )<br>  )<br>  (block2): NetworkBlock(<br>    (layer): Sequential(<br>      (0): BasicBlock(<br>        (bn1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(160, 320, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (convShortcut): Conv2d(160, 320, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>      )<br>      (1): BasicBlock(<br>        (bn1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (2): BasicBlock(<br>        (bn1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (3): BasicBlock(<br>        (bn1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(320, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>    )<br>  )<br>  (block3): NetworkBlock(<br>    (layer): Sequential(<br>      (0): BasicBlock(<br>        (bn1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(320, 640, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (convShortcut): Conv2d(320, 640, kernel_size=(1, 1), stride=(2, 2), bias=False)<br>      )<br>      (1): BasicBlock(<br>        (bn1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (2): BasicBlock(<br>        (bn1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>      (3): BasicBlock(<br>        (bn1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu1): ReLU(inplace=True)<br>        (conv1): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>        (bn2): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>        (relu2): ReLU(inplace=True)<br>        (conv2): Conv2d(640, 640, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)<br>      )<br>    )<br>  )<br>  (bn1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)<br>  (relu): ReLU(inplace=True)<br>  (fc): Linear(in_features=640, out_features=10, bias=True)<br>)<br>[23/0</p>]]></content>
    
    
    <summary type="html">WRN-28-10


conv1
block1
block1.layer
block1.layer.0
block1.layer.0.bn1
block1.layer.0.relu1
block1.layer.0.conv1
block1.layer.0.bn2
block1.layer.0.relu2
block1.layer.0.conv2
block1.layer.0.convShortcut
block1.layer.1
block1.layer.1.bn1
block1.layer.1.relu1
block1.layer.1.conv1
block1.layer.1.bn2
bl</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/work/%E7%AE%80%E5%8E%86/"/>
    <id>https://youngyyp.github.io/2023/03/11/work/%E7%AE%80%E5%8E%86/</id>
    <published>2023-03-11T04:35:15.409Z</published>
    <updated>2023-03-11T04:35:15.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕业设计-基于目标域自适应的在线学习算法研究"><a href="#毕业设计-基于目标域自适应的在线学习算法研究" class="headerlink" title="毕业设计 -  基于目标域自适应的在线学习算法研究"></a>毕业设计 -  基于目标域自适应的在线学习算法研究</h2><p>课题简介：针对深度神经网络在分布偏移的目标域中存在性能急剧下降的问题，研究目标域自适应算法，实现在不改变原模型和训练流程的情况下，仅通过目标域的无标签数据对模型参数进行在线更新，从而极大提升模型对动态变化环境的适应能力。 </p><p>当前进度：基于最小化预测熵的思想，在只给定测试数据的情况下，通过将损失函数替换为最小化预测熵，来最小化模型的不确定性；同时提取神经网络在目标域参数优化轨迹的低维子空间，并在子空间上进行网络参数的更新，以提高模型的鲁棒性，从而避免灾难性遗忘问题。目前在cifar10/100c上测试结果已超越SOTA水平。</p><ul><li>在仅给定测试数据和源模型的情况下，通过<strong>最小化预测熵</strong>损失函数来减少模型不确定性。同时在目标域优化轨迹的<strong>低维子空间</strong>上更新模型参数，以提高模型鲁棒性，避免灾难性遗忘。目前在cifar10/100c上测试结果已超SOTA水平。</li></ul><h2 id="基于单目视觉的飞机位姿估计系统"><a href="#基于单目视觉的飞机位姿估计系统" class="headerlink" title="基于单目视觉的飞机位姿估计系统"></a>基于单目视觉的飞机位姿估计系统</h2><p>根据项目要求采用了传统方法和基于深度学习的方法，传统方法首先采集目标模板图像，使用sfm对目标进行稀疏重建以获得2D-3D点对应，通过orb特征匹配算法将输入图像与模板库图像进行匹配，选择最优匹配图像后通过PnP解算位姿，并通过卡尔曼滤波排除异常值。</p><p>深度学习的方法，预先采集并标注目标检测数据集和关键点识别数据集，通过YOLOv5目标检测网络进行识别以及裁剪图像，然后通过自定义的UNet关键点检测网络识别目标上的2D关键点，最终通过PnP算法求解位姿。</p><p>最终实现30ms延时内定位精度优于2%的效果。</p><p><img src="/2023/03/11/work/%E7%AE%80%E5%8E%86/image-20230305114017843.png" alt="image-20230305114017843"></p><p><img src="/2023/03/11/work/%E7%AE%80%E5%8E%86/流程图.png" alt="流程图"></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h4 id="工具栈"><a href="#工具栈" class="headerlink" title="工具栈"></a>工具栈</h4><p>python、C++、verilog、pytorch、linux、opencv图像处理库</p><h4 id="理论栈"><a href="#理论栈" class="headerlink" title="理论栈"></a>理论栈</h4><p>域自适应、特征匹配（传统or深度）、目标检测、视觉位姿估计算法、多视图几何？</p><p>{YePeng Yang} received the B.E. degree in electronic information engineering from Huazhong University of Science and Technology, Wuhan, China, in 2021. Since 2021, he has been with the Brain-inspired Application Technology Center, Shanghai Jiao Tong University, where he is currently pursuing the Master degree. His main research interests include domain adaptation and feature matching.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;毕业设计-基于目标域自适应的在线学习算法研究&quot;&gt;&lt;a href=&quot;#毕业设计-基于目标域自适应的在线学习算法研究&quot; class=&quot;headerlink&quot; title=&quot;毕业设计 -  基于目标域自适应的在线学习算法研究&quot;&gt;&lt;/a&gt;毕业设计 -  基于目标域自适应的在线学习算法研究&lt;/h2&gt;&lt;p&gt;课题简介：针对深度神经网络在分布偏移的目标域中存在性能急剧下降的问题，研究目标域自适应算法，实现在不改变原模型和训练流程的情况下，仅通过目标域的无标签数据对模型参数进行在线更新，从而极大提升模型对动态变化环境的适应能力。 &lt;/p&gt;
&lt;p&gt;当前进度：基于最小化预测熵的思想，在只给定测试数据的情况下，通过将损失函数替换为最小化预测熵，来最小化模型的不确定性；同时提取神经网络在目标域参数优化轨迹的低维子空间，并在子空间上进行网络参数的更新，以提高模型的鲁棒性，从而避免灾难性遗忘问题。目前在cifar10/100c上测试结果已超越SOTA水平。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在仅给定测试数据和源模型的情况下，通过&lt;strong&gt;最小化预测熵&lt;/strong&gt;损失函数来减少模型不确定性。同时在目标域优化轨迹的&lt;strong&gt;低维子空间&lt;/strong&gt;上更新模型参数，以提高模型鲁棒性，避免灾难性遗忘。目前在cifar10/100c上测试结果已超SOTA水平。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基于单目视觉的飞机位姿估计系统&quot;&gt;&lt;a href=&quot;#基于单目视觉的飞机位姿估计系统&quot; class=&quot;headerlink&quot; title=&quot;基于单目视觉的飞机位姿估计系统&quot;&gt;&lt;/a&gt;基于单目视觉的飞机位姿估计系统&lt;/h2&gt;&lt;p&gt;根据项目要求采用了传统方法和基于深度学习的方法，传统方法首先采集目标模板图像，使用sfm对目标进行稀疏重建以获得2D-3D点对应，通过orb特征匹配算法将输入图像与模板库图像进行匹配，选择最优匹配图像后通过PnP解算位姿，并通过卡尔曼滤波排除异常值。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-11T04:35:13.655Z</published>
    <updated>2023-03-11T04:35:13.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法理论基础"><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接(opens new window)</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>思路：排序后遍历，将最大的饼干喂给能喂饱的胃口最大的孩子。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findContentChildren(vector<int>& g, vector<int>& s) {        sort(g.begin(), g.end());        sort(s.begin(), s.end());        int index = s.size() - 1; // 饼干数组的下标        int result = 0;        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口             if (index >= 0 && s[index] >= g[i]) { // 遍历饼干                 result++;                index--;            }        }        return result;    }};</code></pre><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/">力扣题目链接(opens new window)</a></p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>思路：</p><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int candy(vector<int>& ratings) {        vector<int> candyVec(ratings.size(), 1);        // 从前向后        for (int i = 1; i < ratings.size(); i++) {            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;        }        // 从后向前        for (int i = ratings.size() - 2; i >= 0; i--) {            if (ratings[i] > ratings[i + 1] ) {                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);            }        }        // 统计结果        int result = 0;        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];        return result;    }};</code></pre><h3 id="BM96-主持人调度（二）"><a href="#BM96-主持人调度（二）" class="headerlink" title="BM96 主持人调度（二）"></a><strong>BM96</strong> <strong>主持人调度（二）</strong></h3><h2 id="方法二（排序-贪心）"><a href="#方法二（排序-贪心）" class="headerlink" title="方法二（排序+贪心）"></a>方法二（排序+贪心）</h2><h4 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1.解题思路"></a>1.解题思路</h4><ul><li>首先建立两个数组分别存储开始时间（记为start）和结束时间（记为end）。</li><li>然后分别对start和end数组进行排序。</li><li>接着遍历start数组，判断当前开始时间是否大于等于最小的结束时间，如果是，则说明当前主持人就可以搞定（对应当前最小的结束时间的那个活动）；如果否，则需要新增一个主持人，并将end数组下标后移（表示对应的活动已经有人主持）。</li></ul><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">public class Solution {    public int minmumNumberOfHost (int n, int[][] startEnd) {        //初始化两个数组，分别记录开始时间和结束时间 ， 用vector也可以        int[] start=new int[n];        int[] end=new int[n];        //将活动的开始和结束时间赋值道start和end数组        for(int i=0;i<n;i++){            start[i]=startEnd[i][0];            end[i]=startEnd[i][1];        }        //按从小到大的顺序对start和end数组排序        Arrays.sort(start);        Arrays.sort(end);        int res=0,index=0;        for(int i=0;i<n;i++){            //如果大于等于当前最小的结束时间，说明当前主持人可以搞定 ????why？？？            if(start[i]>=end[index]){                index++;            }            //否则，需要新增主持人            else{                res++;            }        }        return res;    }}</code></pre><h4 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h4><ul><li>时间复杂度：需要进行排序，排序接口的时间复杂度是<script type="math/tex">O(nlogn)</script>，所以时间复杂度为<script type="math/tex">O(nlogn)</script></li><li>空间复杂度：需要额外大小为n的start和end数组，所以空间复杂度为<script type="math/tex">O(n)</script>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;贪心算法理论基础&quot;&gt;&lt;a href=&quot;#贪心算法理论基础&quot; class=&quot;headerlink&quot; title=&quot;贪心算法理论基础&quot;&gt;&lt;/a&gt;贪心算法理论基础&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;贪心的本质是选择每一阶段的局部最优，从而达到全局最优&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有同学问了如何验证可不可以用贪心算法呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;455-分发饼干&quot;&gt;&lt;a href=&quot;#455-分发饼干&quot; class=&quot;headerlink&quot; title=&quot;455.分发饼干&quot;&gt;&lt;/a&gt;455.分发饼干&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/assign-cookies/&quot;&gt;力扣题目链接(opens new window)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-03-11T04:35:09.865Z</published>
    <updated>2023-03-11T04:35:09.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverseString(vector<char>& s) {        char temp;        int left = 0;        int right = s.size() - 1;        while(left < right){            temp = s[right];            s[right] = s[left];            s[left] = temp;            left++;            right--;        }    }};</code></pre><p>解析答案：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void reverseString(vector<char>& s) {    for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {        swap(s[i],s[j]); //注意何时使用库函数    }}</code></pre><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseStr(string s, int k) {        for(int i = 0; i < s.size(); i = i + 2*k){            if(i + k > s.size()) reverse(s.begin()+i,s.end());            else reverse(s.begin()+i,s.begin()+i+k);        }        return s;    }    //也可自己构造reverse,但要记住官方的reverse是左闭右开    // void reverse_me(string& s, int start, int end) {    //     for (int i = start, j = end+1; i < j; i++, j--) {    //         swap(s[i], s[j-1]);    //     }    // }};</code></pre><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>思路：</strong></p><p>首先扩充数组到每个空格替换成”%20”之后的大小。</p><p>然后从后向前替换空格，也就是双指针法</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        int length = s.size();        for(int i = 0; i < s.size(); i++){            if(s[i] == ' '){                length = length + 2;            }        }        int left = s.size() - 1;        int right = length - 1;        s.resize(length);        while(left >= 0){            if(s[left] == ' '){                s[right] = '0';                s[right-1] = '2';                s[right-2] = '%';                right = right - 3;            }else{                s[right] = s[left];                right--;             }            left--;        }        return s;    }};</code></pre><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词*"></a>翻转字符串里的单词*</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><strong>思路：</strong></p><p>若要不额外占用空间，首先去除多余空格，再翻转整个字符串，再用双指针翻转每个单词</p><p><strong>我的：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseWords(string s) {        //双指针去除多余空格        int a = 0,b = 0;        while(a == 0 && s[b] == ' ') b++;        for(;b < s.size(); b++){            if(s[b] == ' ' && (s[b+1] == ' ' || b+1 >= s.size())) continue;             else {                s[a] = s[b];                a++;            }        }        s.resize(a);        //翻转字符串        reverse(s,0,s.size());        //双指针翻转每个单词        for(int c = 0,d = 0; d <= s.size(); d++){            if(s[d] == ' '|| d == s.size()){                reverse(s,c,d);                c = d + 1;            }        }        return s;    }    //左闭右开    void reverse(string& s, int start, int end) {        for (int i = start, j = end-1; i < j; i++, j--) {            swap(s[i], s[j]);        }    }};</code></pre><p><strong>题解：</strong></p><p><a href="https://www.cnblogs.com/zou-ma/p/16162731.html">https://www.cnblogs.com/zou-ma/p/16162731.html</a> </p><p>在 for 循环中，<code>i++</code>和 <code>++i</code>是一样一样的，但是<code>++i</code>的循环耗时短。</p><p>使用<code>++i</code>是一定程度上的系统优化</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []        for (int i = start, j = end; i < j; i++, j--) {            swap(s[i], s[j]);        }    }    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html        for (int i = 0; i < s.size(); ++i) { //            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。                    s[slow++] = s[i++];                }            }        }        s.resize(slow); //slow的大小即为去除多余空格后的大小。    }    string reverseWords(string s) {        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。        reverse(s, 0, s.size() - 1);        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。        for (int i = 0; i <= s.size(); ++i) {            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。                start = i + 1; //更新下一个单词的开始下标start            }        }        return s;    }};</code></pre><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><p><strong>题解：</strong></p><p>整体反转+局部反转就可以实现反转单词顺序的目的</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseLeftWords(string s, int n) {        reverse(s.begin(),s.end());        reverse(s.begin(),s.end()-n);        reverse(s.end()-n,s.end());        return s;    }};</code></pre><h2 id="实现-strStr-——KMP算法"><a href="#实现-strStr-——KMP算法" class="headerlink" title="实现 strStr()——KMP算法"></a>实现 strStr()——KMP算法</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">力扣题目链接(opens new window)</a></p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h4 id="kmp算法："><a href="#kmp算法：" class="headerlink" title="kmp算法："></a>kmp算法：</h4><p>那么使用KMP可以解决两类经典问题：</p><ol><li>匹配问题：<a href="https://programmercarl.com/0028.实现strStr.html">28. 实现 strStr()(opens new window)</a></li><li>重复子串问题：<a href="https://programmercarl.com/0459.重复的子字符串.html">459.重复的子字符串</a></li></ol><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>文本串：aabaabaaf</p><p>模式串：aabaaf</p><p>next数组就是一个前缀表（prefix table），即最长相等前后缀</p><p>前缀：包含首字母，不包含尾字母的所有子串</p><p>后缀：包含尾字母，不包含首字母的所有子串</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>前缀表的求法：</p><p><img src="/2023/03/11/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230212143008343.png" alt="image-20230212143008343" style="zoom: 25%;"></p><p>遇见冲突后找冲突的前一位所对应的前缀表，再从前缀表所对下标处继续匹配</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p>初始化： j 指向前缀末尾位置（也是当前公共前后缀的长度）   i 指向后缀末尾位置</p><p>前后缀不相同</p><p>前后缀相同</p><p>更新next数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext(int* next, const string& s) {        //初始化        int j = 0;        next[0] = 0;        // 相等就加（(i 和 j 都得加，而j加1后刚好等于当前i对应的next)，不相等就回溯;先考虑不相等的情况        for(int i = 1; i < s.size(); i++) {            while (j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if (s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    int strStr(string haystack, string needle) {        if (needle.size() == 0) {            return 0;        }        int next[needle.size()];        getNext(next, needle);        int j = 0;        for (int i = 0; i < haystack.size(); i++) {            while(j > 0 && haystack[i] != needle[j]) {                j = next[j - 1];            }            if (haystack[i] == needle[j]) {                j++;            }            if (j == needle.size() ) {                return (i - needle.size() + 1);            }        }        return -1;    }};</code></pre><h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><p><strong>思路：</strong></p><p>字符串s：abcabc</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt="图二"></p><p>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>我的思路：可用上题的strStr()找</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">    bool repeatedSubstringPattern(string s) {        string t = s + s;        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾        if(strStr(t,s) != -1) return true;        return false;    }</code></pre><p>用KMP算法：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728212157.png" alt="图四" style="zoom:50%;"></p><p>如果len % (len - (next[len - 1])) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext (int* next, const string& s){        next[0] = 0;        int j = 0;        for(int i = 1;i < s.size(); i++){            while(j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if(s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    bool repeatedSubstringPattern(string s) {        int len = s.size();        int next[len];        getNext(next, s);        if(next[len - 1] != 0 && len % (len - (next[len - 1])) == 0) return true;        else return false;    }};</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;反转字符串&quot;&gt;&lt;a href=&quot;#反转字符串&quot; class=&quot;headerlink&quot; title=&quot;反转字符串&quot;&gt;&lt;/a&gt;反转字符串&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot;&gt;力扣题目链接(opens new window)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;输入：[“h”,”e”,”l”,”l”,”o”]&lt;br&gt;输出：[“o”,”l”,”l”,”e”,”h”]&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://youngyyp.github.io/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-03-11T04:34:54.245Z</published>
    <updated>2023-03-11T04:34:54.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树理论基础篇"><a href="#二叉树理论基础篇" class="headerlink" title="#二叉树理论基础篇"></a><a href="https://www.programmercarl.com/二叉树理论基础.html#二叉树理论基础篇">#</a>二叉树理论基础篇</h2><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn</p><p>unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表</p><p>一棵树当中没有子结点（即度为0）的结点称为<em>叶子</em>结点，简称“<em>叶子</em>”</p><p><strong>二叉树主要有两种遍历方式：</strong></p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>前中后是针对中间的节点</p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20200806191109896.png" alt="img" style="zoom:50%;"></p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="#二叉树的定义"></a><a href="https://www.programmercarl.com/二叉树理论基础.html#二叉树的定义">#</a>二叉树的定义</h3><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p><p>C++代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct TreeNode {    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) {}};</code></pre><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><h4 id="递归三要素："><a href="#递归三要素：" class="headerlink" title="递归三要素："></a>递归三要素：</h4><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p><strong>以下以前序遍历为例：</strong></p><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec)</code></pre><ol><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">if (cur == NULL) return;</code></pre><ol><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">vec.push_back(cur->val);    // 中traversal(cur->left, vec);  // 左traversal(cur->right, vec); // 右</code></pre><p>前序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void traversal(TreeNode* cur, vector<int>& vec) {        if (cur == NULL) return;        vec.push_back(cur->val);    // 中        traversal(cur->left, vec);  // 左        traversal(cur->right, vec); // 右    }    vector<int> preorderTraversal(TreeNode* root) {        vector<int> result;        traversal(root, result);        return result;    }};</code></pre><p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p><p>中序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec) {    if (cur == NULL) return;    traversal(cur->left, vec);  // 左    vec.push_back(cur->val);    // 中    traversal(cur->right, vec); // 右}</code></pre><p>后序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec) {    if (cur == NULL) return;    traversal(cur->left, vec);  // 左    traversal(cur->right, vec); // 右    vec.push_back(cur->val);    // 中}</code></pre><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong></p><p>可以用<strong>栈</strong>实现二叉树的前后中序遍历</p><h4 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/二叉树前序遍历（迭代法）-16766184074375.gif" alt="二叉树前序遍历（迭代法）" style="zoom: 67%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> preorderTraversal(TreeNode* root) {        stack<TreeNode*> st;        vector<int> result;        if (root == NULL) return result;        st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();                       // 中            st.pop();            result.push_back(node->val);            if (node->right) st.push(node->right);           // 右（空节点不入栈）            if (node->left) st.push(node->left);             // 左（空节点不入栈）        }        return result;    }};</code></pre><p><strong>中序遍历，可以写出如下代码：</strong></p><p><strong>需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素</strong></p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> inorderTraversal(TreeNode* root) {        vector<int> result;        stack<TreeNode*> st;        TreeNode* cur = root;        while (cur != NULL || !st.empty()) {            if (cur != NULL) { // 指针来访问节点，访问到最底层                st.push(cur); // 将访问的节点放进栈                cur = cur->left;                // 左            } else {                cur = st.top(); // 从栈里弹出的数据，就是放进result数组里的数据                st.pop();                result.push_back(cur->val);     // 中                cur = cur->right;               // 右            }        }        return result;    }};</code></pre><p>后序：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> postorderTraversal(TreeNode* root) {        stack<TreeNode*> st;        vector<int> result;        if (root == NULL) return result;        st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();            st.pop();            result.push_back(node->val);            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）            if (node->right) st.push(node->right); // 空节点不入栈        }        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了        return result;    }};</code></pre><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><h4 id="迭代法中序遍历"><a href="#迭代法中序遍历" class="headerlink" title="迭代法中序遍历"></a>迭代法中序遍历</h4><p>中序遍历代码如下：（详细注释）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> inorderTraversal(TreeNode* root) {        vector<int> result;        stack<TreeNode*> st;        if (root != NULL) st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();            if (node != NULL) {                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）                st.push(node);                          // 添加中节点                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           // 将空节点弹出                node = st.top();    // 重新取出栈中元素                st.pop();                result.push_back(node->val); // 加入到结果集            }        }        return result;    }};</code></pre><p><strong>中节点放入栈之后，紧接着放入一个空指针作为标记</strong></p><h2 id="102-二叉树的层序遍历——广度优先"><a href="#102-二叉树的层序遍历——广度优先" class="headerlink" title="102.二叉树的层序遍历——广度优先"></a>102.二叉树的层序遍历——广度优先</h2><p>广度用队列，深度用栈</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//迭代法class Solution {public:    vector<vector<int>> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<vector<int>> result;        while (!que.empty()) {            int size = que.size();            vector<int> vec;            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的            for (int i = 0; i < size; i++) {                TreeNode* node = que.front();                que.pop();                vec.push_back(node->val);                if (node->left) que.push(node->left);                if (node->right) que.push(node->right);            }            result.push_back(vec);        }        return result;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 递归法class Solution {public:    void order(TreeNode* cur, vector<vector<int>>& result, int depth)    {        if (cur == nullptr) return;        if (result.size() == depth) result.push_back(vector<int>());        result[depth].push_back(cur->val);        order(cur->left, result, depth + 1);        order(cur->right, result, depth + 1);    }    vector<vector<int>> levelOrder(TreeNode* root) {        vector<vector<int>> result;        int depth = 0;        order(root, result, depth);        return result;    }};</code></pre><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣题目链接(opens new window)</a></p><p>翻转一棵二叉树。</p><p>思路：</p><p>采用递归前序的方法。</p><p><a href="https://www.programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%8B%93%E5%B1%95">题解还有更多其他方法</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void order(TreeNode* cur)    {        if (cur == nullptr) return;        TreeNode* temp = cur->left;        cur->left = cur->right;        cur->right = temp;        order(cur->left);        order(cur->right);    }    TreeNode* invertTree(TreeNode* root) {        order(root);        return root;    }};</code></pre><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>递归法：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool compare(TreeNode* left, TreeNode* right){        if (left == NULL && right != NULL) return false;        else if (left != NULL && right == NULL) return false;        else if (left == NULL && right == NULL) return true;        else if (left->val != right->val) return false;         else{            bool outside = compare(left->left, right->right);            bool inside = compare(left->right, right->left);            bool isSame = outside && inside;            return isSame;        }    }    bool isSymmetric(TreeNode* root) {        if(root == NULL) return true;        return compare(root->left,root->right);    }};</code></pre><p>迭代法的条件判断和递归的逻辑是一样的。</p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isSymmetric(TreeNode* root) {        if (root == NULL) return true;        queue<TreeNode*> que;        que.push(root->left);   // 将左子树头结点加入队列        que.push(root->right);  // 将右子树头结点加入队列        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转            TreeNode* leftNode = que.front(); que.pop();            TreeNode* rightNode = que.front(); que.pop();            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的                continue;            }            // 左右一个节点不为空，或者都不为空但数值不相同，返回false            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {                return false;            }            que.push(leftNode->left);   // 加入左节点左孩子            que.push(rightNode->right); // 加入右节点右孩子            que.push(leftNode->right);  // 加入左节点右孩子            que.push(rightNode->left);  // 加入右节点左孩子        }        return true;    }};</code></pre><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p><p>返回它的最大深度 3 。</p><p><strong>我的代码：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    //使用递归法    int order(TreeNode* cur, int depth){        if(cur == NULL) return depth;        depth++;        int d1 = order(cur->left,depth);        int d2 = order(cur->right,depth);        depth = max(d1,d2);        return depth;    }    int maxDepth(TreeNode* root) {        int depth = 0;        return order(root, depth);    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//迭代法 层序遍历class Solution {public:    int maxDepth(TreeNode* root) {        if(root == NULL) return 0;        int depth = 0;        queue<TreeNode*> que;        que.push(root);        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }            depth++;        }        return depth;    }};</code></pre><p>我的n叉树求最大深度代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    //使用递归法    int order(Node* cur, int depth){        if(cur == NULL) return depth;        depth++;        int maxDepth = depth;        for(int i = 0; i < cur->children.size(); i++){            int d1 = order(cur->children[i],depth);            maxDepth = max(d1,maxDepth);        }        return maxDepth;    }    int maxDepth(Node* root) {        int depth = 0;        return order(root, depth);    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxDepth(Node* root) {        if (root == 0) return 0;        int depth = 0;        for (auto child : root->children){            depth = max(depth, maxDepth(child));        }        return depth + 1;    }};</code></pre><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从<strong>根节点到最近叶子节点</strong>的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><p><img src="https://img-blog.csdnimg.cn/2021020315582586.png" alt="111.二叉树的最小深度1"></p><p>返回它的最小深度 2</p><p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度" style="zoom:33%;"></p><p>我的代码 ：</p><p>本题核心就是找到根节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 后续遍历class Solution {public:// 如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。// 反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。// 最后如果左右子树都不为空，返回左右子树深度最小值 + 1     int getDepth(TreeNode* node){        int depth = 0;        if(node == NULL) return 0;        //上式不等价于node->left == NULL && node->right == NULL 的情况，而是表明这个节点为空，不会增加深度。        int leftDepth = getDepth(node->left);//左        int rightDepth = getDepth(node->right);//右        // 中  但是没有要处理的        if(node->left == NULL && node->right != NULL) return rightDepth + 1;        if(node->left != NULL && node->right == NULL) return leftDepth + 1;        // if(node->left != NULL && node->right != NULL) return min(leftDepth,rightDepth) + 1;        // if(node->left == NULL && node->right == NULL) return 0 + 1;  叶子节点 深度加1        return min(leftDepth,rightDepth) + 1;  //最好还是在所有分支都给返回值，防止编译器判断为无返回值    }    int minDepth(TreeNode* root) {        return getDepth(root);    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//题解：前序class Solution {private:    int result;    void getdepth(TreeNode* node, int depth) {        if (node->left == NULL && node->right == NULL) {            result = min(depth, result);              return;        }        // 中 只不过中没有处理的逻辑        if (node->left) { // 左            getdepth(node->left, depth + 1);        }        if (node->right) { // 右            getdepth(node->right, depth + 1);        }        return ;    }public:    int minDepth(TreeNode* root) {        if (root == NULL) return 0;        result = INT_MAX;        getdepth(root, 1);        return result;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//用队列进行层序遍历，逻辑比较清晰class Solution {public:    int minDepth(TreeNode* root) {        if (root == NULL) return 0;        int depth = 0;        queue<TreeNode*> que;        que.push(root);        while(!que.empty()) {            int size = que.size();            depth++; // 记录最小深度            for (int i = 0; i < size; i++) {                TreeNode* node = que.front();                que.pop();                if (node->left) que.push(node->left);                if (node->right) que.push(node->right);                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出                    return depth;                }            }        }        return depth;    }};</code></pre><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">力扣题目链接(opens new window)</a></p><p>给出一个完全二叉树，求出该树的节点个数。</p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20200920221638903.png" alt="img" style="zoom: 33%;"></p><p>我的代码（没有针对完全二叉树做优化）：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int countNodes(TreeNode* root) {        queue<TreeNode*> que;        if(root != NULL) que.push(root);        int num = 0;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                num++;                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }        }        return num;    }};</code></pre><p>题解：</p><p>这个就不是满二叉树</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:33%;"></p><p>判断其子树是不是满二叉树(一直向左遍历的深度==一直向右遍历的深度)，如果是则利用公式（2^树深度 - 1 ，注意这里根节点深度为1）计算这个子树（满二叉树）的节点数量，如果不是则继续递归</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int countNodes(TreeNode* root) {        if (root == nullptr) return 0;        TreeNode* left = root->left;        TreeNode* right = root->right;        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便        while (left) {  // 求左子树深度            left = left->left;            leftDepth++;        }        while (right) { // 求右子树深度            right = right->right;            rightDepth++;        }        if (leftDepth == rightDepth) {            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0        }        //上面是返回条件        return countNodes(root->left) + countNodes(root->right) + 1;    }};</code></pre><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>这里强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210203155515650.png" alt="110.平衡二叉树2" style="zoom:50%;"></p><p>采用递归：</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int getHeight(TreeNode* node){        if(node == NULL) return 0;        int leftHeight = getHeight(node->left);        if(leftHeight == -1) return -1;        int rightHeight = getHeight(node->right);        if(rightHeight == -1) return -1;        if(abs(leftHeight-rightHeight)>1) return -1;        else return 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度    }    bool isBalanced(TreeNode* root) {        int result = getHeight(root);        if(result != -1) return true;        else return false;    }};</code></pre><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>题解：</p><p>to_string() 将数字转为string</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    void traversal(TreeNode* cur, string path, vector<string>& result) {        path += to_string(cur->val); // 中        if (cur->left == NULL && cur->right == NULL) {            result.push_back(path);            return;        }        if (cur->left) traversal(cur->left, path + "->", result); // 左        if (cur->right) traversal(cur->right, path + "->", result); // 右    }public:    vector<string> binaryTreePaths(TreeNode* root) {        vector<string> result;        string path;        if (root == NULL) return result;        traversal(root, path, result);        return result;    }};</code></pre><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接(opens new window)</a></p><p>计算给定二叉树的所有左叶子之和。</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int sumleft(TreeNode* root , int leftfig, int sum){        // int leftfig = 0;        // int sum = 0;        if(root->left == NULL && root->right == NULL && leftfig == 1){            return sum + root->val;        }        int sum1 = 0;        int sum2 = 0;        if(root->left) sum1 = sumleft(root->left, 1 ,sum);        if(root->right) sum2 = sumleft(root->right, 0 ,sum);        return sum1 + sum2;    }    int sumOfLeftLeaves(TreeNode* root) {        int leftfig = 0;        int sum = 0;        if(root == NULL) return 0;        return sumleft(root, leftfig, sum);    }};</code></pre><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>我的代码：</p><p>层序遍历</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findBottomLeftValue(TreeNode* root) {        queue <TreeNode*> que;        que.push(root);        int result;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                if(i == 0) result = node->val; //关键是这一行，记录最后一层的第一个元素                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }        }        return result;    }};</code></pre><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>我的代码：参考<strong>257. 二叉树的所有路径</strong></p><p>当不用遍历所有二叉树时，需要返回值，如本题，一旦找到路径就返回。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool traversal(TreeNode* cur, int pathsum, int targetSum) {        pathsum += cur->val; // 中        if (cur->left == NULL && cur->right == NULL) {            if(pathsum == targetSum) return true;            else return false;        }        bool leftsig;        bool rightsig;        if (cur->left) leftsig = traversal(cur->left, pathsum, targetSum); // 左        if (cur->right) rightsig = traversal(cur->right, pathsum, targetSum); // 右        return leftsig || rightsig; //这里也可以优化一下，只要leftsig=1，就返回，right同理    }    bool hasPathSum(TreeNode* root, int targetSum) {        if(root == NULL) return false;        return traversal(root, 0, targetSum);    }};</code></pre><h2 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h2><p><a href="https://leetcode.cn/problems/path-sum-ii/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>我的代码：参考<strong>257. 二叉树的所有路径</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void traversal(TreeNode* cur, vector<int> path, int pathsum, int targetSum, vector<vector<int>>& path_results) {        path.push_back(cur->val);        pathsum += cur->val; // 中        if (cur->left == NULL && cur->right == NULL) {            if(pathsum == targetSum){                path_results.push_back(path);                return ;            }             else return;        }        if (cur->left) traversal(cur->left, path, pathsum, targetSum, path_results); // 左        if (cur->right) traversal(cur->right, path, pathsum, targetSum, path_results); // 右        return ;    }    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {        vector<vector<int>> path_results;        vector<int> path;        if(root == NULL) return path_results;        traversal(root, path, 0, targetSum, path_results);        return path_results;    }};</code></pre><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树*"></a>106.从中序与后序遍历序列构造二叉树*</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接(opens new window)</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20210203154316774-16775032045302.png" alt="106. 从中序与后序遍历序列构造二叉树1" style="zoom:100%;"></p><p>思路：</p><p>以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* traversal(vector<int>& inorder, vector<int>& postorder) {            // 第一步 终止条件        if (postorder.size() == 0) return NULL;        int rootValue = postorder[postorder.size() - 1];        TreeNode* root = new TreeNode(rootValue);        if (postorder.size() == 1) return root;// 叶子节点        // 找到中序遍历的切割点        int delimiterIndex;        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {            if (inorder[delimiterIndex] == rootValue) break;        }        // 切割中序数组  这题关键：这里切割的写法        // 左闭右开区间：[0, delimiterIndex)        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);        // [delimiterIndex + 1, end)        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );        // 切割后序        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());        // [leftInorder.size(), end)        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()- 1);        root->left = traversal(leftInorder, leftPostorder);        root->right = traversal(rightInorder, rightPostorder);        return root;        }    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {        if (inorder.size() == 0 || postorder.size() == 0) return NULL;        return traversal(inorder, postorder);    }};</code></pre><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">力扣题目地址(opens new window)</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img" style="zoom:50%;"></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* recursion(vector<int> nums) {        if(nums.size() == 0) return NULL;        int rootValue = 0;        int rootValueIndex = 0;        for(int i = 0; i < nums.size(); i++){            if(nums[i]>rootValue){                rootValue = nums[i];                rootValueIndex = i;            }        }        TreeNode* root = new TreeNode(rootValue);        vector<int> leftnums(nums.begin(), nums.begin() + rootValueIndex);        vector<int> rightnums(nums.begin() + rootValueIndex + 1, nums.end());        root->left = recursion(leftnums);        root->right = recursion(rightnums);        return root;    }    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {        return recursion(nums);    }};</code></pre><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接(opens new window)</a></p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>我的代码：</p><p>也可以不new，在root1上改</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {        TreeNode* root = new TreeNode();        if(root1 == NULL) return root2;        if(root2 == NULL) return root1;        root->val = root1->val + root2->val;        root->left = mergeTrees(root1->left,root2->left);        root->right = mergeTrees(root1->right,root2->right);        return root;     }};</code></pre><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">力扣题目地址(opens new window)</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>思路：</p><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* searchBST(TreeNode* root, int val) {        if(root == NULL) return NULL;        if(root->val == val){            return root;        }        if(root->val < val){            return searchBST(root->right, val);        }        if(root->val > val){            return searchBST(root->left, val);        }        return NULL;    }};</code></pre><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树*"></a>98.验证二叉搜索树*</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>思路：</p><p>这道题目比较容易陷入两个陷阱：</p><ul><li>陷阱1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。<strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。</p><p>例如： [10,5,15,null,null,6,20] 这个case：</p><p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树" style="zoom: 67%;"></p><p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p><ul><li>陷阱2</li></ul><p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p><p>此时可以初始化比较元素为longlong的最小值<code>long long maxVal = LONG_MIN;</code></p><p><strong>核心思想：二叉搜索树如果按左中右（中序）顺序遍历，则数据是递增的</strong></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//先变成数组class Solution {private:    vector<int> vec;    void traversal(TreeNode* root) {        if (root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }public:    bool isValidBST(TreeNode* root) {        vec.clear(); // 不加这句在leetcode上也可以过，但最好加上        traversal(root);        for (int i = 1; i < vec.size(); i++) {            // 注意要小于等于，搜索树里不能有相同元素            if (vec[i] <= vec[i - 1]) return false;        }        return true;    }};</code></pre><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接(opens new window)</a></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>我的代码（参考98）：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> vec;    void traversal(TreeNode* root){        if(root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }    int getMinimumDifference(TreeNode* root) {        traversal(root);        int min_sub = 100000;        for (int i = 1; i < vec.size(); i++) {            min_sub = min(min_sub,vec[i] - vec[i - 1]);        }        return min_sub;    }};</code></pre><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>思路：</p><p>针对任意二叉树，可以使用map（有序，key是次数，value是节点值）</p><p>这里是二叉搜索树，是递增的，可以只比较相邻元素</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> vec;    void traversal(TreeNode* root){        if(root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }    vector<int> findMode(TreeNode* root) {        traversal(root);        int left = 0;        int maxnum = 0;        vector<int> results;        for (int right = 0; right < vec.size(); right++) {            if(vec[left] != vec[right]) left = right;            if(maxnum < right - left){                maxnum = right - left;                results.clear(); //这里很关键                results.push_back(vec[right]);            }else if(maxnum == right - left){                results.push_back(vec[right]);            }        }        return results;    }};</code></pre><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>我的代码：</p><p>返回子树中找到目标值的个数</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* result = NULL;    int traversal(TreeNode* node, TreeNode* p, TreeNode* q) {        if(result != NULL) return 2;        int leftfig = 0;        int rightfig = 0;        if(node->left) leftfig = traversal(node->left, p, q);        else leftfig = 0;        if(node->right) rightfig = traversal(node->right, p, q);        else rightfig = 0;        if(leftfig == 1 && rightfig == 1) {            result = node;            return 2;        }else if((leftfig == 1 && rightfig == 0)or(leftfig == 0 && rightfig == 1)){            if(node == p || node == q) {                result = node;                return 2;            }            else return 1;        }         else if(leftfig == 0 && rightfig == 0) {            if(node == p || node == q) return 1;            else return 0;        }        else return 2;    }    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        traversal(root, p, q);        return result;    }};</code></pre><p>题解：</p><p>主要是理清这张图的逻辑</p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/202102041512582.png" alt="236.二叉树的最近公共祖先2" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if (root == q || root == p || root == NULL) return root;        TreeNode* left = lowestCommonAncestor(root->left, p, q);        TreeNode* right = lowestCommonAncestor(root->right, p, q);        if (left != NULL && right != NULL) return root;        if (left == NULL && right != NULL) return right;        else if (left != NULL && right == NULL) return left;        else  { //  (left == NULL && right == NULL)            return NULL;        }    }};</code></pre><ol><li>求最小公共祖先，需要<strong>从底向上遍历</strong>，那么二叉树，只能通过<strong>后序遍历（</strong>即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">//后序遍历left = 递归函数(root->left);  // 左right = 递归函数(root->right); // 右left与right的逻辑处理;         // 中</code></pre><p>搜索一条边的写法（本题，下题）：</p><pre class=" language-lang-text"><code class="language-lang-text">if (递归函数(root->left)) return ;if (递归函数(root->right)) return ;</code></pre><p>搜索整个树写法：</p><pre class=" language-lang-text"><code class="language-lang-text">left = 递归函数(root->left);right = 递归函数(root->right);left与right的逻辑处理;</code></pre><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//对于二叉搜索树，从上向下去递归遍历，第一次遇到 cur节点是数值在[p, q]区间中，那么cur就是 p和q的最近公共祖先class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        while(root) {            if (root->val > p->val && root->val > q->val) {                root = root->left;            } else if (root->val < p->val && root->val < q->val) {                root = root->right;            } else return root;        }        return NULL;    }};</code></pre><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/insertbst-16777246991064.jpg" alt="img" style="zoom:50%;"></p><p>我的代码：</p><p>迭代法</p><p>找到空的就插入新节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* insertIntoBST(TreeNode* root, int val) {        TreeNode* node = root;         TreeNode* insert = new TreeNode(val);//注意新插入节点的创建方式        if(node == NULL) return insert;        while(node != NULL){            if(val > node->val) {                if(node->right) node = node->right;                else {                    node->right = insert;                    break;                }            }            if(val < node->val) {                if(node->left) node = node->left;                else {                    node->left = insert;                    break;                }            }        }        return root;    }};</code></pre><p>题解：</p><p>记录了父节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* insertIntoBST(TreeNode* root, int val) {        if (root == NULL) {            TreeNode* node = new TreeNode(val);            return node;        }        TreeNode* cur = root;        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点        while (cur != NULL) {            parent = cur;            if (cur->val > val) cur = cur->left;            else cur = cur->right;        }        TreeNode* node = new TreeNode(val);        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值        else parent->right = node;        return root;    }};</code></pre><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点*"></a>450.删除二叉搜索树中的节点*</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接(opens new window)</a></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p><p>思路：</p><ol><li><p>暴力：中序遍历后变成数组再处理</p></li><li><p><strong>分析各种可能的情况</strong></p><p> 有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为该节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为该节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为该节点。</li></ul></li></ul></li></ol><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* deleteNode(TreeNode* root, int key) {        if (root == nullptr) return nullptr; //1        if (root->val == key) {            if(root->left == nullptr && root->right == nullptr) return nullptr; //2            if(root->left == nullptr) return root->right; //3            if(root->right == nullptr) return root->left; //4            if(root->left != nullptr && root->right != nullptr){ //5                // 找右子树最左面的节点                TreeNode* cur = root->right;                 while(cur->left != nullptr) {                    cur = cur->left;                }                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置                root = root->right;                 return root;            }         }   //上面相当于把新的节点返回给上一层，上一层就要用 root->left 或者 root->right接住，代码如下：        if (root->val > key) root->left = deleteNode(root->left, key);        if (root->val < key) root->right = deleteNode(root->right, key);        return root;    }};</code></pre><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树*"></a>669. 修剪二叉搜索树*</h2><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">力扣题目链接</a></p><p><img src="/2023/03/11/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/trim2.jpg" alt="img" style="zoom:33%;"></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* trimBST(TreeNode* root, int low, int high) {        if (root == nullptr ) return nullptr;        if (root->val < low) {            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点            return right;        }        if (root->val > high) {            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点            return left;        }        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子        return root;    }};</code></pre><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>思路：</p><ol><li>选取数组中间的节点为根节点，分割数组为左右两部分</li><li>分别在两部分中间再找中间节点</li></ol><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    TreeNode* traversal(vector<int>& nums, int left, int right) {        if (left > right) return nullptr;        int mid = left + ((right - left) / 2); // 防止溢出         // 等价于int mid = (left + right) / 2;        TreeNode* root = new TreeNode(nums[mid]);        root->left = traversal(nums, left, mid - 1);        root->right = traversal(nums, mid + 1, right);        return root;    }public:    TreeNode* sortedArrayToBST(vector<int>& nums) {        TreeNode* root = traversal(nums, 0, nums.size() - 1);        return root;    }};</code></pre><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">力扣题目链接(opens new window)</a></p><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>思路：</p><p>右中左序遍历，需要记录前一个节点的数值</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    int pre = 0; // 记录前一个节点的数值    void traversal(TreeNode* cur) { // 右中左遍历        if (cur == NULL) return;        traversal(cur->right);        cur->val += pre;        pre = cur->val;        traversal(cur->left);    }public:    TreeNode* convertBST(TreeNode* root) {        pre = 0;        traversal(root);        return root;    }};</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二叉树理论基础篇&quot;&gt;&lt;a href=&quot;#二叉树理论基础篇&quot; class=&quot;headerlink&quot; title=&quot;#二叉树理论基础篇&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.programmercarl.com/二叉树理论基础.html#二叉树理论基础篇&quot;&gt;#&lt;/a&gt;二叉树理论基础篇&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树&lt;/strong&gt;，所以map、set的增删操作时间时间复杂度是logn&lt;/p&gt;
&lt;p&gt;unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表&lt;/p&gt;
&lt;p&gt;一棵树当中没有子结点（即度为0）的结点称为&lt;em&gt;叶子&lt;/em&gt;结点，简称“&lt;em&gt;叶子&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树主要有两种遍历方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深度优先遍历：先往深走，遇到叶子节点再往回走。&lt;/li&gt;
&lt;li&gt;广度优先遍历：一层一层的去遍历。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2023-02-09T12:55:49.833Z</published>
    <updated>2023-02-09T12:55:49.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>当我们需要<strong>查询一个元素是否出现过，或者一个元素是否在集合里的时候</strong>，就要第一时间想到哈希法。</p><p><strong>拉链法</strong></p><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235015226.png" alt="哈希表4"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p><strong>线性探测法</strong></p><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235109950.png" alt="哈希表5"></p><p>常见的哈希结构：数组、set（集合）、map（映射）</p><blockquote><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p></blockquote><p><strong>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</strong></p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，不过给我们的使用方式，还是哈希法的使用方式，即key和value。map同理。</p><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><blockquote><p>数组就是简单的哈希表，但是数组的大小可不是无限开辟的</p></blockquote><p>本题使用数组模拟哈希表，数组大小为26，元素值代表字母出现的次数</p><p><img src="/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/242.有效的字母异位词.gif" alt="242.有效的字母异位词"></p><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20200818193523911.png" alt="349. 两个数组的交集"></p><p>本题结果是无重复的，且没有限制数组的长度，且无需排序，因此使用<strong>unordered_set</strong></p><blockquote><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的长度。</strong>而这道题目没有限制数值的长度，就无法使用数组来做哈希表了。</p><p>（用vector代替数组是否能解决限制长度的问题）</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p></blockquote><p><a href="https://blog.csdn.net/qq_40286920/article/details/124731777">c++ unordered<em>set详细操作</em>好人好事代表nxx的博客-CSDN博客_unordered_set</a></p><p><strong>使用迭代器构造</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">unordered_set<int> set3(set1.begin(), set1.end());</code></pre><p><strong>find()函数——查找</strong><br>//查找2，找到返回迭代器，失败返回end()</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">set1.find(2);</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {        unordered_set<int> result_set;        unordered_set<int> nums_set(nums1.begin(),nums1.end());        for(int num:nums2){            if (nums_set.find(num) != nums_set.end()) {                result_set.insert(num);            }        }        return vector<int>(result_set.begin(), result_set.end()); //注意返回值类型    }};</code></pre><p>注：</p><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int getSum(int n){        int sum = 0;        //取数值各个位上的单数操作        while(n){            sum += (n % 10) * (n % 10); //不可使用^2表示平方            n = n/10;        }        return sum;    }    bool isHappy(int n) {        unordered_set<int> sums_set;        while(1){            int sum = getSum(n);            if(sum == 1) return true;            if(sums_set.find(sum) != sums_set.end()) return false;            sums_set.insert(sum);            n = sum;        }    }};</code></pre><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p><strong>思路：</strong></p><p>每次遍历时要看这个<strong>元素</strong>之前是否出现过–&gt;考虑用哈希</p><p>同时要存元素和下表两个值–&gt;用map–&gt;元素对应key，下标对应value</p><p><strong>题解：</strong></p><p><a href="https://blog.csdn.net/zyc2018/article/details/93591189">(73条消息) C++之auto的使用<em>Waldeinsamkeit</em>的博客-CSDN博客_auto iter</a></p><p><a href="https://blog.csdn.net/u010112268/article/details/81153034">(73条消息) C++中pair的用法_淼淼1111的博客-CSDN博客_pair</a></p><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        std::unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map.insert(pair<int, int>(nums[i], i));//可用此用法            }        }        return {};    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map[nums[i]]=i;  //可用此用法            }        }        return {};    }};</code></pre><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>思路：</strong></p><p>HashMap 存一个数组，如 A。然后计算三个数组之和，如 BCD。时间复杂度为：O(n)+O(n^3)，得到 O(n^3).<br>HashMap 存三个数组之和，如 ABC。然后计算一个数组，如 D。时间复杂度为：O(n^3)+O(n)，得到 O(n^3).<br>HashMap 存两个数组之和，如AB。然后计算两个数组之和，如 CD。时间复杂度为：O(n^2) + O(n^2)，得到 O(n^2).</p><p>要存a+b的所有可能，以及出现的次数</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {        std::unordered_map <int,int> map12;        int sum12;        int sum34;        int num=0;        for(int i = 0; i < nums1.size(); i++){            for(int j = 0; j < nums2.size(); j++){                map12[nums1[i]+nums2[j]]++;            }        }        for(int i = 0; i < nums3.size(); i++){            for(int j = 0; j < nums4.size(); j++){                sum34 = nums3[i]+nums4[j];                if(map12.find(-sum34) != map12.end()){                    num = num + map12[-sum34];                }            }        }        return num;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中        for (int a : A) {   // 注意这种特殊用法            for (int b : B) {                umap[a + b]++;            }        }        int count = 0; // 统计a+b+c+d = 0 出现的次数        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。        for (int c : C) {            for (int d : D) {                if (umap.find(0 - (c + d)) != umap.end()) {                    count += umap[0 - (c + d)];                }            }        }        return count;    }};</code></pre><p>后面大概还剩150道题</p><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        unordered_map <int,int> map;        for(int i = 0; i < magazine.size(); i++){            map[magazine[i]]++;        }        for(int i = 0; i < ransomNote.size(); i++){            if(map.find(ransomNote[i]) != map.end()){                if(map[ransomNote[i]]>0){                    map[ransomNote[i]]--;                }else{                    return false;                }            }else{                return false;            }        }        return true;    }};</code></pre><p><strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 时间复杂度: O(n)// 空间复杂度：O(1)class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int record[26] = {0};        //add        if (ransomNote.size() > magazine.size()) {            return false;        }        for (int i = 0; i < magazine.length(); i++) {            // 通过recode数据记录 magazine里各个字符出现次数            record[magazine[i]-'a'] ++;        }        for (int j = 0; j < ransomNote.length(); j++) {            // 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-'a']--;            // 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-'a'] < 0) {                return false;            }        }        return true;    }};</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中<strong>不可以包含重复</strong>的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p><strong>思考：</strong></p><p>哈希法C++代码:（此题不宜使用哈希法，去重比较复杂）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> result;        sort(nums.begin(), nums.end());        // 找出a + b + c = 0        // a = nums[i], b = nums[j], c = -(a + b)        for (int i = 0; i < nums.size(); i++) {            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组            if (nums[i] > 0) {                break;            }            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重                continue;            }            unordered_set<int> set;            for (int j = i + 1; j < nums.size(); j++) {                if (j > i + 2                        && nums[j] == nums[j-1]                        && nums[j-1] == nums[j-2]) { // 三元组元素b去重                    continue;                }                int c = 0 - (nums[i] + nums[j]);                if (set.find(c) != set.end()) {                    result.push_back({nums[i], nums[j], c});                    set.erase(c);// 三元组元素c去重                } else {                    set.insert(nums[j]);                }            }        }        return result;    }};</code></pre><p>使用双指针法更高效：</p><p><img src="/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/15.三数之和.gif" alt="15.三数之和"></p><p>遇事不决先排序，两边逼近双指针</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int i = 0; i < nums.size(); i++){            if(nums[i] > 0) break;            //a去重            if(i>0 && nums[i] == nums[i-1]) continue;            //定义双指针            int left = i + 1;            int right = nums.size() - 1;            while(right > left){                int sum = nums[i]+nums[left]+nums[right];                if(sum > 0) right--;                else if(sum <0) left++;                else{                    results.push_back(vector<int>{nums[i],nums[left],nums[right]});                    //去重                    while (right > left && nums[right] == nums[right - 1]) right--;                    while (right > left && nums[left] == nums[left + 1]) left++;                    right--;                    left++;                }            }        }        return results;    }};</code></pre><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接(opens new window)</a></p><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> fourSum(vector<int>& nums, int target) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int j = 0; j < nums.size(); j++){            if(j>0 && nums[j] == nums[j-1]) continue;            for(int i = j + 1; i < nums.size(); i++){                //a去重                if(i>j+1 && nums[i] == nums[i-1]) continue;                //定义双指针                int left = i + 1;                int right = nums.size() - 1;                while(right > left){                    //此处需要强制转换为long，否则会溢出                    long sum =(long) nums[j]+nums[i]+nums[left]+nums[right];                    if(sum > target) right--;                    else if(sum <target) left++;                    else{                        results.push_back(vector<int>{nums[j],nums[i],nums[left],nums[right]});                        //去重                        while (right > left && nums[right] == nums[right - 1]) right--;                        while (right > left && nums[left] == nums[left + 1]) left++;                        right--;                        left++;                    }                }            }        }        return results;    }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在两数之和中map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>map是一种<code>&lt;key, value&gt;</code>的结构，两数之和可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哈希表理论基础&quot;&gt;&lt;a href=&quot;#哈希表理论基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表理论基础&quot;&gt;&lt;/a&gt;哈希表理论基础&lt;/h2&gt;&lt;p&gt;哈希表是根据关键码的值而直接进行访问的数据结构。&lt;/p&gt;
&lt;p&gt;当我们需要&lt;strong&gt;查询一个元素是否出现过，或者一个元素是否在集合里的时候&lt;/strong&gt;，就要第一时间想到哈希法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拉链法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/02/09/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235015226.png&quot; alt=&quot;哈希表4&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
