<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>young&#39;s blog</title>
  
  <subtitle>慢慢来，比较快</subtitle>
  <link href="https://youngyyp.github.io/atom.xml" rel="self"/>
  
  <link href="https://youngyyp.github.io/"/>
  <updated>2023-06-26T14:20:26.514Z</updated>
  <id>https://youngyyp.github.io/</id>
  
  <author>
    <name>young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://youngyyp.github.io/2023/06/26/work/%E7%AE%80%E5%8E%86%E4%BC%98%E5%8C%96/"/>
    <id>https://youngyyp.github.io/2023/06/26/work/%E7%AE%80%E5%8E%86%E4%BC%98%E5%8C%96/</id>
    <published>2023-06-26T14:14:08.930Z</published>
    <updated>2023-06-26T14:20:26.514Z</updated>
    
    <content type="html"><![CDATA[<p>可按照备受HR推崇的<strong>STAR原则</strong>来写：</p><p><strong>Situation:</strong> 事情是在什么情况下发生的</p><p><strong>Task:</strong> 你是如何明确你的任务的</p><p><strong>Action:</strong> 针对这样的情况分析，你采用了什么行动方式</p><p><strong>Result:</strong> 结果怎样，在这样的情况下你学习到了什么</p><p>每个项目按背景、难点、方法、成果来写。</p>]]></content>
    
    
    <summary type="html">可按照备受HR推崇的STAR原则来写：

Situation: 事情是在什么情况下发生的

Task: 你是如何明确你的任务的

Action: 针对这样的情况分析，你采用了什么行动方式

Result: 结果怎样，在这样的情况下你学习到了什么

每个项目按背景、难点、方法、成果来写。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://youngyyp.github.io/2023/04/27/cpp/%E5%9B%BE/"/>
    <id>https://youngyyp.github.io/2023/04/27/cpp/%E5%9B%BE/</id>
    <published>2023-04-27T02:13:33.000Z</published>
    <updated>2023-05-30T13:04:35.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><p><img src="/2023/04/27/cpp/%E5%9B%BE/2.jpeg" alt="img" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// graph[x] 存储 x 的所有邻居节点vector<int> graph[];  //其实也相当于vector<vector<int>> graph;// 邻接矩阵// matrix[x][y] 记录 x 是否有一条指向 y 的边bool matrix[][];</code></pre><p><strong>度</strong>（degree）：</p><p>无向图中，「度」就是每个节点相连的边的条数。</p><p>由于有向图的边有方向，所以有向图中每个节点「度」被细分为<strong>入度</strong>（indegree）和<strong>出度</strong>（outdegree）</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/0.jpg" alt="img" style="zoom:50%;"></p><p>其中节点 <code>3</code> 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 记录遍历过的节点vector<bool> visited;// 记录从起点到当前节点的路径vector<bool> onPath;/* 图遍历框架 */void traverse(Graph graph, int s) {    if (visited[s]) return;    // 经过节点 s，标记为已遍历    visited[s] = true;    // 做选择：标记节点 s 在路径上    onPath[s] = true;    for (int neighbor : graph.neighbors(s)) {        traverse(graph, neighbor);    }    // 撤销选择：节点 s 离开路径    onPath[s] = false;}</code></pre><h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h2><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797. 所有可能的路径 - 力扣（Leetcode）</a></p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 j  <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="/2023/04/27/cpp/%E5%9B%BE/all_1.jpg" alt="img" style="zoom:50%;"></p><pre><code>输入：graph = [[1,2],[3],[3],[]]输出：[[0,1,3],[0,2,3]]解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void dfs(vector<vector<int>>& graph, int x){        if(x == graph.size() - 1) { // 如果不能走到终点就不用做处理            result.push_back(path);            return;        }        for(int i : graph[x]){            path.push_back(i);            dfs(graph, i);            path.pop_back();        }    }public:    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {        //注意dfs和回溯的区别，dfs需要加入根节点到路径中        path.push_back(0);        dfs(graph, 0);        return result;    }};</code></pre><h2 id="207-课程表——环检测-DFS）"><a href="#207-课程表——环检测-DFS）" class="headerlink" title="207. 课程表——环检测(DFS）"></a>207. 课程表——环检测(DFS）</h2><p><a href="https://leetcode.cn/problems/course-schedule/description/">207. 课程表 - 力扣（Leetcode）</a></p><p><strong>示例 1：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    // 记录一次 traverse 递归经过的节点    vector<bool> onPath;    // 记录遍历过的节点，防止走回头路    vector<bool> visited;// 如果有节点在之前的轮次中被遍历过了，证明这个节点不存在环了，跟这个节点相连的节点已经被检查过了，可以节省时间    // 记录图中是否有环    bool hasCycle = false;    void traverse(vector<vector<int>>& graph, int s) {        if (onPath[s]) {            // 出现环            hasCycle = true;        }        if (visited[s] || hasCycle) {            // 如果已经找到了环，也不用再遍历了            return;        }        //前序遍历位置        visited[s] = true; // 没有回溯！！！表示这条路上的节点已经都被检查过了        onPath[s] = true;        for (int t : graph[s]) {            traverse(graph, t);        }        //后序遍历位置        onPath[s] = false;    }public:    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {        // 首先将输入转换为邻接表        vector<vector<int>> graph(numCourses);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);        }        visited.resize(numCourses, false);//初始化！        onPath.resize(numCourses, false);        for (int i = 0; i < numCourses; i++) {            // 遍历图中的所有节点            traverse(graph, i);        }        // 只要没有循环依赖可以完成所有课程        return !hasCycle;    }};</code></pre><h2 id="210-课程表-II-——-拓扑排序-DFS"><a href="#210-课程表-II-——-拓扑排序-DFS" class="headerlink" title="210. 课程表 II —— 拓扑排序(DFS)"></a>210. 课程表 II —— 拓扑排序(DFS)</h2><p><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II - 力扣（Leetcode）</a></p><p>这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。</p><p>拓扑排序示意（C7-&gt;C8-&gt;C6<code>应该改为</code>C6-&gt;C7-&gt;C8）：</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/image-20230428094601419.png" alt="image-20230428094601419" style="zoom:50%;"></p><p><strong>直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的</strong>，比如上图所有箭头都是朝右的。</p><p>如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「<strong>有向无环图</strong>」，那么一定可以进行拓扑排序</p><p>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的<strong>拓扑排序</strong>结果就是上课顺序</p><p>将<strong>后序遍历</strong>的结果进行<strong>反转</strong>，就是拓扑排序的结果。—— <strong>逆后序遍历</strong></p><p>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行。</p><p>用树来做类比如下：</p><p><img src="/2023/04/27/cpp/%E5%9B%BE/image-20230428101621512.png" alt="image-20230428101621512" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dfs逆后序遍历class Solution {private:    // 记录一次 traverse 递归经过的节点    vector<bool> onPath;    // 记录遍历过的节点，防止走回头路    vector<bool> visited;// 如果有节点在之前的轮次中被遍历过了，证明这个节点不存在环了，跟这个节点相连的节点已经被检查过了，可以节省时间    // 记录图中是否有环    bool hasCycle = false;    vector<int> postorder;    void traverse(vector<vector<int>>& graph, int s) {        if (onPath[s]) {            // 出现环            hasCycle = true;        }        if (visited[s] || hasCycle) {            // 如果已经找到了环，也不用再遍历了            return;        }        //前序遍历位置        visited[s] = true; // 没有回溯！！！表示这条路上的节点已经都被检查过了        onPath[s] = true;        for (int t : graph[s]) {            traverse(graph, t);        }        //后序遍历位置        onPath[s] = false;        postorder.push_back(s);    }public:    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {        // 首先将输入转换为邻接表        vector<vector<int>> graph(numCourses);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);        }        visited.resize(numCourses, false);//初始化！        onPath.resize(numCourses, false);        for (int i = 0; i < numCourses; i++) {            // 遍历图中的所有节点            traverse(graph, i);        }        // 只要没有循环依赖可以完成所有课程        if(hasCycle) return {};        reverse(postorder.begin(), postorder.end());        return postorder;    }};</code></pre><h2 id="BFS算法——宽度优先搜索"><a href="#BFS算法——宽度优先搜索" class="headerlink" title="BFS算法——宽度优先搜索"></a>BFS算法——宽度优先搜索</h2><p>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多</strong></p><p>BFS 的核心思想：就是把一些问题抽象成图，从一个点开始，向四周开始扩散</p><p>写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列</p><p>BFS使用场景：一幅「图」，让你从一个起点，走到终点，问最短路径</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 计算从起点 start 到终点 target 的最近距离int BFS(Node start, Node target) {    queue<Node> q; // 核心数据结构    unordered_set<Node> visited; // 避免走回头路    q.push(start); // 将起点加入队列    visited.insert(start);    int step = 0; // 记录扩散的步数    while (!q.empty()) {        int sz = q.size();        /* 将当前队列中的所有节点向四周扩散 */        for (int i = 0; i < sz; i++) {            Node cur = q.front();            q.pop();            /* 划重点：这里判断是否到达终点 */            if (cur == target)                return step;            /* 将 cur 的相邻节点加入队列 */            for (Node x : cur.adj()) {                if (visited.count(x) == 0) {                    q.push(x);                    visited.insert(x);                }            }        }        /* 划重点：更新步数在这里 */        step++;    }}</code></pre><h2 id="环检测算法（BFS-版本）—课程表题目优先用bfs"><a href="#环检测算法（BFS-版本）—课程表题目优先用bfs" class="headerlink" title="环检测算法（BFS 版本）—课程表题目优先用bfs"></a>环检测算法（BFS 版本）—课程表题目优先用bfs</h2><p><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/">环检测及拓扑排序算法 :: labuladong的算法小抄</a></p><p>BFS 算法借助 <code>indegree</code> 数组记录每个节点的「入度」，也可以实现【课程表】算法</p><p>思路：</p><p>1、构建邻接表，和之前一样，边的方向表示「被依赖」关系。</p><p>2、构建一个 <code>indegree</code> 数组记录每个节点的入度，即 <code>indegree[i]</code> 记录节点 <code>i</code> 的入度。</p><p>3、对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。</p><p><strong>4、开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列</strong>。</p><p><strong>5、如果最终所有节点都被遍历过（<code>count</code> 等于节点数），则说明不存在环，反之则说明存在环</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {        // 建立邻接表和入度表        vector<vector<int>> graph(numCourses);        vector<int> indegree(numCourses, 0);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);            indegree[pre[0]]++;        }        // 将入度为 0 的节点首先装入队列        queue<int> que;        for(int i = 0; i < numCourses; i++){            if(indegree[i] == 0){                que.push(i);            }        }        // 减少相邻节点的入度，并将入度变为 0 的节点加入队列        int count = 0;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                int node = que.front();                que.pop();                count++;                for(auto child : graph[node]){                    indegree[child]--;                    if(indegree[child] == 0){                        que.push(child);                    }                }            }        }        return count == numCourses;    }};</code></pre><h2 id="拓扑排序算法（BFS-版本）"><a href="#拓扑排序算法（BFS-版本）" class="headerlink" title="拓扑排序算法（BFS 版本）"></a>拓扑排序算法（BFS 版本）</h2><p>如果你能看懂 BFS 版本的环检测算法，那么就很容易得到 BFS 版本的拓扑排序算法，因为<strong>节点的遍历顺序就是拓扑排序</strong>的结果。</p><p>稍微修改一下 BFS 版本的环检测算法，记录节点的遍历顺序即可得到拓扑排序的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {       // 建立邻接表和入度表        vector<vector<int>> graph(numCourses);        vector<int> indegree(numCourses, 0);        for(auto pre : prerequisites){            graph[pre[1]].push_back(pre[0]);            indegree[pre[0]]++;        }        // 将入度为 0 的节点首先装入队列        queue<int> que;        for(int i = 0; i < numCourses; i++){            if(indegree[i] == 0){                que.push(i);            }        }        // 减少相邻节点的入度，并将入度变为 0 的节点加入队列        int count = 0;        vector<int> res; // 记录遍历顺序        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                int node = que.front();                que.pop();                res.push_back(node);                count++;                for(auto child : graph[node]){                    indegree[child]--;                    if(indegree[child] == 0){                        que.push(child);                    }                }            }        }        if(count == numCourses){            return res;        }else return {};     }};</code></pre>]]></content>
    
    
    <summary type="html">图论基础


// graph[x] 存储 x 的所有邻居节点
vector&lt;int&gt; graph[];  //其实也相当于vector&lt;vector&lt;int&gt;&amp;gt; graph;

// 邻接矩阵
// matrix[x][y] 记录 x 是否有一条指向 y 的边
bool matrix[][];


度（degree）：

无向图中，「度」就是每个节点相连的边的条数。

由于有向图的边有方向，所以有向图中每个节点「度」被细分为入度（indegree）和出度（outdegree）



其中节点 3 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。

// 记录遍历过的&lt;/vector&lt;int&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>ACM模式</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/ACM%E6%A8%A1%E5%BC%8F/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/ACM%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-04-13T06:09:42.703Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qwe641259875/article/details/117031847">(79条消息) clion mac 下刷题最佳配置<em>clion 刷题模板</em>菜饼同学的博客-CSDN博客</a></p><p>单文件编译<a href="https://plugins.jetbrains.com/plugin/8352-c-c--single-file-execution">C/C++ Single File Execution - CLion Plugin | Marketplace (jetbrains.com)</a></p><h1 id="include-：-万能头文件＜bits-stdc-h＞"><a href="#include-：-万能头文件＜bits-stdc-h＞" class="headerlink" title="include   ： 万能头文件＜bits/stdc++.h＞"></a>include <bits stdc++.h>  ： 万能头文件<strong>＜bits/stdc++.h＞</strong></bits></h1><p><a href="https://blog.csdn.net/hehehe326/article/details/123954338">(79条消息) C++ 输入输出函数总结及 OJ 在线编程常见输入输出练习<em>c++ oj 输入</em>吃烧鸭的博客-CSDN博客</a></p><h1 id="C-输入"><a href="#C-输入" class="headerlink" title="C++ 输入"></a>C++ 输入</h1><h2 id="std-operator-gt-gt"><a href="#std-operator-gt-gt" class="headerlink" title="std::operator>>"></a>std::operator&gt;&gt;</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <string>istream& operator>> (istream& is, string& str);123</code></pre><ul><li>遇到空格（回车等）停止，但<strong>不会</strong>从输入中读取并丢弃空格；</li><li>连续使用 cin 时，会自动跳过前导空格（回车等）；</li></ul><h2 id="std-getline"><a href="#std-getline" class="headerlink" title="std::getline"></a>std::getline</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <string>istream& getline (istream&  is, string& str, char delim);istream& getline (istream&  is, string& str); // default delim '\n'123</code></pre><ul><li>遇到 delim 则停止读取，从输入缓冲<strong>读取并丢弃 delim</strong>；</li><li>delim 不会写入 str，且下一个输入操作将从 delim 下一位开始；</li></ul><h2 id="std-istream-getline"><a href="#std-istream-getline" class="headerlink" title="std::istream::getline"></a>std::<a href="https://so.csdn.net/so/search?q=istream&amp;spm=1001.2101.3001.7020">istream</a>::getline</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>istream& getline (char* s, streamsize n );  // default delim '\n'istream& getline (char* s, streamsize n, char delim );123</code></pre><ul><li>遇到 delim 或已经读入 n-1 个有效字符则停止，函数会在 s 尾部自动添加终止空字符<code>'\0'</code>；</li><li>从输入缓冲<strong>读取 delim 并丢弃</strong>，不会写入字符串 s 中；</li></ul><h2 id="std-istream-get"><a href="#std-istream-get" class="headerlink" title="std::istream::get"></a>std::istream::get</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>int peek(); // no extractingint get();  // extractistream& get (char& c);istream& get (char* s, streamsize n); // default delim '\n'istream& get (char* s, streamsize n, char delim);123456</code></pre><ul><li>读入 n-1 个有效字符 或 遇到 delim 则停止，且 delim <strong>不会</strong>被读入并丢弃；</li><li>空字符 <code>'\0'</code> 自动添加到 s 末尾；</li></ul><h2 id="std-istream-ignore"><a href="#std-istream-ignore" class="headerlink" title="std::istream::ignore"></a>std::istream::ignore</h2><pre class=" language-lang-cpp"><code class="language-lang-cpp">istream& ignore (streamsize n = 1, int delim = EOF);1</code></pre><ul><li>从输入序列中读取并丢弃字符，直到丢弃共计 n 个字符或遇到 delim；</li><li>delim 会被<strong>读取并丢弃</strong>；</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>大部分函数都会返回输入流的引用 <code>istream&amp;</code>，因此可以用于条件判断输入有效性，或连续输入；</li></ul><h1 id="牛客-OJ-输入输出练习"><a href="#牛客-OJ-输入输出练习" class="headerlink" title="牛客 OJ 输入输出练习"></a>牛客 <a href="https://so.csdn.net/so/search?q=OJ&amp;spm=1001.2101.3001.7020">OJ</a> 输入输出练习</h1><h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h2><p>输入描述:<br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 1000),输入数据包括多组。<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int a, b;    while(cin >> a >> b)        cout << a + b << endl;    return 0;}123456789</code></pre><h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h2><p>输入描述:<br>输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)<br>接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 1000)<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int t;    int a, b;    cin >> t;    while(t--){        cin >> a >> b;        cout << a + b << endl;    }    return 0;}12345678910111213</code></pre><h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h2><p>输入描述:<br>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入<br>输出描述:<br>输出a+b的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int a, b;    while(cin >> a >> b){        if(a == 0 && b == 0)            break ;        cout << a + b << endl;    }    return 0;}123456789101112</code></pre><h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h2><p>输入描述:<br>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int n, num;    int sum = 0;    while(cin >> n && n != 0){        while(n--){            cin >> num;            sum += num;        }        cout << sum << endl;        sum = 0;//注意输出后初始化结果    }    return 0;}12345678910111213141516</code></pre><h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B(5)"></a>A+B(5)</h2><p>输入描述:<br>输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    int lines, n, num;    int sum;    cin >> lines;    while (cin >> n) {        sum = 0;        while (n--) {            cin >> num;            sum += num;        }        cout << sum << endl;    }    return 0;}1234567891011121314151617</code></pre><h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h2><p>输入描述:<br>输入数据有多组, 每行表示一组输入数据。<br>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。<br>输出描述:<br>每组数据输出求和的结果</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// F1#include <iostream>using namespace std;int main() {    int sum, num;    while (cin >> num) {        sum += num;        if (cin.get() == '\n') { // 提取空格或行尾回车            cout << sum << endl;            sum = 0;        }    }    return 0;}// F2#include <iostream>#include <sstream>using namespace std;int main() {    int sum, num;    string line;    while (getline(cin, line)) {        istringstream iss(line);        while (iss >> num)            sum += num;        cout << sum << endl;        sum = 0;    }    return 0;}</code></pre><h2 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a><a href="https://so.csdn.net/so/search?q=字符串排序&amp;spm=1001.2101.3001.7020">字符串排序</a>(1)</h2><p>输入描述:<br>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开<br>输出描述:<br>输出一行排序后的字符串，空格隔开，无结尾空格</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <string>#include <vector>#include <algorithm>using namespace std;int main() {    int n;    cin >> n;    vector<string> vec(n);    while(n--) cin >> vec[n];    sort(vec.begin(), vec.end());    for (string& str : vec)        cout << str << " ";    return 0;}1234567891011121314151617</code></pre><h2 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h2><p>输入描述:<br>多个测试用例，每个测试用例一行。<br>每行通过空格隔开，有n个字符，n＜100<br>输出描述:<br>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <vector>#include <string>#include <algorithm>using namespace std;int main(){    vector<string> vec;    string tmp;    while (cin >> tmp) {        vec.push_back(tmp);        if (cin.get() == '\n'){            sort(vec.begin(), vec.end());            for (string& str : vec)                cout << str << " ";            cout << endl;            vec.clear();        }    }    return 0;}12345678910111213141516171819202122</code></pre><h2 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h2><p>输入描述:<br>多个测试用例，每个测试用例一行。<br>每行通过,隔开，有n个字符，n＜100<br>输出描述:<br>对于每组用例输出一行排序后的字符串，用’,’隔开，无结尾空格</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>#include <sstream>#include <vector>#include <string>#include <algorithm>using namespace std;int main(){    vector<string> vec;    string str;    while (getline(cin, str)) { // 解决 '\n'        istringstream iss(str);        while (getline(iss, str, ',')) // 按 ',' 分割            vec.push_back(str);        sort(vec.begin(), vec.end());        for (int i = 0; i < vec.size() - 1; ++i)            cout << vec[i] << ",";        cout << vec.back() << endl;        vec.clear();    }    return 0;}1234567891011121314151617181920212223</code></pre><h2 id="自测本地通过提交为0"><a href="#自测本地通过提交为0" class="headerlink" title="自测本地通过提交为0"></a>自测本地通过提交为0</h2><p>数据范围：0 &lt; a , b &lt; 2 × 1 0 10 0 &lt; a,b &lt; 2 \times 10^{10}0&lt;a,b&lt;2×1010<br>输入描述:<br>输入有多组测试用例，每组空格隔开两个整数<br>输出描述:<br>对于每组数据输出一行两个整数的和；</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">#include <iostream>using namespace std;int main(){    long long a, b;  // 需注意数据范围，样例通过不代表所有测试数据通过；    while (cin >> a >> b)        cout << a + b << endl;    return 0;}</code></pre><p><a href="https://blog.csdn.net/qq_46046431/article/details/129266738">(79条消息) ACM模式输入输出攻略 | C++篇<em>acm模式c++输入输出</em>小黛的求职笔记的博客-CSDN博客</a></p><pre class=" language-lang-CPP"><code class="language-lang-CPP">// 链表定义，并给出两个有参构造函数struct ListNode{    int val;    ListNode* next;    ListNode(int _val):val(_val),next(nullptr){}    ListNode(int _val,ListNode* _next):val(_val),next(_next){}};</code></pre><pre class=" language-lang-CPP"><code class="language-lang-CPP">//定义树节点struct TreeNode{    int val;    TreeNode* left;    TreeNode* right;    TreeNode():val(0),left(nullptr),right(nullptr){}    TreeNode(int _val):val(_val),left(nullptr),right(nullptr){}    TreeNode(int _val,TreeNode* _left,TreeNode* _right):val(0),left(_left),right(_right){}};</code></pre>]]></content>
    
    
    <summary type="html">(79条消息) clion mac 下刷题最佳配置clion 刷题模板菜饼同学的博客-CSDN博客

单文件编译C/C++ Single File Execution - CLion Plugin | Marketplace (jetbrains.com)

include ： 万能头文件＜bits/stdc++.h＞
(79条消息) C++ 输入输出函数总结及 OJ 在线编程常见输入输出练习c++ oj 输入吃烧鸭的博客-CSDN博客

C++ 输入
std::operator&amp;gt;&amp;gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
istream&amp;amp; operator&lt;/string&gt;&lt;/iostream&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-04-13T06:09:42.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单调栈基础"><a href="#单调栈基础" class="headerlink" title="单调栈基础"></a>单调栈基础</h2><h4 id="什么时候用单调栈："><a href="#什么时候用单调栈：" class="headerlink" title="什么时候用单调栈："></a>什么时候用单调栈：</h4><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p>关于单调栈的顺序给大家一个总结： <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>中求一个元素右边第一个更大元素，单调栈就是递增的，<a href="https://programmercarl.com/0084.柱状图中最大的矩形.html">84.柱状图中最大的矩形 (opens new window)</a>求一个元素右边第一个更小元素，单调栈就是递减的。</p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">力扣题目链接(opens new window)</a></p><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接temperatures[i]就可以获取。class Solution {public:    vector<int> dailyTemperatures(vector<int>& temperatures) {        stack<int> st;        vector<int> result(temperatures.size(), 0);        st.push(0);        for(int i = 1; i < temperatures.size(); i++){            if(temperatures[i] <= temperatures[st.top()]) st.push(i);            else {                // 注意这里的非空判断条件要放到&&前面，会优先判断是否空                while(!st.empty() && temperatures[i] > temperatures[st.top()]){                    result[st.top()] = i - st.top();                     st.pop();                }                st.push(i);            }        }        return result;    }};</code></pre><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/">力扣题目链接(opens new window)</a></p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {        stack<int> st;        vector<int> result(nums1.size(), -1);        if (nums1.size() == 0) return result;        unordered_map<int, int> umap; // key:元素值，value：下标        for (int i = 0; i < nums1.size(); i++) {            umap[nums1[i]] = i;        }        st.push(0);        for (int i = 1; i < nums2.size(); i++) {            if (nums2[i] < nums2[st.top()]) {           // 情况一                st.push(i);            } else if (nums2[i] == nums2[st.top()]) {   // 情况二                st.push(i);            } else {                                    // 情况三                while (!st.empty() && nums2[i] > nums2[st.top()]) {                    if (umap.find(nums2[st.top()]) != umap.end()) { // 看map里是否存在这个元素                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标                        result[index] = nums2[i];                    }                    st.pop();                }                st.push(i);            }        }        return result;    }};</code></pre><h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a>503.下一个更大元素II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">力扣题目链接(opens new window)</a></p><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><ul><li>输入: [1,2,1]</li><li>输出: [2,-1,2]</li><li>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> nextGreaterElements(vector<int>& nums) {        vector<int> result(nums.size(), -1);        if (nums.size() == 0) return result;        stack<int> st;        for (int i = 0; i < nums.size() * 2; i++) {            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作            // 这里对三种情况进行了合并            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {                result[st.top()] = nums[i % nums.size()];                st.pop();            }            st.push(i % nums.size());        }        return result;    }};</code></pre><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/">力扣题目链接(opens new window)</a></p><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/20210713205038.png" alt="img"></p><ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单调栈是按照行方向来计算雨水class Solution {public:    int trap(vector<int>& height) {        stack<int> st;        st.push(0);        int result = 0;        for(int i = 0; i < height.size(); i++){            while(!st.empty() && height[i] > height[st.top()]){                int mid = st.top();                st.pop();                if(!st.empty()){                    int h = min(height[i], height[st.top()]) - height[mid];                    int w = i - st.top() - 1;                    result += h*w;                }            }            st.push(i);        }        return result;    }};</code></pre><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">力扣题目链接(opens new window)</a></p><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/20210803220437.png" alt="img"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 找右边第一个比当前值小的class Solution {public:    int largestRectangleArea(vector<int>& heights) {        int result = 0;        stack<int> st;        heights.insert(heights.begin(), 0); // 数组头部加入元素0        heights.push_back(0); // 数组尾部加入元素0        st.push(0);        // 第一个元素已经入栈，从下标1开始        for (int i = 1; i < heights.size(); i++) {            if (heights[i] > heights[st.top()]) { // 情况一                st.push(i);            } else if (heights[i] == heights[st.top()]) { // 情况二                st.pop(); // 这个可以加，可以不加，效果一样，思路不同                st.push(i);            } else { // 情况三                while (!st.empty() && heights[i] < heights[st.top()]) { // 注意是while                    int mid = st.top();                    st.pop();                    if (!st.empty()) {                        int left = st.top();                        int right = i;                        int w = right - left - 1;                        int h = heights[mid];                        result = max(result, w * h);                    }                }                st.push(i);            }        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">单调栈基础
什么时候用单调栈：
通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。

单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

关于单调栈的顺序给大家一个总结： 739. 每日温度 (opens new window)中求一个元素右边第一个更大元素，单调栈就是递增的，84.柱状图中最大的矩形 (opens new window)求一个元素右边第一个更小元素，单调栈就是递减的。

739. 每日温度
力扣题目链接(opens ne</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://youngyyp.github.io/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/"/>
    <id>https://youngyyp.github.io/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-06-25T15:05:28.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. 数组中重复的数字</h2><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3</code></pre><p><strong>我的（hash）：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        // hash        vector<int> hash(nums.size(),0);        for(int i = 0; i < nums.size(); i++){            if(hash[nums[i]] == 0) hash[nums[i]]++;            else return nums[i];        }        return 0;    }};</code></pre><p>法二（原地交换）：</p><p>题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/1618146573-bOieFQ-Picture0.png" alt="Picture0.png" style="zoom:50%;"></p><p>遍历中，第一次遇到数字 x时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x]=x ，此时即可得到一组重复数字。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findRepeatNumber(vector<int>& nums) {        int i = 0;        while(i < nums.size()) {            if(nums[i] == i) {                i++;                continue;            }            if(nums[nums[i]] == nums[i])                return nums[i];            swap(nums[i],nums[nums[i]]);        }        return -1;    }};</code></pre><p>想了一个比较好理解方法2方式</p><p>这个原地交换法就相当于分配工作，每个索引代表一个工作岗位，每个岗位必须专业对口，既0索引必须0元素才能上岗。而我们的目的就是找出溢出的人才，既0索引岗位有多个0元素竞争。</p><p>我们先从0索引岗位开始遍历，首先我们看0索引是不是已经专业对口了，如果已经专业对口既nums[0]=0，那我们就跳过0岗位看1岗位。如果0索引没有专业对口，那么我们看现在0索引上的人才调整到他对应的岗位上，比如num[0]=2，那我们就把2这个元素挪到他对应的岗位上既num[2]，这个时候有两种情况:1、num[2]岗位上已经有专业对口的人才了，既num[2]=2，这就说明刚刚那个在num[0]上的2是溢出的人才，我们直接将其返回即可。2、num[2]上的不是专业对口的人才，那我们将num[0]上的元素和num[2]上的元素交换，这样num[2]就找到专业对口的人才了。之后重复这个过程直到帮num[0]找到专业对口的人才，然后以此类推帮num[1]找人才、帮num[2]找人才，直到找到溢出的人才。</p><h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h2><p>在一个 n <em> m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <em>*非递减</em></em> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><pre><code>[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>代码：</strong></p><p>如果真从左上角开始的话，就会发现无论向右还是向下走，元素大小都会增加，那么到底向右还是向下？不确定，那只好用类似 <a href="https://labuladong.github.io/article/fname.html?fname=动态规划详解进阶">动态规划算法</a> 的思路穷举了。</p><p>但实际上不用这么麻烦，我们不要从左上角开始，而是<strong>从右上角开始</strong>，规定只能向左或向下移动。</p><p>如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和 <code>target</code> 的相对大小来判断应该往哪移动，不断接近从而找到 <code>target</code> 的位置。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {        int n = matrix.size();        if(n == 0) return false; //防止输入[]        int m = matrix[0].size();        int i = 0;        int j = m - 1;        while(i < n && j >= 0){            if(matrix[i][j] < target){                i++;            }else if(matrix[i][j] > target){                j--;            }else return true;        }        return false;    }};</code></pre><h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = "We are happy."输出："We%20are%20happy."</code></pre><p>另外开辟一个字符串来存，空间复杂度O(n)：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        string result;        for(auto c:s){            if(c == ' ') result += "%20";            else result += c;        }        return result;    }};</code></pre><p>双指针，优化空间复杂度：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        int length = s.size();        for(int i = 0; i < s.size(); i++){            if(s[i] == ' '){                length = length + 2;            }        }        int left = s.size() - 1;        int right = length - 1;        s.resize(length);        while(left >= 0){            if(s[left] == ' '){                s[right] = '0';                s[right-1] = '2';                s[right-2] = '%';                right = right - 3;            }else{                s[right] = s[left];                right--;             }            left--;        }        return s;    }};</code></pre><h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p>栈：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> reversePrint(ListNode* head) {        stack<int> s;        vector<int> result;        while(head){            s.push(head->val);            head = head->next;        }        while(!s.empty()){            result.push_back(s.top());            s.pop();        }        return result;    }};</code></pre><p>双指针 翻转链表：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> reversePrint(ListNode* head) {        ListNode* temp;        ListNode* cur = head;        ListNode* pre = NULL;        while(cur){            temp = cur->next;            cur->next = pre;             pre = cur;             cur = temp;        }        vector<int> r;        while(pre){            r.push_back(pre->val);            pre = pre->next;        }        return  r;    }   };</code></pre><h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树*"></a>07. 重建二叉树*</h2><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/tree.jpg" alt="img"></p><pre><code>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    unordered_map<int, int> index;public:    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {        if (preorder_left > preorder_right) {            return nullptr;        }        // 前序遍历中的第一个节点就是根节点        int preorder_root = preorder_left;        // 在中序遍历中定位根节点        int inorder_root = index[preorder[preorder_root]];        // 先把根节点建立出来        TreeNode* root = new TreeNode(preorder[preorder_root]);        // 得到左子树中的节点数目        int size_left_subtree = inorder_root - inorder_left;        // 递归地构造左子树，并连接到根节点        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);        // 递归地构造右子树，并连接到根节点        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);        return root;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        int n = preorder.size();        // 构造哈希映射，帮助我们快速定位根节点        for (int i = 0; i < n; ++i) {            index[inorder[i]] = i;        }        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);    }};作者：力扣官方题解链接：https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solutions/103063/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> preorder;    unordered_map<int, int> map;    TreeNode* traversal(int root, int left, int right){        if(left > right) return nullptr;        // root为前序根节点的位置，left为中序的左边界位置，right为中序的右边界位置        TreeNode* node = new TreeNode(preorder[root]);        int i = map[preorder[root]];        node->left = traversal(root + 1, left, i - 1);        node->right = traversal(root + (i - left) + 1, i + 1, right);        return node;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        int n = preorder.size();        this->preorder = preorder;        for(int i = 0; i < n; i++){            map[inorder[i]] = i;        }        return traversal(0, 0, n-1);    }};作者：Krahets链接：https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solutions/100091/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/</code></pre><pre><code>root + (i - left) + 1 含义为  根节点索引 + 左子树长度 + 1</code></pre><p><strong>切片方法</strong> 这个方法最直接：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 切片的方式    TreeNode* traversal(vector<int> preorder, vector<int> inorder){        if(preorder.size() == 0 || inorder.size() == 0) return nullptr;         TreeNode* node = new TreeNode(preorder[0]);        if(preorder.size() == 1) return node;         int i; //根据pre找根节点的值，根据这个值在in中找坐标        for(int j = 0; j < preorder.size(); j++){            if(inorder[j] == preorder[0]) {                i = j;                break;            }        }        //切片操作是左闭右开的   begin指向0，end指向n        vector<int> l_p(preorder.begin() + 1, preorder.begin() + i + 1);        vector<int> l_i(inorder.begin(), inorder.begin() + i);        vector<int> r_p(preorder.begin() + i + 1, preorder.end());        vector<int> r_i(inorder.begin() + i + 1, inorder.end());        node->left = traversal(l_p, l_i);        node->right = traversal(r_p, r_i);        return node;    }    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        return traversal(preorder,inorder);    }};</code></pre><h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a>09. 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><pre><code>输入：["CQueue","appendTail","deleteHead","deleteHead","deleteHead"][[],[3],[],[],[]]输出：[null,null,3,-1,-1]</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class CQueue {private:    stack<int> st1, st2;public:    CQueue() {    }    void appendTail(int value) {        st2.push(value);    }    int deleteHead() {        if(st1.empty() && st2.empty()){            return -1;        }        if(st1.empty()){            while(!st2.empty()){                st1.push(st2.top());                st2.pop();            }        }        int res = st1.top();        st1.pop();        return res;    }};</code></pre><h2 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a>10- II. 青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要<strong>取模</strong> 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp问题class Solution {public:    int numWays(int n) {        uint64_t mod = 1000000007;        if(n <= 1) return 1;        vector<uint64_t> dp(n+1);         dp[0] = 1;        dp[1] = 1;         for(int i = 2; i <= n; i++){            dp[i] = (dp[i-1]+dp[i-2]) % mod;        }        return dp[n] ;    }};</code></pre><h2 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a>10- I. 斐波那契数列</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><pre><code>F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        vector<int> dp(n+1);        if(n <= 1) return n;        dp[0] = 0;        dp[1] = 1;        for(int i = 2; i <= n; i++){            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007;        }        return dp[n];    }};</code></pre><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。 </p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：numbers = [3,4,5,1,2]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：numbers = [2,2,2,0,1]输出：0</code></pre><p>我的暴力解法：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minArray(vector<int>& numbers) {        if(numbers.size() == 1) return numbers[0];        int last = numbers[0];        for(int i = 1; i < numbers.size(); i++){            if(numbers[i] >= last) last = numbers[i];            else return numbers[i];        }        return numbers[0];    }};</code></pre><p>此题考虑是升序数组，可以使用二分法来减少时间复杂度（左闭右开）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minArray(vector<int>& numbers) {        int low = 0;        int high = numbers.size() - 1;        while(low < high){            int mid = low + (high - low) / 2;            if(numbers[mid] > numbers[high]) low = mid + 1;            else if (numbers[mid] < numbers[high]) high = mid;            else high--;        }        return numbers[low];    }};</code></pre><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/</a></p><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径*"></a>12. 矩阵中的路径*</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/word2.jpg" alt="img"></p><p><strong>回溯的函数中，传参不加引用 会克隆一个新board并赋值然后供check()使用 这样会大大增加时间复杂度</strong>！！</p><p><strong>示例 1：</strong></p><pre><code>输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"输出：true</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 回溯算法用于递归查找子集    // 回溯    // 设函数 check(i,j,k) 表示判断以网格的 (i,j)位置出发，能否搜索到单词 word[k..](以k开头的后缀子串)    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, string& s, int k) {        // 这个board怎么不用引用就不行了呢？        // 因为不加引用 会克隆一个新board并赋值然后供check()使用 这样会大大增加时间复杂度        if (board[i][j] != s[k]) {            return false;        } else if (k == s.length() - 1) {            return true;        }        visited[i][j] = true;        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};        bool result = false;        for (auto dir: directions) {            int newi = i + dir.first, newj = j + dir.second;            if(newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size()){                if(!visited[newi][newj]){                    bool flag = check(board, visited, newi, newj, s, k + 1);                    if(flag){                        result = true;                        break;                    }                }            }        }        visited[i][j] = false;        return result;    }    bool exist(vector<vector<char>>& board, string word) {        int h = board.size(), w = board[0].size();        vector<vector<int>> visited(h, vector<int>(w));        for (int i = 0; i < h; i++) {            for (int j = 0; j < w; j++) {                bool flag = check(board, visited, i, j, word, 0);                if (flag) {                    return true;                }            }        }        return false;    }};</code></pre><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h2><p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/?favorite=xb9nqhhg">剑指 Offer 13. 机器人的运动范围 - 力扣（Leetcode）</a></p><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><pre><code>输入：m = 2, n = 3, k = 1输出：3</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // dfs遍历    int m;    int n;    int k;    int res = 0;    void dfs(int i, int j, vector<vector<bool>>& visited){ // i,j 表示当前位置         if(i >= m || j >=  n || i < 0 || j < 0) return;        if(i%10 + i/10 + j%10 + j/10 > k) return;        if(visited[i][j]) return;        visited[i][j] = true;        res++;        dfs(i-1, j, visited);        dfs(i+1, j, visited);        dfs(i, j-1, visited);        dfs(i, j+1, visited);    }    int movingCount(int m, int n, int k) {        this->m = m;        this->n = n;        this->k = k;        vector<vector<bool>> visited(m, vector<bool>(n, false));        dfs(0,0,visited);        return res;    }};</code></pre><h2 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a>14- I. 剪绳子</h2><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><pre><code>输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 动规    // dp[i] 长度为i的绳子的最大乘积    // 拆成两个还是拆成两个及以上？    // dp[i] = max((i-j)*j, dp[i - j]*j, dp[i])    int cuttingRope(int n) {        vector<int> dp(n+1);        dp[1] = 1;        dp[2] = 1;        for(int i = 2; i <= n; i++){            for(int j = 1; j < i; j++){                dp[i] = max(dp[i],max((i-j)*j, dp[i - j] * j));            }        }        return dp[n];    }};</code></pre><h2 id="15-二进制中1的个数——用n-amp-n-1-消除二进制最后一个1"><a href="#15-二进制中1的个数——用n-amp-n-1-消除二进制最后一个1" class="headerlink" title="15. 二进制中1的个数——用n &amp; (n-1)消除二进制最后一个1"></a>15. 二进制中1的个数——用n &amp; (n-1)消除二进制最后一个1</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 <a href="https://baike.baidu.com/item/二进制补码/5295284">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</code></pre><p><code>n &amp; (n-1)</code> 这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1：</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/1.png" alt="img" style="zoom: 50%;"></p><p>不断消除数字 <code>n</code> 中的 1，直到 <code>n</code> 变为 0。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int hammingWeight(uint32_t n) {        int res = 0;        while (n != 0) {            n = n & (n - 1);            res++;        }        return res;    }};</code></pre><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方*"></a>16. 数值的整数次方*</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><pre><code>输入：x = 2.00000, n = 10输出：1024.00000</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：x = 2.10000, n = 3输出：9.26100</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25</code></pre><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/shu-xue-yu-659f1/ru-he-gao--15bdf/">如何高效进行模幂运算 :: labuladong的算法小抄</a></p><p>我的：（会存在超时 ac:301/304）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    double myPow(double x, int n) {        double res = 1.0;        if(x == 1) return 1;        if(n > 0){            for(int i = 0; i < n; i++){                res = res*x;            }        }else if(n < 0){            x = 1/x;            n = -n;            for(int i = 0; i < n; i++){                res = res*x;            }        }else res = 1;        return res;    }};</code></pre><p>题解方法：快速幂 + 递归</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230411214203507.png" alt="image-20230411214203507"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    double quickMul(double x, long long N) {        if (N == 0) {            return 1.0;        }        double y = quickMul(x, N / 2);        return N % 2 == 0 ? y * y : y * y * x;    }    double myPow(double x, int n) {        long long N = n;        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);    }};</code></pre><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h2><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><pre><code>输入: n = 1输出: [1,2,3,4,5,6,7,8,9]</code></pre><p><strong>考虑大数问题</strong>！！（leetcode上没考虑，直接暴力就完事了)</p><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solutions/278565/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/">剑指 Offer 17. 打印从1到最大的n位数 - 力扣（Leetcode）</a></p><p><strong>用字符串模拟加法</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> res;    vector<int> printNumbers(int n) {        for(int i = 1; i <= n; i++)            for(int j = 1; j <= 9; j++)                dfs(1, i, to_string(j)); //dfs从1开始，因为第0位已经确定了        return res;    }    void dfs(int k, int len, string s) // k表示第k位数字，len表示要打印的长度    {        if(k==len)        {            res.push_back(stoi(s));            return;        }        for(int i = 0; i < 10; i++){            dfs(k + 1, len, s + to_string(i));        }    }};</code></pre><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><pre><code>输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//虚拟头节点的定义和使用，防止头节点要另外操作class Solution {public:    ListNode* deleteNode(ListNode* head, int val) {        ListNode* dummyhead = new ListNode(-1);        dummyhead->next = head;        ListNode* cur = dummyhead;        while(cur->next){            if(cur->next->val != val){                cur = cur->next;            }else {                cur->next = cur->next->next;                return dummyhead->next;            }        }        return dummyhead->next;    }};</code></pre><h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19. 正则表达式匹配*"></a>19. 正则表达式匹配*</h2><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/?favorite=xb9nqhhg">剑指 Offer 19. 正则表达式匹配 - 力扣（Leetcode）</a></p><p>请实现一个函数用来匹配包含<code>'. '</code>和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>"aaa"</code>与模式<code>"a.a"</code>和<code>"ab*ac*a"</code>匹配，但与<code>"aa.a"</code>和<code>"ab*a"</code>均不匹配。</p><p><strong>示例 1:</strong></p><pre><code>输入:s = "aa"p = "a"输出: false解释: "a" 无法匹配 "aa" 整个字符串。</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public://dp 函数的定义如下：// dp[i,j] 表示 s 的前i 个字符与p 的前 j 个字符是否能够匹配 (末尾下标分别对应i-1，j-1)// 递推：分两种情况，p[j-1] == 'x*?  不等于的很简单，下面只写等于的// 如果 p 的第 j 个字符是 *，那么就表示我们可以对 p 的第 j−1个字符匹配任意自然数次。在匹配0次的情况下，我们有// dp[i][j]=dp[i][j−2] ,也就是我们「浪费」了一个字符 + 星号的组合，没有匹配任何 s 中的字符。// 匹配 s 末尾的一个字符，将该字符扔掉，而该字符 + 星号组合还可以继续进行匹配；(dp[i-1][j] && match_sig(i,j-1))// 初始化：dp[0][0]  i从0遍历，因为s长度为0，p为a*也能匹配,需要计算得出    string S,P;    bool match_sig(int i, int j){        if(i != 0 && (S[i-1] == P[j-1] || P[j-1] == '.' )) return true;        else return false;    }    bool isMatch(string s, string p) {        S = s;        P = p;        vector<vector<int>> dp(s.size() + 1,vector<int>(p.size() + 1, 0));        dp[0][0] = true;        // i != 0 ; j == 0 的情况都为false        for(int i = 0; i <= s.size(); i++){            for(int j = 1; j <= p.size(); j++){                if(p[j - 1] == '*') {                    dp[i][j] = (match_sig(i,j-1) && dp[i-1][j]) || dp[i][j-2];                }else{                    dp[i][j] = match_sig(i,j) && dp[i-1][j-1];                }            }        }        int a;        return dp[s.size()][p.size()];    }};</code></pre><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h2><p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">剑指 Offer 20. 表示数值的字符串 - 力扣（Leetcode）</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 此题考查状态机写法,太麻烦了。。。// 抄下面的方法：// ‘.’出现正确情况：只出现一次，且在e的前面// ‘e’出现正确情况：只出现一次，且出现前有数字// ‘+’‘-’出现正确情况：只能在开头和e后一位class Solution {public:    bool isNumber(string s) {        //去掉首尾空格        int i = 0;        while (i < s.size() && s[i] == ' ')            i++;        s = s.substr(i);        while (s.back() == ' ')            s.pop_back();        bool numFlag = false;        bool dotFlag = false;        bool eFlag = false;        for (int i = 0; i < s.size(); i++) {            // 判定为数字，则标记numFlag            if (isdigit(s[i])) {                numFlag = true;            }            // 判定为'.'需要没出现过'.'并且没出现过'e'            else if (s[i] == '.' && !dotFlag && !eFlag) {                dotFlag = true;            }            // 判定为'e'，需要没出现过'e'，并且出现过数字            else if ((s[i] == 'e' || s[i] == 'E') && !eFlag && numFlag) {                eFlag = true;                numFlag = false; // 'e'后面必须跟着一个整数，所以出现'e'之后就标志为false            }            // 判定为'+''-'符号，只能出现在第一位或者紧接'e'后面            else if ((s[i] == '+' || s[i] == '-') && (i == 0 || s[i - 1] == 'e' || s[i - 1] == 'E')) {            }             // 其他情况，都是非法的            else {                return false;            }        }        return numFlag;    }};</code></pre><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><p><strong>示例：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:// 双指针    vector<int> exchange(vector<int>& nums) {        int n = nums.size();        int left = 0;        int right = 0;        while(right < n){            if(nums[right] % 2 == 1){                swap(nums[left], nums[right]);                left++;            }            right++;        }        return nums;    }};</code></pre><h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    ListNode* getKthFromEnd(ListNode* head, int k) {        ListNode* left = head;        ListNode* right = head;        while(k--){            right = right->next;        }        while(right){            left = left->next;            right = right->next;        }        return left;    }};</code></pre><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode* left = nullptr;        ListNode* right = head;        while(right){            ListNode* temp = right->next;            right->next = left;            left = right;            right = temp;        }        return left;    }};</code></pre><h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h2><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/?favorite=xb9nqhhg">剑指 Offer 25. 合并两个排序的链表 - 力扣（Leetcode）</a></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1 == nullptr) return l2;        if(l2 == nullptr) return l1;        ListNode* left = l1;        ListNode* right = l2;        ListNode* dummy = new ListNode(-1);        ListNode* cur = dummy;        while(left && right){            if(left->val <= right->val) {                cur->next = left;                left = left->next;            }else{                cur->next = right;                right = right->next;            }            cur = cur->next;        }         if(left) cur->next = left;        if(right) cur->next = right;        return dummy->next;    }};</code></pre><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h2><p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/?favorite=xb9nqhhg">剑指 Offer 26. 树的子结构 - 力扣（Leetcode）</a></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 回溯      // 注意：约定空树不是任意一个树的子结构    // 判定同根节点的树B是否是A的子树    bool dfs(TreeNode* A, TreeNode* B){        if(!B) return true; // 当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true        if(!A) return false; //当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false        return A->val == B->val && dfs(A->left, B->left) && dfs(A->right, B->right);    }      // 切换不同子节点作为A的根节点和B比较    bool isSubStructure(TreeNode* A, TreeNode* B) {        if(!B || !A) return false;        return dfs(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);    }};</code></pre><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h2><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/?favorite=xb9nqhhg">剑指 Offer 27. 二叉树的镜像 - 力扣（Leetcode）</a></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* mirrorTree(TreeNode* root) {        if(!root) return nullptr;        TreeNode* res = new TreeNode(root->val);        res->left = mirrorTree(root->right);        res->right = mirrorTree(root->left);        return res;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//这个方法更直观，且占用的额外空间更少class Solution {public:    TreeNode* mirrorTree(TreeNode* root) {        if(root == NULL) return root;        TreeNode* temp = root->left;        root->left = mirrorTree(root->right);        root->right = mirrorTree(temp);         return root;    }};</code></pre><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h2><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/description/?favorite=xb9nqhhg">剑指 Offer 28. 对称的二叉树 - 力扣（Leetcode）</a></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230417164040752.png" alt="image-20230417164040752"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt="Picture1.png" style="zoom: 33%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool dfs(TreeNode* L, TreeNode* R){        if(!L && !R) return true;        else if(!L || !R) return false;        if(L->val == R->val) return dfs(L->left, R->right) && dfs(L->right, R->left);        else return false;    }    bool isSymmetric(TreeNode* root) {        if(!root) return true;        return dfs(root->left,root->right);    }};</code></pre><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public://状态机    vector<int> spiralOrder(vector<vector<int>>& matrix) {        int m = matrix.size(); // m行        if(m == 0) return {};        int n = matrix[0].size(); // n列        if(n == 0) return {};        vector<int> res;        int state = 0;// 0 向右，1向下，2向左，3向上        int up = 0, down = m - 1, left = 0, right = n - 1;        int x = 0, y = 0;        for(int i = 0; i < m*n - 1; i++){            res.push_back(matrix[x][y]);            switch (state){                case 0:                    if(y == right){                        state = 1;                        x++;                        up++;                    }else{                        y++;                    }                    break;                case 1:                    if(x == down){                        state = 2;                        y--;                        right--;                    }else{                        x++;                    }                    break;                case 2:                    if(y == left){                        state = 3;                        x--;                        down--;                    }else{                        y--;                    }                    break;                case 3:                    if(x == up){                        state = 0;                        y++;                        left++;                    }else{                        x--;                    }                    break;            }        }        return res;     }};</code></pre><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h2><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/?favorite=xb9nqhhg">剑指 Offer 30. 包含min函数的栈 - 力扣（Leetcode）</a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.</code></pre><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/155.jpeg" alt="img" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 空间换时间 用一个额外的栈 minStk 来记录栈中每个元素下面（到栈底）的最小元素是多少class MinStack {public:    stack<int> st;    stack<int> min_st;    /** initialize your data structure here. */    MinStack() {    }    void push(int x) {        if(st.empty()) {            min_st.push(x);        }else{            if(x <= min_st.top()){                min_st.push(x);            } else{                min_st.push(min_st.top());            }           }        st.push(x);      }    void pop() {        if(!st.empty()){            st.pop();            min_st.pop();        }    }    int top() {        return st.top();    }    int min() {        return min_st.top();    }};</code></pre><h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 新建一个栈模拟该过程，    // popped[i] != s.top()   s.push(pushed[j])    // popped[i] == s.top()   s.pop()    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {        stack<int> s;        for(int i = 0, j = 0; i < popped.size(); i++){            // 注意最开始第一个直接入栈            while( s.empty() || (popped[i] != s.top() && j < pushed.size())){                s.push(pushed[j]);                j++;            }            if(popped[i] == s.top()) {                s.pop();            }        }        return s.empty();    }};</code></pre><h2 id="32-二叉树层序遍历"><a href="#32-二叉树层序遍历" class="headerlink" title="32. 二叉树层序遍历"></a>32. 二叉树层序遍历</h2><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/?favorite=xb9nqhhg">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/?favorite=xb9nqhhg</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 二叉树层序遍历 迭代    vector<int> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<int> res;        while(!que.empty()){            TreeNode* cur = que.front();            res.push_back(cur->val);            if (cur->left) que.push(cur->left);            if (cur->right) que.push(cur->right);            que.pop();        }        return res;    }};</code></pre><p>结果分层打印，如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<vector<int>> res;        while(!que.empty()){            int length = que.size();            vector<int> temp;            for(int i = 0; i < length; i++){                TreeNode* cur = que.front();                temp.push_back(cur->val);                if (cur->left) que.push(cur->left);                if (cur->right) que.push(cur->right);                que.pop();            }            res.push_back(temp);        }        return res;    }};</code></pre><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 中序遍历二叉搜索树，则是递增的    // 前驱节点 pre 和当前节点 cur, pre.right = cur,  cur.left = pre    // 记录头尾节点    Node *pre, *head;    void dfs(Node* cur){        if (cur == NULL) return;        dfs(cur->left);        //中序处理        if(pre != nullptr) pre->right = cur;        else head = cur;        cur->left = pre;        pre = cur;        dfs(cur->right);    }    Node* treeToDoublyList(Node* root) {        if(root == NULL) return NULL;        dfs(root);        head->left = pre;        pre->right = head;        return head;    }};</code></pre><h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。（字符串中可能存在重复字符）</p><p>你可以以任意顺序返回这个字符串数组，但里面<strong>不能有重复</strong>元素。</p><p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/description/">剑指 Offer 38. 字符串的排列 - 力扣（Leetcode）</a></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230516165808685.png" alt="image-20230516165808685"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:// 全排列问题，回溯算法// 排序去重！ 树层去重效率更高    vector<string> res;    string path;    void dfs(string& s, vector<bool>& used){        if(path.size() == s.size()){            res.push_back(path);            return;        }        for(int i = 0; i < s.size(); i++){            if(used[i]) continue;            // used[i - 1] == false，说明同一树层nums[i - 1]使用过            // 如果同一树层nums[i - 1]使用过则直接跳过            if (i > 0 && s[i] == s[i - 1] && used[i - 1] == false) {                continue;            }            used[i] = true;            path += s[i];            dfs(s,used);            used[i] = false;            path.pop_back();        }    }public:    vector<string> permutation(string s) {        vector<bool> used(s.size(), false);        sort(s.begin(), s.end()); // 排序        dfs(s, used);        return res;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:// 全排列问题，回溯算法// uset去重！    vector<string> res;    string path;    void dfs(string& s, vector<bool>& used){        if(path.size() == s.size()){            res.push_back(path);            return;        }        unordered_set<char> uset;        for(int i = 0; i < s.size(); i++){            if(used[i]) continue;            if (uset.find(s[i]) != uset.end()) {                continue;            }            uset.insert(s[i]); // 记录元素            used[i] = true;            path += s[i];            dfs(s,used);            used[i] = false;            path.pop_back();        }    }public:    vector<string> permutation(string s) {        vector<bool> used(s.size(), false);        dfs(s, used);        return res;    }};</code></pre><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p> <a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/?favorite=xb9nqhhg">剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（Leetcode）</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//解法一：排序取中位数//时间O(nlogn)，空间O(1)class Solution {public:    int majorityElement(vector<int>& nums) {        sort(nums.begin(), nums.end());        return nums[nums.size()/2];    }};//解法二：建立哈希表法//时间O(n)，空间O(n/2)class Solution {public:    int majorityElement(vector<int>& nums) {        unordered_map<int,int> hash;        int len = nums.size();        for(int i = 0; i < len; i++){            hash[nums[i]]++;            //不必等到哈希表完全建立再进行此判断             if(hash[nums[i]] > len/2) return nums[i];          }        return 0;    }};//解法三：摩尔投票法//也可以理解成混战极限一换一，不同的两者一旦遇见就同归于尽，最后活下来的值都是相同的，即要求的结果//时间O(n)，空间O(1)class Solution {public:    int majorityElement(vector<int>& nums) {        int res = 0, count = 0;        for(int i = 0; i < nums.size(); i++){            if(count == 0){                res = nums[i];                count++;            }            else                res==nums[i] ? count++:count--;        }        return res;    }};</code></pre><h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a>40. 最小的k个数</h2><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/">剑指 Offer 40. 最小的k个数 - 力扣（Leetcode）</a></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><pre><code>输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]</code></pre><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h2><p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/description/?favorite=xb9nqhhg">剑指 Offer 42. 连续子数组的最大和 - 力扣（Leetcode）</a></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:/*dp 数组的含义：以 nums[i] 为结尾的「最大子数组和」为 dp[i]。dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。在这两种选择中择优，就可以计算出最大子数组，dp[i] = max(dp[i-1] + nums[i], nums[i])注意返回值不是dp[n] 而是最大的dp[i]*/    int maxSubArray(vector<int>& nums) {        vector<int> dp(nums.size());        dp[0] = nums[0];        int res = dp[0];        for(int i = 1; i < nums.size(); i++){            dp[i] = max(dp[i-1] + nums[i], nums[i]);            res = max(res,dp[i]);        }        return res;    }};</code></pre><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h2><p><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/?favorite=xb9nqhhg">剑指 Offer 46. 把数字翻译成字符串 - 力扣（Leetcode）</a></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><pre><code>输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"</code></pre><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230518164846771.png" alt="image-20230518164846771"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230518165739691.png" alt="image-20230518165739691"></p><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int translateNum(int num) {        string s = to_string(num);        if(s.size() == 0) return 0;        vector<int> dp(s.size()+1,0);        // dp[i]表示以第i-1位结尾的前缀传翻译的方案数        dp[0] = 1;        dp[1] = 1;        for(int i = 2; i <= s.size(); i++){            string tmp = s.substr(i-2,2);            if(stoi(tmp) <= 25 && stoi(tmp) >= 10){                dp[i] = dp[i-1] + dp[i-2];            }else{                dp[i] = dp[i-1];            }        }        return dp[s.size()];    }};</code></pre><p>空间优化：</p><p>滚动数组代替dp</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int translateNum(int num) {        string s = to_string(num);        if(s.size() == 0) return 0;        vector<int> dp(s.size()+1,0);        // dp[i]表示以第i-1位结尾的前缀传翻译的方案数        int a = 1;        int b = 1;        int c = 0;        for(int i = 2; i <= s.size(); i++){            string tmp = s.substr(i-2,2);            if(stoi(tmp) <= 25 && stoi(tmp) >= 10){                c = b + a;            }else{                c = b;            }            a = b;            b = c;        }        return b;    }};</code></pre><h2 id="57-II-和为s的连续正数序列"><a href="#57-II-和为s的连续正数序列" class="headerlink" title="57 - II. 和为s的连续正数序列*"></a>57 - II. 和为s的连续正数序列*</h2><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：target = 9输出：[[2,3,4],[4,5]]</code></pre><p>法一暴力：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>> res;        for(int i = 1; i <= target/2; i++){            int sum = 0;            vector<int> temp;            for(int j = i; j < target && sum <= target; j++){                if(sum == target){                    res.push_back(temp);                    break;                }                sum += j;                temp.push_back(j);            }        }        return res;    }};</code></pre><p>方法二：枚举 + 数学优化</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211105743.png" alt="image-20230522211105743"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211727462.png" alt="image-20230522211727462" style="zoom:50%;"></p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522211735296.png" alt="image-20230522211735296" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>> res;        vector<int> vec;        int sum = 0, limit = (target - 1) / 2; // (target - 1) / 2 等效于 target / 2 下取整        for (int x = 1; x <= limit; ++x) {            long long delta = 1 - 4 * (x - 1ll * x * x - 2 * target); // 1ll是为了把int类型转为long long            if (delta < 0) {                continue;            }            // int delta_sqrt = (int)sqrt(delta + 0.5); // 开根号之后是double，直接转int会有损失，所以往回补点            int delta_sqrt = (int)sqrt(delta); //不加0.5也行，此处没有这种极端情况            if (1ll * delta_sqrt * delta_sqrt == delta && (delta_sqrt-1) % 2 == 0) {                int y = (-1 + delta_sqrt) / 2; // 另一个解(-1-delta_sqrt)/2必然小于0，不用考虑                if (x < y) {                    vec.clear();                    for (int i = x; i <= y; ++i) {                        vec.emplace_back(i);                    }                    res.emplace_back(vec);                }            }        }        return res;    }};</code></pre><p>法三：双指针（这个最好）</p><p><img src="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/image-20230522215007347.png" alt="image-20230522215007347"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> findContinuousSequence(int target) {        vector<vector<int>>vec;        vector<int> res;        for (int l = 1, r = 2; l < r;){            int sum = (l + r) * (r - l + 1) / 2;            if (sum == target) {                res.clear();                for (int i = l; i <= r; ++i) {                    res.emplace_back(i);                }                vec.emplace_back(res);                l++;            } else if (sum < target) {                r++;            } else {                l++;            }        }        return vec;    }};</code></pre>]]></content>
    
    
    <summary type="html">03. 数组中重复的数字
找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3


我的（hash）：

class Solution {
public:
    int findRepeatNumber(vector&lt;int&gt;&amp;amp; nums) {
        // hash
        vector&lt;int&gt; hash(nums.size(),0&lt;/int&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>经典八股</title>
    <link href="https://youngyyp.github.io/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/"/>
    <id>https://youngyyp.github.io/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-06-26T14:09:39.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="池化层是怎么进行反向传播的-最大池化-平均池化"><a href="#池化层是怎么进行反向传播的-最大池化-平均池化" class="headerlink" title="池化层是怎么进行反向传播的 最大池化 平均池化"></a>池化层是怎么进行反向传播的 最大池化 平均池化</h4><p>1、平均池化的反向传播<br>mean pooling的前向传播就是把一个patch中的值求取平均来做pooling，那么反向传播的过程也就是把某个元素的梯度等分为n份分配给前一层，这样就保证池化前后的梯度（残差）之和保持不变，还是比较理解的，图示如下 ：</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/resize,m_fixed,w_1184.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_面试_15"></p><p>2、最大池化的反向传播<br>反向传播也就是把梯度直接传给前一层某一个像素，而其他像素不接受梯度，也就是为0</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/resize,m_fixed,w_1184-16838108349864.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_激活函数_16"></p>]]></content>
    
    
    <summary type="html">池化层是怎么进行反向传播的 最大池化 平均池化
1、平均池化的反向传播
mean pooling的前向传播就是把一个patch中的值求取平均来做pooling，那么反向传播的过程也就是把某个元素的梯度等分为n份分配给前一层，这样就保证池化前后的梯度（残差）之和保持不变，还是比较理解的，图示如下 ：



2、最大池化的反向传播
反向传播也就是把梯度直接传给前一层某一个像素，而其他像素不接受梯度，也就是为0</summary>
    
    
    
    <category term="深度学习基础" scheme="https://youngyyp.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>transformer基础</title>
    <link href="https://youngyyp.github.io/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://youngyyp.github.io/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2023-03-01T13:14:33.000Z</published>
    <updated>2023-06-26T14:08:09.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>能够适应大数据，泛化性更强（transformer上限高，cnn下限高）</p><p>全局感受野</p><p>更好的处理序列数据能力</p><p>并行计算能力</p><p>更容易扩展到其他任务</p><p>缺点：</p><p>没有平移、缩放、形变的不变性（CNN存在归纳偏置，局部性和平移等变性）</p><p>CNN有强归纳偏置性,所以在小数据集上表现更好。但如果有大量的数据可用,CNN的强归纳偏置性反而会限制模型的能力</p><h3 id="卷积的平移等变性："><a href="#卷积的平移等变性：" class="headerlink" title="卷积的平移等变性："></a>卷积的平移等变性：</h3><p><strong>卷积+最大池化等于平移等变性</strong>。</p><p>卷积：简单地说，<strong>图像经过平移，相应的特征图上的表达也是平移的。</strong>输入图像的左下角有一个人脸，经过卷积，人脸的特征（眼睛，鼻子）也位于特征图的左下角</p><p>池化：比如最大池化，它返回感受野中的最大值，<strong>如果最大值被移动了，但是仍然在这个感受野中</strong>，那么池化层也仍然会输出相同的最大值。这就有点平移不变的意思了。</p><h4 id="也有论文认为cnn不具备平移等变性："><a href="#也有论文认为cnn不具备平移等变性：" class="headerlink" title="也有论文认为cnn不具备平移等变性："></a>也有论文认为cnn不具备平移等变性：</h4><p>论文地址：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1805.12177.pdf">arxiv.org/pdf/1805.12177.pdf</a></p><p>希伯来大学的Ah<a href="https://link.zhihu.com/?target=https%3A//www.jqr.com/service/company%3Fbusiness%3D17">ar</a>on Azulay和Yair Weiss近期发表的<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1805.12177.pdf">Why do deep convolutional networks generalize so poorly to small image transformations?</a> 这篇文章发现当小尺寸图像发生平移后，CNN会出现识别错误的现象，而且这一现象是普遍的。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Transformer采用Encoder-Decoder架构，N一般取6</p><p><strong>encoder</strong>主要包括self-attention和前馈网络两个模块，每个模块之后还会加上残差连接和layernorm</p><p>attention本质上就是通过加权求和获得对上下文的全局感知，qk计算权重，再乘以v嵌入上下文信息</p><p>每个向量的q 和 所有向量的k 相乘得到的权重就是attention，用softmax过滤掉不相干的单词，乘以v向量进行加权求和</p><p>encoder基本结构：Embedding + Position Embedding，Self-Attention，Add + LN，FN，Add + LN</p><p><strong>decoder</strong>主要包括masked multihead attention(self-attention)、encoder-decoder attention(cross attention) 和 feed forward network三个模块，每个模块之后还会加上残差连接和layernorm</p><p>encoder-decoder attention不仅考虑已经翻译的内容，还要考虑encoder中上下文的信息。解码器的输出经过线性层和softmax层，得到输出</p><p>每个self-attention又会分解成几个部分，称为multi-head self-attention（通常8头），在这之中使用了不同的权重矩阵qkv进行了8次计算，这样做的目的是为了消除QKV初始值的影响（一件事找八个人做，万一哪个不靠谱也不影响）</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426094514229.png" alt="image-20230426094514229" style="zoom:50%;"></p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095027000.png" alt="image-20230426095027000" style="zoom:50%;"></p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095826505.png" alt="image-20230426095826505" style="zoom: 33%;"></p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426095902928.png" alt="image-20230426095902928" style="zoom: 33%;"></p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230426100259964.png" alt="image-20230426100259964" style="zoom:50%;"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://luweikxy.gitbook.io/machine-learning-notes/self-attention-and-transformer">很好的讲解transformer的文章</a></p><h2 id="常见八股"><a href="#常见八股" class="headerlink" title="常见八股"></a>常见八股</h2><p>1.Transformer为何使用多头注意力机制？（为什么不使用一个头）</p><ul><li>Transformer使用多头注意力机制是为了增强模型的表达能力，可以让模型在不同的表征空间内学习到不同的特征表示。如果只使用一个头，模型就只能学习到单一的特征表示，而无法利用多个空间内的特征信息。</li><li>通俗来说就是从多个方面来进行理解</li></ul><p>2.Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？ （注意和第一个问题的区别）</p><ul><li><p>简单回答就是，使用Q/K/V不相同可以保证在不同空间进行投影，增强了表达能力，提高了泛化能力。</p></li><li><p><em>q</em>就是query，k就是key，v就是value，(k,v)就是键值对、也就是用query关键词去找到最相关的检索结果</p></li><li><p>Q和K使用不同的权重矩阵生成是因为它们的含义不同。Q是查询向量，K是键向量，它们代表了不同的信息，因此使用不同的权重矩阵可以让它们学习不同的表示。</p></li></ul><p>3.Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？</p><ul><li>Transformer计算attention时选择点乘而不是加法，是因为点乘可以反映不同向量之间的相似度，更好地捕捉到语义信息的相关性。而加法只是简单地把两个向量相加，不能反映语义信息的相关性。从计算复杂度和效果上看，点乘更适合文本序列的处理。</li></ul><p>4.为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根），并使用公式推导进行讲解</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230511101521508.png" alt="image-20230511101521508" style="zoom:50%;"></p><ul><li><p><a href="https://blog.csdn.net/jokerxsy/article/details/116299343">Transformer中的attention为什么要做scale？</a></p></li><li><p>一句话：</p></li><li><p><strong>如果不对softmax的输入做缩放，那么万一输入的数量级很大，输出会趋向1，softmax的梯度就会趋向于0，导致梯度消失。</strong>假设 Q 和 K 的均值为0，方差为1。它们的矩阵乘积将有均值为0，方差为<script type="math/tex">d_k</script>。方差越大，就有更可能取到很大的值，所以我们除以dk的平方根，使其方差为1。</p></li></ul><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pva2VyeHN5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>5.在计算attention score的时候如何对padding做mask操作？</p><ul><li><p><strong>Padding Mask</strong></p><p>  什么是padding mask呢？因为每个批次输入序列长度是不一样的也就是说，我们要对输入序列进行对齐。具体来说，就是给在较短的序列后面填充0。但是如果输入的序列太长，则是截取左边的内容，把多余的直接舍弃。因为这些填充的位置，其实是没什么意义的，所以我们的Attention机制不应该把注意力放在这些位置上，所以我们需要进行一些处理。</p><p>  具体的做法是，<strong>把这些位置的值加上一个非常大的负数(负无穷)，这样的话，经过softmax，这些位置的概率就会接近0</strong>！ 而我们的padding mask 实际上是一个张量，每个值都是一个Boolean，值为false的地方就是我们要进行处理的地方</p></li><li><p><strong>Sequence mask</strong></p><p>  文章前面也提到，sequence mask是为了使得Decoder不能看见未来的信息。也就是对于一个序列，在time_step为t的时刻，我们的解码输出应该只能依赖于t时刻之前的输出，而不能依赖t之后的输出。因此我们需要想一个办法，把t之后的信息给隐藏起来。 那么具体怎么做呢？也很简单：产生一个上三角矩阵，上三角的值全为0。把这个矩阵作用在每一个序列上，就可以达到我们的目的。</p><p>  sequence mask的目的是防止Decoder “seeing the future”，就像防止考生偷看考试答案一样。这里mask是一个下三角矩阵，对角线以及对角线左下都是1，其余都是0。下面是个10维度的下三角矩阵：</p><p>  [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 0, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 0, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 0, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 0, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],</p><p>   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]</p></li></ul><p>6.为什么在进行多头注意力的时候需要对每个head进行降维？（可以参考上面一个问题）</p><ul><li>借鉴CNN多核的思想，在更低的维度，在多个独立的特征空间，更容易学习到更丰富的特征信息。</li><li>将原有的高维空间转化为多个低维空间并再最后进行拼接，形成同样维度的输出，借此丰富特性信息，降低了计算量</li></ul><p>7.大概讲一下Transformer的Encoder模块？</p><ul><li><strong>encoder</strong>主要包括self-attention和前馈网络两个模块，每个模块之后还会加上残差连接和layernorm</li></ul><p>8.为何在获取输入词向量之后需要对矩阵乘以embedding size的开方？意义是什么？</p><ul><li><p>对矩阵乘以embedding size的开方是为了将词向量的scale调整到合适的范围，避免过大或过小的梯度对模型的训练产生影响。</p></li><li><p>embedding matrix的初始化方式是xavier init，这种方式的方差是1/embedding size，因此乘以embedding size的开方使得embedding matrix的方差是1，在这个scale下可能更有利于embedding matrix的收敛。</p></li></ul><p>9.简单介绍一下Transformer的位置编码？有什么意义和优缺点？</p><ul><li><p>因为self-attention是位置无关的，无论句子的顺序是什么样的，通过self-attention计算的token的hidden embedding都是一样的，这显然不符合人类的思维。因此要有一个办法能够在模型中表达出一个token的位置信息，transformer使用了固定的positional encoding来表示token在句子中的绝对位置信息。</p></li><li><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512112447304.png" alt="image-20230512112447304" style="zoom:50%;"></p></li><li><p>理解transformer的作者为什么设计这样的编码方式来生成位置向量呢? 因为三角函数有个性质</p><p>  ​          sin(a+b) = sin(a) <em> cos(b) + cos(a) </em> sin(b)</p><p>  ​         cos(a+b) = cos(a) <em> cos(b) - sin(a) </em> sin(b)</p><p>   因此可以推导出，两个位置向量的点积是一个与他们两个位置差值（即相对位置）有关，而与绝对位置无关。这个性质使得在计算注意力权重的时候(两个向量做点积)，使得相对位置对注意力发生影响，而不是绝对位置，这更符合常理。</p></li></ul><p>10.<strong>你还了解哪些关于位置编码的技术，各自的优缺点是什么？</strong></p><ul><li><p>相对位置编码（RPE）</p><p>  1.在计算attention score和weighted value时各加入一个可训练的表示相对位置的参数。</p><p>  2.在生成多头注意力时，把对key来说将绝对位置转换为相对query的位置</p><p>  3.复数域函数，已知一个词在某个位置的词向量表示，可以计算出它在任何位置的词向量表示。前两个方法是词向量+位置编码，属于亡羊补牢，复数域是生成词向量的时候即生成对应的位置信息。</p></li></ul><p>11.简单讲一下Transformer中的残差结构以及意义。</p><ul><li><p>encoder和decoder的self-attention层和ffn层都有残差连接</p></li><li><p>反向传播的时候不会造成梯度消失。</p></li><li><p>残差网络与普通网络不同的地方就是引入了跳连接,这可以使上一个残差块的信息没有阻碍的流入到下一个残差块,提高了信息流通,并且也避免了由与网络过深所引起的消失梯度问题和退化问题。</p></li><li><p>残差链接的方式：</p><p>  H(x)=F(x)+x 通道相同，所以采用计算方式为H(x)=F(x)+x</p><p>  H(x)=F(x)+x  通道不同，采用的计算方式为H(x)=F(x)+Wx，其中W是卷积操作，用来调整x维度的。</p></li></ul><p>12.为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm 在Transformer的位置是哪里？</p><p>layernorm的<script type="math/tex">x_i</script> 是样本内，bn是样本间</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512103216297.png" alt="image-20230512103216297" style="zoom:50%;"></p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230512103229670.png" alt="image-20230512103229670" style="zoom:50%;"></p><ul><li>LN：针对每个样本序列进行求均值和方差，归一化到正态分布后再缩放到合适的均值和方差，没有样本间的依赖。位置在每个Atention和FFN后。</li><li>CV使用BN是认为channel维度的信息对cv方面有重要意义，如果对channel维度也归一化会造成不同通道信息一定的损失。而同理nlp领域认为句子长度不一致，并且各个batch的信息没什么关系，因此只考虑句子内信息的归一化，也就是LN。</li></ul><p>13.简单讲一下BatchNorm技术，以及它的优缺点。</p><p><a href="https://blog.csdn.net/Icanhearwawawa/article/details/123347946">【面试总结】BN的利弊</a></p><ul><li><p>BN优点：</p><ul><li>第一个就是可以<strong>解决内部协变量偏移</strong>，简单来说训练过程中，各层分布不同，增大了学习难度，BN缓解了这个问题。</li><li>BN 层通常设置在激活函数之前。BN层的作用机制是对隐藏层输入的分布进行平滑，缓解随机梯度下降权重更新对后续层的负面影响。对sigmoid和tanh而言，放非线性激活之前，能缓解sigmoid或者 tanh的<strong>梯度衰减</strong>问题，而对ReLU而言，BTTA相关实验结果和代码N放到relu之前，可以防止某一层的激活值全部都被抑制，从而防止从这一层往前传的梯度全都变成０，也就是防止<strong>梯度消失</strong>。（当然也可以防止<strong>梯度爆炸</strong>）</li></ul></li><li><p>BN缺点：</p><ul><li>第一个，batch_size较小的时候，效果差。</li><li>第二个缺点就是 BN 在NLP中效果不好，因为文本的输入长度是动态的。</li><li>在测试阶段若出现样本长度超过训练集的最大长度，则无法处理，需要对样本进行截断</li><li>测试阶段的均值和方差的计算可能与训练集的相差较大</li></ul></li></ul><p>14.简单描述一下Transformer中的前馈神经网络？使用了什么激活函数？相关优缺点？</p><p>就是全连接层加残差连接和LN  </p><p>使用的激活函数是ReLU()</p><p><a href="https://dandelioncloud.cn/article/details/1473009113708978178/">深度神经网络中常用的激活函数的优缺点分析</a></p><p>15.Encoder端和Decoder端是如何进行交互的？（在这里可以问一下关于seq2seq的attention知识）</p><p><img src="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/resize,m_fixed,w_1184.webp" alt="面试宝典二：nlp常见知识点随机梯度下降SGD：这个算法的流程就是在每次更新的时候使用一个样本进行梯度下降，所谓的随机二字，就是说我们可以随机用一个样本来表示所有的样本_面试_03"></p><ul><li>Cross Self-Attention，Decoder提供Q，Encoder提供K，V</li><li>Encoder端和Decoder端通过attention机制进行交互，在Encoder端中，每个时间步都会计算一个attention向量，然后将其与输入向量相加得到新的向量；在Decoder端中，除了计算attention向量外还需要计算一个mask向量来避免模型看到未来的信息</li></ul><p>16.Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？（为什么需要decoder自注意力需要进行 sequence mask)</p><ul><li>Decoder阶段的多头自注意力和encoder的多头自注意力最大的区别就是decoder自注意力需要进行sequence mask来避免模型看到未来信息</li></ul><p>17.Transformer的并行化体现在哪个地方？Decoder端可以做并行化吗？</p><ul><li><p>Transformer的并行化我认为主要体现在self-attention模块，在Encoder端Transformer可以并行处理整个序列，并得到整个输入序列经过Encoder端的输出。因为单词之间没有依赖关系，不需要先输入前一个单词再输入下一个，可以同时输入所有单词。</p></li><li><p>Decode引入sequence mask就是为了并行化训练，推理过程不并行。 Transformer的Decoder部分，引入了一种“teacher force”的概念，就是每个时刻的输入不依赖上一时刻的输出，而是依赖之前所有正确的样本，而正确的样本在训练集中已经全部提供了。正是这种“teacher force”的思想，才可以在Transformer的Decoder部分进行并行化计算，</p></li><li><p>值得注意的一点是：Decoder的并行化仅在训练阶段，在测试阶段，因为我们没有label，所以t时刻的输入必然依赖t-1时刻的输出，这时跟之前的NLP中的序列预测就没什么区别了。</p><ul><li>NLP中的RNN之所以不能并行化，是因为其是一个马尔可夫过程，即当前状态只与前一个状态有关,而与再之前的所有状态无关。它天生是个时序结构，t时刻依赖t-1时刻的输出，而t-1时刻又依赖t-2时刻，如此循环往前，我们可以说t时刻依赖了前t时刻所有的信息。</li></ul></li></ul><p>19.Transformer训练的时候学习率是如何设定的？Dropout是如何设定的，位置在哪里？Dropout 在测试的需要有什么需要注意的吗？</p><ul><li>Transformer训练时学习率会有一个warmup的过程，即先升高再逐渐减小；Dropout一般设置为0.1-0.2之间，并且只在训练时使用，在测试时不需要使用</li></ul><p>20解码端的残差结构有没有把后续未被看见的mask信息添加进来，造成信息的泄露。</p><ul><li>解码端的残差结构没有把后续未被看见的mask信息添加进来，因此不会造成信息泄露³。</li></ul>]]></content>
    
    
    <summary type="html">特点
能够适应大数据，泛化性更强（transformer上限高，cnn下限高）

全局感受野

更好的处理序列数据能力

并行计算能力

更容易扩展到其他任务

缺点：

没有平移、缩放、形变的不变性（CNN存在归纳偏置，局部性和平移等变性）

CNN有强归纳偏置性,所以在小数据集上表现更好。但如果有大量的数据可用,CNN的强归纳偏置性反而会限制模型的能力

卷积的平移等变性：
卷积+最大池化等于平移等变性。

卷积：简单地说，图像经过平移，相应的特征图上的表达也是平移的。输入图像的左下角有一个人脸，经过卷积，人脸的特征（眼睛，鼻子）也位于特征图的左下角

池化：比如最大池化，它返回感受野中的</summary>
    
    
    
    <category term="深度学习基础" scheme="https://youngyyp.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-03T01:24:07.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划基础知识"><a href="#动态规划基础知识" class="headerlink" title="动态规划基础知识"></a>动态规划基础知识</h2><p>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>动规是由前一个状态推导出来的，而贪心是局部直接选最优的</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int n) {        if(n == 0) return 0;        if(n == 1) return 1;        return fib(n-1) + fib(n-2);    }};</code></pre><p>题解动规：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fib(int N) {        if (N <= 1) return N;        vector<int> dp(N + 1);        dp[0] = 0;        dp[1] = 1;        for (int i = 2; i <= N; i++) {            dp[i] = dp[i - 1] + dp[i - 2];        }        return dp[N];    }};</code></pre><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>用递归和回溯都超出时间限制</strong></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int climbStairs(int n) {        if (n <= 2) return n;        vector<int> dp(n+1);        dp[1] = 1;        dp[2] = 2;        for (int i = 3; i <= n; i++) {            dp[i] = dp[i - 1] + dp[i - 2];//关键        }        return dp[n];    }};</code></pre><p>还可以用完全背包，求排列（先遍历背包，再遍历物体）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int climbStairs(int n) {        vector<int> dp(n + 1, 0);        dp[0] = 1;        for (int i = 1; i <= n; i++) { // 遍历背包            for (int j = 1; j <= m; j++) { // 遍历物品                if (i - j >= 0) dp[i] += dp[i - j];            }        }        return dp[n];    }};</code></pre><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int minCostClimbingStairs(vector<int>& cost) {        vector<int> dp(cost.size() + 1);        dp[0] = 0; // 默认第一步都是不花费体力的        dp[1] = 0;        for (int i = 2; i <= cost.size(); i++) {            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);        }        return dp[cost.size()];    }};</code></pre><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePaths(int m, int n) {        vector<vector<int>> dp(m, vector<int>(n, 0));        //初始化，最好吧初始化和逻辑处理分开写，比较明了        for (int i = 0; i < m; i++) dp[i][0] = 1;        for (int j = 0; j < n; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接(opens new window)</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        int m = obstacleGrid.size(); //！！记住这里的方式        int n = obstacleGrid[0].size();        vector<vector<int>> dp(m, vector<int>(n, 0));        /* 这块的判断写复杂了        int sig = 1;        for (int i = 0; i < m; i++) {            if(obstacleGrid[i][0] == 1) {                dp[i][0] = 0;                sig = 0;            }            if(sig) dp[i][0] = 1;        }        sig = 1;        for (int j = 0; j < n; j++) {            if(obstacleGrid[0][j] == 1) {                dp[0][j] = 0;                sig = 0;            }            if(sig) dp[0][j] = 1;        }        */        //题解的初始化判断        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;        for(int i = 1; i < m; i++) {            for(int j = 1; j < n; j++){                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;                else dp[i][j] = dp[i-1][j] + dp[i][j-1];            }        }        return dp[m-1][n-1];    }};</code></pre><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接(opens new window)</a></p><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>思路：遍历，比较<code>dp[i - j] * j, (i - j) * j</code>大小，即比较拆成两个和拆成两个以上的乘积大小。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int integerBreak(int n) {        vector<int> dp(n+1);        dp[2] = 1;        for(int i = 3; i <= n; i++){            for (int j = 2; j < i; j++){                dp[i] = max(dp[i],max(dp[i - j] * j, (i - j) * j));            }        }        return dp[n];    }};</code></pre><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接(opens new window)</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的<strong>二叉搜索树</strong>有多少种？</p><p>思路：</p><p><img src="/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230310111953290.png" alt="image-20230310111953290"> </p><p>dp[3] = dp[0]dp[2] + dp[1]dp[1]+dp[2]dp[0];</p><p>节点的数值其实关系不大，只要每个值不一样就行；</p><p>dp[i] += dp[j - 1] * dp[i - j];</p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numTrees(int n) {        vector<int> dp(n+1);        dp[0] = 1;        dp[1] = 1;        for(int i = 2; i <= n; i++){            for(int j = 1; j <= i; j++){                dp[i] += dp[j - 1] * dp[i - j];            }        }        return dp[n];    }};</code></pre><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有N件物品和⼀个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p><p>例：</p><p>背包最⼤重量为4。<br>              重量    价值<br>物品0      1          15<br>物品1      3          20<br>物品2      4          30</p><p>思路：</p><h4 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h4><p>对于背包问题，有⼀种写法， 是使⽤<strong>⼆维数组</strong>，即<code>dp[i] [j]</code> 表⽰从下标为<code>[0-i]</code>的物品⾥任意取，放进容量为<code>j</code>的背包，价值总和最⼤是多少。</p><p>不放物品i:  <code>dp[i-1] [j]</code></p><p>放物品i:<code>dp[i-1] * [j - weight[ i ]] + value[ i ]</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//测试代码void test_2_wei_bag_problem1() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    int bagweight = 4;    // 二维数组    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));    // 初始化    for (int j = weight[0]; j <= bagweight; j++) {        dp[0][j] = value[0];    }    // weight数组的大小 就是物品个数    for(int i = 1; i < weight.size(); i++) { // 遍历物品        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量            if (j < weight[i]) dp[i][j] = dp[i - 1][j];            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);        }    }    cout << dp[weight.size() - 1][bagweight] << endl;}int main() {    test_2_wei_bag_problem1();}</code></pre><h4 id="一维dp数组——用物品去遍历不同重量的背包"><a href="#一维dp数组——用物品去遍历不同重量的背包" class="headerlink" title="一维dp数组——用物品去遍历不同重量的背包"></a>一维dp数组——用物品去遍历不同重量的背包</h4><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[ i-1 ] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p><strong>所以递归公式为：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></pre><p>一维dp数组<strong>遍历顺序</strong>比较固定：</p><ul><li>物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历</li></ul><p>注意：</p><ul><li>若先遍历重量，则每个重量的背包只放了一个物品</li><li>若正序遍历重量，则存在物品被放置多次的现象</li></ul><p>代码如下：</p><pre class=" language-lang-text"><code class="language-lang-text">for(int i = 0; i < weight.size(); i++) { // 遍历物品    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);    }}</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_1_wei_bag_problem() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    int bagWeight = 4;    // 初始化    vector<int> dp(bagWeight + 1, 0);    for(int i = 0; i < weight.size(); i++) { // 遍历物品        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);        }    }    cout << dp[bagWeight] << endl;}int main() {    test_1_wei_bag_problem();}</code></pre><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接(opens new window)</a></p><p>题目难易：中等</p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100， 数组的大小不会超过 200</p><p>示例 1:</p><ul><li>输入: [1, 5, 11, 5]</li><li>输出: true</li><li>解释: 数组可以分割成 [1, 5, 5] 和 [11].</li></ul><p>转换：</p><p>背包最⼤重量为11。<br>              重量    价值<br>物品0      1          1<br>物品1      5          5<br>物品2     11        11<br>物品3      5          5</p><p>思路：</p><p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为target = sum / 2</li><li>背包要放入的商品（集合里的元素）<strong>重量为 元素的数值</strong>，<strong>价值也为元素的数值</strong></li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。即寻找dp[target] == target</li><li>背包中每一个元素是不可重复放入。</li></ul><p>我的：</p><p>背包能放的最大价值（等价于最大重量），就是刚好放满</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canPartition(vector<int>& nums) {        int sum = 0;        // dp[j]容量为j的背包，所背的物品价值可以最大为dp[j]。        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了        vector<int> dp(10001, 0);        for (int i = 0; i < nums.size(); i++) {            sum += nums[i];        }        // 也可以使用库函数一步求和        // int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum % 2 == 1) return false;        int target = sum / 2;        // 开始 01背包        for(int i = 0; i < nums.size(); i++) {            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);                if (dp[target] == target) return true;            }        }        // // 集合中的元素正好可以凑成总和target        // if (dp[target] == target) return true;        return false;    }};</code></pre><h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h2><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接(opens new window)</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；</p><p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例：</p><ul><li>输入：[2,7,4,1,8,1]</li><li>输出：1</li></ul><p>解释：</p><ul><li><p>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</p></li><li><p>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</p></li><li><p>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</p></li><li><p>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p></li></ul><p>思路：</p><p>本题其实就是<strong>尽量</strong>让石头<strong>分成重量相同的两堆</strong>，相撞之后剩下的石头最小</p><ol><li><p>dp数组含义：dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背的最大重量</p></li><li><p>递推公式：<strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li>初始化： dp的size初始化为最大重量，value初始化为0；<code>vector&lt;int&gt; dp(15001, 0);</code></li><li>确定遍历顺序：同01背包</li><li>举例推导dp数组</li></ol><p>最后dp[target]里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。<strong>target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>所以<code>return sum - dp[target] - dp[target];</code></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int lastStoneWeightII(vector<int>& stones) {        vector<int> dp(15001,0);        int sum = 0;        for (int i = 0; i < stones.size(); i++) {            sum += stones[i];        }        int target = sum / 2;        //先遍历物品，再遍历容量        for(int i = 0; i < stones.size(); i++){            for(int j = target; j >= stones[i]; j--){                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);            }        }        return sum - dp[target] - dp[target];    }};</code></pre><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接(opens new window)</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><ul><li>输入：nums: [1, 1, 1, 1, 1], S: 3</li><li>输出：5</li></ul><p>解释：</p><ul><li>-1+1+1+1+1 = 3</li><li>+1-1+1+1+1 = 3</li><li>+1+1-1+1+1 = 3</li><li>+1+1+1-1+1 = 3</li><li>+1+1+1+1-1 = 3</li></ul><p>思路：</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = target</p><p>x = (target + sum) / 2</p><ol><li>dp数组含义：dp[j]表示填满容积为j的背包，有多少种组合</li><li></li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findTargetSumWays(vector<int>& nums, int S) {        int sum = 0;        for (int i = 0; i < nums.size(); i++) sum += nums[i];        if (abs(S) > sum) return 0; // 此时没有方案        if ((S + sum) % 2 == 1) return 0; // 此时没有方案        int bagSize = (S + sum) / 2;        vector<int> dp(bagSize + 1, 0);        dp[0] = 1;        for (int i = 0; i < nums.size(); i++) {            for (int j = bagSize; j >= nums[i]; j--) {                dp[j] += dp[j - nums[i]];            }        }        return dp[bagSize];    }};</code></pre><p>记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] += dp[j - nums[i]];</code></pre><h2 id="474-一和零——二维背包"><a href="#474-一和零——二维背包" class="headerlink" title="474.一和零——二维背包"></a>474.一和零——二维背包</h2><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 ：</p><ul><li>输入：strs = [“10”, “0”, “1”], m = 1, n = 1</li><li>输出：2</li><li>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</li></ul><p><strong>思路：</strong></p><p>二维背包</p><ol><li>dp：<strong>最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]</strong>。</li><li>递推公式：dp [i] [j] 可以由前一个strs里的字符串推导出来，当前str里的字符串有zeroNum个0，oneNum个1（其实就相当于重量）。dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</li><li>初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</li><li><strong>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历</strong></li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findMaxForm(vector<string>& strs, int m, int n) {        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0        for (string str : strs) { // 遍历物品            int oneNum = 0, zeroNum = 0;            for (char c : str) {                if (c == '0') zeroNum++;                else oneNum++;            }            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！                for (int j = n; j >= oneNum; j--) {                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);                }            }        }        return dp[m][n];    }};</code></pre><h2 id="动态规划：完全背包理论基础"><a href="#动态规划：完全背包理论基础" class="headerlink" title="动态规划：完全背包理论基础"></a>动态规划：完全背包理论基础</h2><p>完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 先遍历物品，再遍历背包（这个顺序可以调换，但是有区别）for(int i = 0; i < weight.size(); i++) { // 遍历物品    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);    }}</code></pre><h2 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a>518.零钱兑换II</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">力扣题目链接(opens new window)</a></p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><ul><li>输入: amount = 5, coins = [1, 2, 5]</li><li>输出: 4</li></ul><p>解释: 有四种方式可以凑成总金额:</p><ul><li>5=5</li><li>5=2+2+1</li><li>5=2+1+1+1</li><li>5=1+1+1+1+1</li></ul><p>思路：</p><p>背包容量为5，要刚好装满；硬币面额相当于物体重量</p><ol><li>dp[j]：背包容量为j，能装满的<strong>最大方式数</strong></li><li>递推公式   dp[j] += dp[j-coins[i]]</li><li>初始化</li><li>遍历顺序</li></ol><p>我的：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int change(int amount, vector<int>& coins) {        vector<int> dp(amount + 1,0);        dp[0] = 1;        for(int i = 0; i < coins.size(); i++){            for(int j = coins[i]; j <= amount; j++){                dp[j] += dp[j-coins[i]];            }        }        return dp[amount];    }};</code></pre><p><strong>注意：</strong></p><p>本题要求凑成总和的<strong>组合数</strong>，元素之间明确要求<strong>没有顺序</strong>。纯完全背包是能凑成总和就行，不用管怎么凑的。</p><p>所以本题要 ：<strong>先遍历物品再遍历容量，计算的是组合数</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 0; i < coins.size(); i++) { // 遍历物品    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量        dp[j] += dp[j - coins[i]];    }}</code></pre><p>而先遍历容量再遍历物体，计算的是<strong>排列数</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int j = 0; j <= amount; j++) { // 遍历背包容量    for (int i = 0; i < coins.size(); i++) { // 遍历物品        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];    }}</code></pre><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h2><p><a href="https://leetcode.cn/problems/combination-sum-iv/">力扣题目链接(opens new window)</a></p><p>难度：中等</p><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><ul><li>nums = [1, 2, 3]</li><li>target = 4</li></ul><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7</p><p><strong>思路：</strong></p><p>多重背包问题，求排列数</p><ol><li>dp[j]  :  刚好装满容量为j的背包的最大排列数</li><li>dp[j] += dp[j - nums[i]]</li><li>dp[0] = 1</li><li>先遍历背包，再遍历物品</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int combinationSum4(vector<int>& nums, int target) {        vector<int> dp(target + 1, 0);        dp[0] = 1;        for(int j = 0; j <= target; j++){            for(int i = 0; i < nums.size(); i++){// C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[j] < INT_MAX - dp[j - nums[i]]。这里省去了。ps：数量类型改成longlong还是会超                if (j - nums[i] >= 0) dp[j] += dp[j - nums[i]];            }        }        return dp[target];    }};</code></pre><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/">力扣题目链接(opens new window)</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><ul><li>输入：coins = [1, 2, 5], amount = 11</li><li>输出：3</li><li>解释：11 = 5 + 5 + 1</li></ul><p>思路：</p><p>完全背包，求<strong>最少</strong>硬币数</p><p><strong>本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓</strong></p><p>dp[j] 装满背包容量为j的最少硬币数 </p><p>凑足总金额为0所需钱币的个数一定是0，那么<strong>dp[0] = 0;</strong> (为什么不是和求最大数量一样dp[0]=1)</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int coinChange(vector<int>& coins, int amount) {        vector<int> dp(amount + 1, INT_MAX);        dp[0] = 0;        for (int i = 0; i < coins.size(); i++) { // 遍历物品            for (int j = coins[i]; j <= amount; j++) { // 遍历背包                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过,因为+1会溢出，而且最小值还是不变                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);                }            }        }        if (dp[amount] == INT_MAX) return -1;        return dp[amount];    }};</code></pre><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/">力扣题目链接(opens new window)</a></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1：</p><ul><li>输入：n = 12</li><li>输出：3</li><li>解释：12 = 4 + 4 + 4</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int numSquares(int n) {        vector<int> dp(n+1, INT_MAX);        dp[0] = 0;        for(int i = 1; i <= n; i++){ // i=0也可以，但是没有意义，不会改变结果            for(int j = i*i; j <= n; j++){                if(dp[j - i*i] != INT_MAX){                    dp[j] = min(dp[j], dp[j - i*i] + 1);                }            }        }        //if (dp[n] == INT_MAX) return -1; 由于该问题一定有解，所以加不加这个都行        return dp[n];    }};</code></pre><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/">力扣题目链接(opens new window)</a></p><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1：</p><ul><li>输入: s = “leetcode”, wordDict = [“leet”, “code”]</li><li>输出: true</li><li>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</li></ul><p>思路：</p><p>完全背包求排列，先遍历背包再遍历物品      单词就是物品，字符串s就是背包</p><p>dp[j]: 长度为j的背包s刚好能被单词装满</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool wordBreak(string s, vector<string>& wordDict) {        unordered_set <string> wordSet(wordDict.begin(), wordDict.end());        vector<bool> dp(s.size() + 1, false);        dp[0] = true;        for (int i = 1; i <= s.size(); i++) {   // 遍历背包            for (int j = 0; j < i; j++) {       // 遍历物品                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)                if (wordSet.find(word) != wordSet.end() && dp[j] == true) {                    dp[i] = true;                }            }        }        return dp[s.size()];    }};</code></pre><p>or 可以把unordered_set改成用find()函数</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool wordBreak(string s, vector<string>& wordDict) {        int n = s.size();        vector<bool> dp(n + 1, false);        dp[0] = true;        for (int i = 1; i <= n; i++) {            for (int j = 0; j < i; j++) {                if (dp[j] && find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {                    dp[i] = true;                    break;                }            }        }        return dp[n];    }};</code></pre><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>每种物品数量有限(1&lt;= 数量 &lt; 无穷)</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_multi_pack() {    vector<int> weight = {1, 3, 4};    vector<int> value = {15, 20, 30};    vector<int> nums = {2, 3, 2};    int bagWeight = 10;    vector<int> dp(bagWeight + 1, 0);    for(int i = 0; i < weight.size(); i++) { // 遍历物品        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量            // 以上为01背包，然后加一个遍历个数 ！！！            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);            }        }        // 打印一下dp数组        for (int j = 0; j <= bagWeight; j++) {            cout << dp[j] << " ";        }        cout << endl;    }    cout << dp[bagWeight] << endl;}int main() {    test_multi_pack();}</code></pre><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/">力扣题目链接(opens new window)</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><ul><li>示例 1：</li><li>输入：[1,2,3,1]</li><li>输出：4</li></ul><p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。</p><p>思路：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p><ol><li>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</li><li>dp[0] = nums[0]   dp[1]  = max(nums[1], nums[0])</li><li>从前向后遍历</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(vector<int>& nums) {        if (nums.size() == 0) return 0;        if (nums.size() == 1) return nums[0];        vector<int> dp(nums.size(), 0);        dp[0] = nums[0];        dp[1] = max(nums[0],nums[1]);        for (int i = 2; i < nums.size(); i++){            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);        }        return dp[nums.size() - 1];    }};</code></pre><h2 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h2><p><a href="https://leetcode.cn/problems/house-robber-ii/">力扣题目链接</a></p><p>相对上一题添加条件： 房间成环，即第一个房间和最后一个房间挨着</p><p>思路:</p><p>考虑两种情况：考虑包含首元素，不包含尾元素；  考虑包含尾元素，不包含首元素</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(vector<int>& nums) {        if (nums.size() == 0) return 0;        if (nums.size() == 1) return nums[0];        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三        return max(result1, result2);    }    // 198.打家劫舍的逻辑    int robRange(vector<int>& nums, int start, int end) {        if (end == start) return nums[start];        vector<int> dp(nums.size());        dp[start] = nums[start];        dp[start + 1] = max(nums[start], nums[start + 1]);        for (int i = start + 2; i <= end; i++) {            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);        }        return dp[end];    }};</code></pre><h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h2><p><a href="https://leetcode.cn/problems/house-robber-iii/">力扣题目链接</a></p><p>这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>思路：</p><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p><p>关键是要讨论当前节点抢还是不抢。如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子</p><ol><li><p>确定递归函数的参数和返回值</p><p> 参数为当前节点，代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> vector<int> robTree(TreeNode* cur) {</code></pre><p> 其实这里的返回数组就是dp数组。</p><p> 所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p></li><li><p>终止条件<code>if (cur == NULL) return vector&lt;int&gt;{0, 0};</code></p></li><li><p>确定遍历顺序</p><p> 首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p> 通过递归左节点，得到左节点偷与不偷的金钱。</p><p> 通过递归右节点，得到右节点偷与不偷的金钱。</p><p> 代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> // 下标0：不偷，下标1：偷 vector<int> left = robTree(cur->left); // 左 vector<int> right = robTree(cur->right); // 右 // 中</code></pre></li><li><p>确定单层递归的逻辑</p><p> 当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><pre class=" language-lang-cpp"><code class="language-lang-cpp"> int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷 int val1 = cur->val + left[0] + right[0]; //偷 return {val0,val1};</code></pre></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int rob(TreeNode* root) {        vector<int> result = robTree(root);        return max(result[0],result[1]);    }    vector<int> robTree(TreeNode* cur) {        if (cur == NULL) return vector<int>{0, 0};        vector<int> left = robTree(cur->left);        vector<int> right = robTree(cur->right);        int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷        int val1 = cur->val + left[0] + right[0]; //偷        return {val0,val1};    }};</code></pre><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">力扣题目链接(opens new window)</a></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>思路：</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p> dp[i] [0] 表示第i天持有股票所得最多现金 </p><p> dp[i] [1] 表示第i天不持有股票所得最多现金</p></li><li><p>确定递推公式</p><p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li><li><p>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</p><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p></li><li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p></li><li><p>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p><p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p></li></ul></li><li><p>初始化</p><p> dp[0] [0]  = - prices[0]</p><p> dp[0] [1] = 0</p></li><li><p>遍历顺序从前到后</p><p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        if(prices.size() == 1) return 0;        vector<vector<int>> dp(prices.size(),vector<int>(2)); //注意vector<int>(2) ！        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i < prices.size(); i++){            dp[i][0] = max(dp[i - 1][0], -prices[i]);            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        }        return dp[prices.size()-1][1];    }};</code></pre><p>用滚动数组优化，节省空间复杂度：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本二class Solution {public:    int maxProfit(vector<int>& prices) {        int len = prices.size();        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组        dp[0][0] -= prices[0];        dp[0][1] = 0;        for (int i = 1; i < len; i++) {            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);        }        return dp[(len - 1) % 2][1];    }};</code></pre><h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接(opens new window)</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p>思路:</p><ol><li><p>确定dp数组（dp table）以及下标的含义</p><p> dp[i] [0] 表示第i天持有股票所得最多现金 </p><p> dp[i] [1] 表示第i天不持有股票所得最多现金</p></li><li><p>确定递推公式</p><p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p><ul><li><p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</p></li><li><p>第i-1天不持有股票，第i天买入股票，<strong>所得现金就是买入今天股票花的钱加上之前赚的钱</strong>：    </p><p>  <strong>dp[i - 1] [1]</strong> - prices[i]</p><p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], <strong>dp[i - 1] [1]</strong> - prices[i]); </p><p><strong>！！！加粗部分为和上一题唯一的不同</strong></p><p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p></li><li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p></li><li><p>第i-1天持有股票，第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p><p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p></li></ul></li><li><p>初始化</p><p> dp[0] [0]  = - prices[0]</p><p> dp[0] [1] = 0</p></li><li><p>遍历顺序从前到后</p><p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        if(prices.size() == 1) return 0;        vector<vector<int>> dp(prices.size(),vector<int>(2));        dp[0][0] = -prices[0];        dp[0][1] = 0;        for(int i = 1; i < prices.size(); i++){            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]-prices[i]); // 唯一不同            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);        }        return dp[prices.size()-1][1];    }};</code></pre><h2 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">力扣题目链接(opens new window)</a></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。</p><p>思路：</p><ol><li><p>确定dp数组以及下标的含义</p><p> 一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态）</li><li>第一次持有股票</li><li>第一次不持有股票</li><li>第二次持有股票</li><li><p>第二次不持有股票</p><p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j所剩最大现金。</p></li></ol></li><li><p>确定递推公式</p></li></ol><p>达到dp[i] [1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i] [1] = dp[i-1] [0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] = dp[i - 1] [1]</li></ul><p>一定是选最大的，所以 dp[i] [1] = max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        int len = prices.size();        if(len == 1) return 0;        vector<vector<int>> dp(len,vector<int>(5));        dp[0][0] = 0;        dp[0][1] = -prices[0];        dp[0][2] = 0;        dp[0][3] = -prices[0];        dp[0][4] = 0;        for(int i = 1; i < len; i++){            dp[i][0] = dp[i - 1][0]; //这个其实一直是0            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); //第一次不买or买            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); //第一次不卖or卖            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);        }        return dp[len-1][4];    }};</code></pre><h2 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">力扣题目链接</a></p><p>最多可以完成K笔交易</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(int k, vector<int>& prices) {        if (prices.size() == 0) return 0;        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));        for (int j = 1; j < 2 * k; j += 2) {            dp[0][j] = -prices[0];        }        for (int i = 1;i < prices.size(); i++) {            for (int j = 0; j < 2 * k - 1; j += 2) {                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);            }        }        return dp[prices.size() - 1][2 * k];    }};</code></pre><h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例:</p><ul><li>输入: [1,2,3,0,2]</li><li>输出: 3</li><li>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li></ul><p>思路：</p><ol><li><p>确定dp数组以及下标的含义</p><p> dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p><p> 具体可以区分出如下四个状态：</p></li></ol><ul><li>状态0：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态1：结束冷冻期的状态（前一天是冷冻期。或者是前几天是冷冻期）</li><li>状态2：今天卖出股票</li></ul></li><li>状态3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices) {        int n = prices.size();        if (n == 0) return 0;        vector<vector<int>> dp(n, vector<int>(4, 0));        dp[0][0] -= prices[0]; // 持股票        for (int i = 1; i < n; i++) {            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);            dp[i][2] = dp[i - 1][0] + prices[i];            dp[i][3] = dp[i - 1][2];        }        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));    }};</code></pre><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>思路：</p><p>dp[i] [j]</p><p>0: 持有股票 dp[i] [0] :  dp [i-1] [0]     dp[i-1] [1] - prices[i] </p><p>1：不持有股票 dp[i] [1]: dp[i-1] [1]     dp[i-1] [0] + prices[i] - fee  卖出的时候再扣手续费</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxProfit(vector<int>& prices, int fee) {        int n = prices.size();        if (n == 0) return 0;        vector<vector<int>> dp(n, vector<int>(2, 0));        dp[0][0] -= prices[0]; // 持股票        for (int i = 1; i < n; i++) {            dp[i][0] = max(dp [i-1][0], dp[i-1][1] - prices[i]);            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]- fee);        }        return dp[n-1][1];//题解这里用的max(dp[n - 1][0], dp[n - 1][1]);感觉不太对，一定是不持股的时候钱多；    }};</code></pre><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">力扣题目链接(opens new window)</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><ul><li>输入：nums = [10,9,2,5,3,7,101,18]</li><li>输出：4</li><li>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</li></ul><p><strong>子序列问题是动态规划的一个重要系列</strong></p><p>思路：</p><ol><li><p>dp[i]的定义</p><p> dp[i]表示以<strong>nums[i]结尾</strong>的最长递增子序列的长度</p><p> 因为比较递增，那么一定是比较最后一个数字的大小</p></li><li><p>状态转移方程</p><p> 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p> 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p></li><li><p>dp[i]的初始化</p><p> 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p></li><li><p>确定遍历顺序</p><p> 从前向后遍历。</p></li></ol><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int lengthOfLIS(vector<int>& nums) {        if (nums.size() <= 1) return nums.size();        vector<int> dp(nums.size(), 1);        int result = 0;        for (int i = 1; i < nums.size(); i++) {            for (int j = 0; j < i; j++) {                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);            }            result = max(result, dp[i]); // 取长的子序列        }        return result;    }};</code></pre><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">力扣题目链接(opens new window)</a></p><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1：</p><ul><li>输入：nums = [1,3,5,4,7]</li><li>输出：3</li><li>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findLengthOfLCIS(vector<int>& nums) {        if(nums.size() == 0) return 0;        int n = nums.size();        int result = 1;        vector<int> dp(n, 1);        for(int i = 1; i < n; i++){            if(nums[i] > nums[i - 1]){                dp[i] = dp[i-1] + 1;            }            result = max(result,dp[i]);        }        return result;    }};</code></pre><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">力扣题目链接(opens new window)</a></p><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例：</p><p>输入：</p><ul><li>A: [1,2,3,2,1]</li><li>B: [3,2,1,4,7]</li><li>输出：3</li><li>解释：长度最长的公共子数组是 [3, 2, 1] 。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] ：以下标i为结尾的A，和以下标j为结尾的B，最长重复子数组长度为dp[i][j]//if(nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;//dp[0][j] class Solution {public:    int findLength(vector<int>& nums1, vector<int>& nums2) {        int n1 = nums1.size();        int n2 = nums2.size();        int result = 0;        vector<vector<int>> dp(n1,vector<int>(n2,0));        // 要对第一行，第一列经行初始化        for (int i = 0; i < nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;        for (int j = 0; j < nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1;        for (int i = 0; i < nums1.size(); i++) {            for (int j = 0; j < nums2.size(); j++) {                if(nums1[i] == nums2[j] && i > 0 && j >0) dp[i][j] = dp[i-1][j-1] + 1;                result = max(result,dp[i][j]);            }        }        return result;    }};</code></pre><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">力扣题目链接(opens new window)</a></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]//if(text1[i-1] == text2[i-1])  dp[i][j] = dp[i-1][j-1] + 1;//else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);class Solution {public:    int longestCommonSubsequence(string text1, string text2) {        int n1 = text1.size();        int n2 = text2.size();        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));        for (int i = 1; i <= text1.size(); i++) {            for (int j = 1; j <= text2.size(); j++) {                if (text1[i - 1] == text2[j - 1]) {                    dp[i][j] = dp[i - 1][j - 1] + 1;                } else {                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);                }            }        }        return dp[n1][n2];    }};</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxSubArray(vector<int>& nums) {        int n = nums.size();        vector<int> dp(n);        dp[0] = nums[0];        int result = dp[0];        for(int i = 1; i < n; i++){            dp[i] = max(dp[i - 1] + nums[i], nums[i]);            result = max(result, dp[i]);         }        return result;    }};</code></pre><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h2><p><a href="https://leetcode.cn/problems/is-subsequence/">力扣题目链接(opens new window)</a></p><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p><p>示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false</p><p>可以发现和 <a href="https://programmercarl.com/1143.最长公共子序列.html">1143.最长公共子序列 (opens new window)</a>的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isSubsequence(string s, string t) {        int n1 = s.size();        int n2 = t.size();        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));        for (int i = 1; i <= n1; i++) {            for (int j = 1; j <= n2; j++) {                if (s[i - 1] == t[j - 1]) {                    dp[i][j] = dp[i - 1][j - 1] + 1;                } else {                    dp[i][j] = dp[i][j-1];                }            }        }        return dp[n1][n2] == n1;    }};</code></pre><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。class Solution {public:    int numDistinct(string s, string t) {        int n1 = s.size();        int n2 = t.size();        vector<vector<uint64_t>> dp(n1+1,vector<uint64_t> (n2+1,0));        for (int i = 0; i <= n1; i++) dp[i][0] = 1;        for(int i = 1; i <= n1; i++){            for(int j = 1; j <= n2; j++){                // dp[i-1][j] 不用 s的最后一位 来匹配                // dp[i-1][j-1]表示s和t最后一位已经匹配，                if(s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j];                else dp[i][j] = dp[i-1][j];            }        }        return dp[n1][n2];       }};</code></pre><h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h2><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">力扣题目链接(opens new window)</a></p><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><p>示例：</p><ul><li>输入: “sea”, “eat”</li><li>输出: 2</li><li>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//求最长公共子序列class Solution {public:    int minDistance(string word1, string word2) {        int n1 = word1.size();        int n2 = word2.size();        vector<vector<int>> dp(n1 + 1, vector<int> (n2 + 1, 0));        for(int i = 1; i <= n1; i++){            for(int j = 1; j <= n2; j++){                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            }         }        return n1+n2-2*dp[n1][n2];    }};</code></pre><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p><a href="https://leetcode.cn/problems/edit-distance/">力扣题目链接(opens new window)</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 长度为i的word1 转换成 长度为j的word2 所使用的最少操作数// 插：word2删1  删：word1删1  换：都删1class Solution {public:    int minDistance(string word1, string word2) {        int l1 = word1.size();        int l2 = word2.size();        vector<vector<int>> dp(l1 + 1, vector<int>(l2 + 1, 0));        for(int i = 0; i <= l1; i++) dp[i][0] = i;        for(int j = 0; j <= l2; j++) dp[0][j] = j;        for (int i = 1; i <= l1; i++) {            for (int j = 1; j <= l2; j++) {                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];                else {                    int n1 = dp[i-1][j] + 1;                    int n2 = dp[i][j-1] + 1;                    int n3 = dp[i-1][j-1] + 1;                    dp[i][j] = min(min(n1,n2),n3);                }            }        }        return dp[l1][l2];    }};</code></pre><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><ul><li>输入：”abc”</li><li>输出：3</li><li>解释：三个回文子串: “a”, “b”, “c”</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。//dp[i + 1][j - 1] 在 dp[i][j]的左下角 ,要从左下开始遍历，顺序是从下到上，从左到右。class Solution {public:    int countSubstrings(string s) {        int n = s.size();        int result = 0;        vector<vector<int>> dp(n,vector<int>(n,0));        // dp[0][0] = 1;        for(int i = n-1; i >= 0; i--){            for(int j = i; j < n; j++){                if(s[i] != s[j]) dp[i][j] = 0;                else{                    if(i == j) {                        dp[i][j] = 1;                        result++;                    }                    else if(j-i == 1) {                        dp[i][j] = 1;                        result++;                    }                    else {                        if(dp[i+1][j-1]){                            dp[i][j] = 1;                            result++;                        }                    }                }            }        }        return result;    }};</code></pre><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p><p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 表示s[i,j] 最长的回文子串//画图理解  i表示行，j表示列class Solution {public:    int longestPalindromeSubseq(string s) {        int n = s.size();        int result = 0;        vector<vector<int>> dp(n,vector<int>(n,0));        for(int i = n-1; i >= 0; i--){            for(int j = i; j < n; j++){                if(s[i] == s[j]) {                    if(i == j) dp[i][j] = 1;                    else if(j-i == 1) dp[i][j] = 2;                    else dp[i][j] = dp[i+1][j-1] + 2;                }else{                    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);                }            }        }        return dp[0][n-1];    }};</code></pre>]]></content>
    
    
    <summary type="html">动态规划基础知识
动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

动规五部曲：

 1. 确定dp数组（dp table）以及下标的含义
 2. 确定递推公式
 3. dp数组如何初始化
 4. 确定遍历顺序
 5. 举例推导dp数组

509. 斐波那契数
力扣题目链接(opens new window)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:57.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接(opens new window)</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverseString(vector<char>& s) {        char temp;        int left = 0;        int right = s.size() - 1;        while(left < right){            temp = s[right];            s[right] = s[left];            s[left] = temp;            left++;            right--;        }    }};</code></pre><p>解析答案：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void reverseString(vector<char>& s) {    for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {        swap(s[i],s[j]); //注意何时使用库函数    }}</code></pre><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseStr(string s, int k) {        for(int i = 0; i < s.size(); i = i + 2*k){            if(i + k > s.size()) reverse(s.begin()+i,s.end());            else reverse(s.begin()+i,s.begin()+i+k);        }        return s;    }    //也可自己构造reverse,但要记住官方的reverse是左闭右开    // void reverse_me(string& s, int start, int end) {    //     for (int i = start, j = end+1; i < j; i++, j--) {    //         swap(s[i], s[j-1]);    //     }    // }};</code></pre><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">力扣题目链接(opens new window)</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>思路：</strong></p><p>首先扩充数组到每个空格替换成”%20”之后的大小。</p><p>然后从后向前替换空格，也就是双指针法</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string replaceSpace(string s) {        int length = s.size();        for(int i = 0; i < s.size(); i++){            if(s[i] == ' '){                length = length + 2;            }        }        int left = s.size() - 1;        int right = length - 1;        s.resize(length);        while(left >= 0){            if(s[left] == ' '){                s[right] = '0';                s[right-1] = '2';                s[right-2] = '%';                right = right - 3;            }else{                s[right] = s[left];                right--;             }            left--;        }        return s;    }};</code></pre><h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词*"></a>翻转字符串里的单词*</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接(opens new window)</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good  example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><strong>思路：</strong></p><p>若要不额外占用空间，首先去除多余空格，再翻转整个字符串，再用双指针翻转每个单词</p><p><strong>我的：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseWords(string s) {        //双指针去除多余空格        int a = 0,b = 0;        while(a == 0 && s[b] == ' ') b++;        for(;b < s.size(); b++){            if(s[b] == ' ' && (s[b+1] == ' ' || b+1 >= s.size())) continue;             else {                s[a] = s[b];                a++;            }        }        s.resize(a);        //翻转字符串        reverse(s,0,s.size());        //双指针翻转每个单词        for(int c = 0,d = 0; d <= s.size(); d++){            if(s[d] == ' '|| d == s.size()){                reverse(s,c,d);                c = d + 1;            }        }        return s;    }    //左闭右开    void reverse(string& s, int start, int end) {        for (int i = start, j = end-1; i < j; i++, j--) {            swap(s[i], s[j]);        }    }};</code></pre><p><strong>题解：</strong></p><p><a href="https://www.cnblogs.com/zou-ma/p/16162731.html">https://www.cnblogs.com/zou-ma/p/16162731.html</a> </p><p>在 for 循环中，<code>i++</code>和 <code>++i</code>是一样一样的，但是<code>++i</code>的循环耗时短。</p><p>使用<code>++i</code>是一定程度上的系统优化</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []        for (int i = start, j = end; i < j; i++, j--) {            swap(s[i], s[j]);        }    }    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html        for (int i = 0; i < s.size(); ++i) { //            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。                    s[slow++] = s[i++];                }            }        }        s.resize(slow); //slow的大小即为去除多余空格后的大小。    }    string reverseWords(string s) {        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。        reverse(s, 0, s.size() - 1);        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。        for (int i = 0; i <= s.size(); ++i) {            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。                start = i + 1; //更新下一个单词的开始下标start            }        }        return s;    }};</code></pre><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接(opens new window)</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><p><strong>题解：</strong></p><p>整体反转+局部反转就可以实现反转单词顺序的目的</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string reverseLeftWords(string s, int n) {        reverse(s.begin(),s.end());        reverse(s.begin(),s.end()-n);        reverse(s.end()-n,s.end());        return s;    }};</code></pre><h2 id="实现-strStr-——KMP算法"><a href="#实现-strStr-——KMP算法" class="headerlink" title="实现 strStr()——KMP算法"></a>实现 strStr()——KMP算法</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">力扣题目链接(opens new window)</a></p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h4 id="kmp算法："><a href="#kmp算法：" class="headerlink" title="kmp算法："></a>kmp算法：</h4><p>那么使用KMP可以解决两类经典问题：</p><ol><li>匹配问题：<a href="https://programmercarl.com/0028.实现strStr.html">28. 实现 strStr()(opens new window)</a></li><li>重复子串问题：<a href="https://programmercarl.com/0459.重复的子字符串.html">459.重复的子字符串</a></li></ol><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><p>文本串：aabaabaaf</p><p>模式串：aabaaf</p><p>next数组就是一个前缀表（prefix table），即最长相等前后缀</p><p>前缀：包含首字母，不包含尾字母的所有子串</p><p>后缀：包含尾字母，不包含首字母的所有子串</p><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>前缀表的求法：</p><p><img src="/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20230212143008343.png" alt="image-20230212143008343" style="zoom: 25%;"></p><p>遇见冲突后找冲突的前一位所对应的前缀表，再从前缀表所对下标处继续匹配</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p><p>初始化： j 指向前缀末尾位置（也是当前公共前后缀的长度）   i 指向后缀末尾位置</p><p>前后缀不相同</p><p>前后缀相同</p><p>更新next数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext(int* next, const string& s) {        //初始化        int j = 0;        next[0] = 0;        // 相等就加（(i 和 j 都得加，而j加1后刚好等于当前i对应的next)，不相等就回溯;先考虑不相等的情况        for(int i = 1; i < s.size(); i++) {            while (j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if (s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    int strStr(string haystack, string needle) {        if (needle.size() == 0) {            return 0;        }        int next[needle.size()];        getNext(next, needle);        int j = 0;        for (int i = 0; i < haystack.size(); i++) {            while(j > 0 && haystack[i] != needle[j]) {                j = next[j - 1];            }            if (haystack[i] == needle[j]) {                j++;            }            if (j == needle.size() ) {                return (i - needle.size() + 1);            }        }        return -1;    }};</code></pre><h1 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接(opens new window)</a></p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><p><strong>思路：</strong></p><p>字符串s：abcabc</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" alt="图二"></p><p>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>我的思路：可用上题的strStr()找</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">    bool repeatedSubstringPattern(string s) {        string t = s + s;        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾        if(strStr(t,s) != -1) return true;        return false;    }</code></pre><p>用KMP算法：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728212157.png" alt="图四" style="zoom:50%;"></p><p>如果len % (len - (next[len - 1])) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void getNext (int* next, const string& s){        next[0] = 0;        int j = 0;        for(int i = 1;i < s.size(); i++){            while(j > 0 && s[i] != s[j]) {                j = next[j - 1];            }            if(s[i] == s[j]) {                j++;            }            next[i] = j;        }    }    bool repeatedSubstringPattern(string s) {        int len = s.size();        int next[len];        getNext(next, s);        if(next[len - 1] != 0 && len % (len - (next[len - 1])) == 0) return true;        else return false;    }};</code></pre>]]></content>
    
    
    <summary type="html">反转字符串
力扣题目链接(opens new window)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：[“h”,”e”,”l”,”l”,”o”]
输出：[“o”,”l”,”l”,”e”,”h”]

示例 2：
输入：[“H”,”a”,”n”,”n”,”a”,”h”]
输出：[“h”,”a”,”n”,”n”,”a”,”H”]

class Solutio</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E6%95%B0%E7%BB%84/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-08T11:02:21.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>坚持<strong>左闭右闭or左闭又开</strong><ul><li>while(left &lt;= right)  or  while(left &lt; right)</li></ul></li><li>比较left、middle和right三个值</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本一class Solution {public:    int search(vector<int>& nums, int target) {        int left = 0;        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2            if (nums[middle] > target) {                right = middle - 1; // target 在左区间，所以[left, middle - 1]            } else if (nums[middle] < target) {                left = middle + 1; // target 在右区间，所以[middle + 1, right]            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本二class Solution {public:    int search(vector<int>& nums, int target) {        int left = 0;        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <            int middle = left + ((right - left) >> 1);            if (nums[middle] > target) {                right = middle; // target 在左区间，在[left, middle)中            } else if (nums[middle] < target) {                left = middle + 1; // target 在右区间，在[middle + 1, right)中            } else { // nums[middle] == target                return middle; // 数组中找到目标值，直接返回下标            }        }        // 未找到目标值        return -1;    }};</code></pre><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p><p><strong>双指针法（快慢指针法</strong>）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</p><ul><li>快指针：寻找不等于有目标元素的值 （通常快指针就是for循环里面的索引）</li><li>慢指针：指向新数组最后一个下标的位置</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">        for (int fast=0;fast<nums.size();fast++){            if (nums[fast] != val){                nums[slow] = nums[fast];                slow++;            }        }</code></pre><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。<br>示例：<br>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组</p></blockquote><p><strong>滑动窗口</strong>：不断的调节子序列的起始位置和终止位置。其实算是双指针法的一种，一个指向滑动窗口起始位置，一个指向末端。</p><p>滑动窗口主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p><img src="/2023/02/01/cpp/%E6%95%B0%E7%BB%84/209.长度最小的子数组.gif" alt="209.长度最小的子数组"></p>]]></content>
    
    
    <summary type="html">二分查找
 * 坚持左闭右闭or左闭又开 * while(left &amp;lt;= right) or while(left &amp;lt; * 比较left、middle和right三个值 版本一 class solution { public: int search(vector&lt;int&gt;&amp;amp; nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left &lt;!--=--&gt;&lt;/int&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:58.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806194529815.png" alt="链表1"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 单链表struct ListNode {    int val;  // 节点上存储的元素    ListNode *next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL};</code></pre><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/image-20221218173554982.png" alt="image-20221218173554982"></p><p>删除节点和添加节点：</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195114541.png" alt="链表-删除节点"></p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195134331.png" alt="链表-添加节点"></p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/20200806195200276.png" alt="链表-链表与数据性能对比"></p><p>使用C，C++编程语言的话，不要忘了还要从<strong>内存中删除</strong>被移除的节点</p><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>为了使用一种统一的逻辑来移除链表的节点，我们可以设置<strong>虚拟头节点</strong></p><p>最后在题目中，return 头结点的时候，需要 <code>return dummyNode-&gt;next;</code></p><h3 id="新建虚拟头节点："><a href="#新建虚拟头节点：" class="headerlink" title="新建虚拟头节点："></a>新建虚拟头节点：</h3><pre class=" language-lang-cpp"><code class="language-lang-cpp">ListNode* dummyHead = new ListNode(-1);</code></pre><p>注：当需要避免对头节点的情况进行特殊处理时，采用虚拟头节点</p><p><a href="https://blog.csdn.net/qq_54182926/article/details/119193250">(63条消息) C++之new的使用_软硬兼施的程序员的博客-CSDN博客_c++ new</a></p><p>一、new的使用。<br>new+数据类型（初值），返回值为申请空间的对应数据类型的地址。<br>1.使用new申请一个对象</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *p = new int(10);//申请了一个初值为10的整型数据</code></pre><p>2.使用new申请数组</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">int *arr = new int[10];//申请了能存放10个整型数据元素的数组，其首地址为arr</code></pre><p>二、delete运算符的使用。<br>new运算符通常搭配delete元素安抚来使用，new用来动态申请存储空间，delete用于释放new申请的空间。<br>语法格式如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">delete p；delete[] arr;//注意要删除数组时，需要加[]，以表示arr为数组。</code></pre><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p>双指针法</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>双指针法：fast先走n+1步，slow再和fast同时走。注意使用虚拟头节点</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img" style="zoom:50%;"></p><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>思路：相交部分长度相同，交点处指针相等。即先将长度对齐，再比较指针是否相同。</p><p>注：<strong>判断链表结束是看是否指向NULL，</strong>而不是0。没有使用虚拟头节点的话，判断如下<code>while(curA != NULL)</code>,不需要用curA-&gt;next</p><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p><strong>判断环内相遇</strong>：双指针，慢指针每走一步，快指针走两步，如果两指针相遇，则表明有环。</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/141.环形链表.gif" alt="141.环形链表"></p><p><strong>找到环的入口：</strong>（快指针可能走N圈才会和慢的相遇）</p><p><img src="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/142.环形链表II（求入口）.gif" alt="142.环形链表II（求入口）"></p><p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>]]></content>
    
    
    <summary type="html">链表理论基础


// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，val初始化为x，next初始化为NULL
};




删除节点和添加节点：







使用C，C++编程语言的话，不要忘了还要从内存中删除被移除的节点

移除链表元素
为了使用一种统一的逻辑来移除链表的节点，我们可以设置虚拟头节点

最后在题目中，return 头结点的时候，需要 retu</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-04-03T01:24:08.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法理论基础"><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接(opens new window)</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>思路：排序后遍历，将最大的饼干喂给能喂饱的胃口最大的孩子。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findContentChildren(vector<int>& g, vector<int>& s) {        sort(g.begin(), g.end());        sort(s.begin(), s.end());        int index = s.size() - 1; // 饼干数组的下标        int result = 0;        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口             if (index >= 0 && s[index] >= g[i]) { // 遍历饼干                 result++;                index--;            }        }        return result;    }};</code></pre><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/">力扣题目链接(opens new window)</a></p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>思路：</p><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int candy(vector<int>& ratings) {        vector<int> candyVec(ratings.size(), 1);        // 从前向后        for (int i = 1; i < ratings.size(); i++) {            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;        }        // 从后向前        for (int i = ratings.size() - 2; i >= 0; i--) {            if (ratings[i] > ratings[i + 1] ) {                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);            }        }        // 统计结果        int result = 0;        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];        return result;    }};</code></pre><h3 id="BM96-主持人调度（二）"><a href="#BM96-主持人调度（二）" class="headerlink" title="BM96 主持人调度（二）"></a><strong>BM96</strong> <strong>主持人调度（二）</strong></h3><h2 id="方法二（排序-贪心）"><a href="#方法二（排序-贪心）" class="headerlink" title="方法二（排序+贪心）"></a>方法二（排序+贪心）</h2><h4 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1.解题思路"></a>1.解题思路</h4><ul><li>首先建立两个数组分别存储开始时间（记为start）和结束时间（记为end）。</li><li>然后分别对start和end数组进行排序。</li><li>接着遍历start数组，判断当前开始时间是否大于等于最小的结束时间，如果是，则说明当前主持人就可以搞定（对应当前最小的结束时间的那个活动）；如果否，则需要新增一个主持人，并将end数组下标后移（表示对应的活动已经有人主持）。</li></ul><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h4><pre class=" language-lang-cpp"><code class="language-lang-cpp">public class Solution {    public int minmumNumberOfHost (int n, int[][] startEnd) {        //初始化两个数组，分别记录开始时间和结束时间 ， 用vector也可以        int[] start=new int[n];        int[] end=new int[n];        //将活动的开始和结束时间赋值道start和end数组        for(int i=0;i<n;i++){            start[i]=startEnd[i][0];            end[i]=startEnd[i][1];        }        //按从小到大的顺序对start和end数组排序        Arrays.sort(start);        Arrays.sort(end);        int res=0,index=0;        for(int i=0;i<n;i++){            //如果大于等于当前最小的结束时间，说明当前主持人可以搞定 ????why？？？            if(start[i]>=end[index]){                index++;            }            //否则，需要新增主持人            else{                res++;            }        }        return res;    }}</code></pre><h4 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h4><ul><li>时间复杂度：需要进行排序，排序接口的时间复杂度是<script type="math/tex">O(nlogn)</script>，所以时间复杂度为<script type="math/tex">O(nlogn)</script></li><li>空间复杂度：需要额外大小为n的start和end数组，所以空间复杂度为<script type="math/tex">O(n)</script>。</li></ul><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列 *"></a>376. 摆动序列 *</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接(opens new window)</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int wiggleMaxLength(vector<int>& nums) {        if (nums.size() <= 1) return nums.size();        int curDiff = 0; // 当前一对差值        int preDiff = 0; // 前一对差值        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值        for (int i = 0; i < nums.size() - 1; i++) {            curDiff = nums[i + 1] - nums[i];            // 出现峰值            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {                result++;                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff             }        }        return result;    }};</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><ul><li>输入: [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出: 6</li><li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxSubArray(vector<int>& nums) {        int n = nums.size();        int result = INT32_MIN;        int count = 0;        for(int i = 0; i < n; i++){            count += nums[i];            result = max(result,count);            if(count <= 0) count = 0;        }        return result;    }};</code></pre><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p><a href="https://leetcode.cn/problems/jump-game/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: true</li><li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 跳跃覆盖范围究竟可不可以覆盖到终点class Solution {public:    bool canJump(vector<int>& nums) {        int n = nums.size();        if (n == 1) return true;        int cover = 0;        for(int i = 0; i <= cover; i++){            cover = max(cover, i + nums[i]);            if(cover >= n - 1) return true;        }        return false;    }};</code></pre><h2 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h2><p><a href="https://leetcode.cn/problems/jump-game-ii/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: 2</li><li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li></ul><p>说明: 假设你总是可以到达数组的最后一个位置</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//当指针走到cover1的边界时，就需要增加步数，进入cover2阶段class Solution {public:    int jump(vector<int>& nums) {        int cover1 = 0;        int cover2 = 0;        int n = nums.size();        int count = 0;        for(int i = 0; i <= cover1; i++){            if(cover1 >= n-1) break;            cover2 = max(cover2, i + nums[i]);            if(i == cover1 && i < n){                count++;                cover1 = cover2;            }        }        return count;    }};</code></pre><h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A = [4,2,3], K = 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 无序的数组可以先排序 sort可以自定义比较函数/*第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小(因为有些负数翻转后比原本最小的正数小)第二步：从前向后遍历，遇到负数将其变为正数，同时K--第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完第四步：求和*/class Solution {    //注意这里必须用static boolstatic bool cmp(int a, int b) {    return abs(a) > abs(b);}public:    int largestSumAfterKNegations(vector<int>& A, int K) {        sort(A.begin(), A.end(), cmp);       // 第一步        for (int i = 0; i < A.size(); i++) { // 第二步            if (A[i] < 0 && K > 0) {                A[i] *= -1;                K--;            }        }        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步        int result = 0;        for (int a : A) result += a;        // 第四步        return result;    }};</code></pre><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/">力扣题目链接(opens new window)</a></p><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p>示例 1: 输入:</p><ul><li>gas = [1,2,3,4,5]</li><li>cost = [3,4,5,1,2]</li></ul><p>输出: 3 解释:</p><ul><li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</li><li>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</li><li>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</li><li>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</li><li>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</li><li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li><li>因此，3 可为起始索引。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">/*情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。 （相当于从0往前一站看）*/class Solution {public:    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {        int curSum = 0;        int minsum = INT_MAX;        for (int i = 0; i < gas.size(); i++) {            int rest = gas[i]-cost[i];            curSum += rest;            minsum = min(minsum,curSum);        }        if(curSum < 0) return -1;        if(minsum >= 0) return 0;        else {            for (int i = gas.size() - 1; i >= 0; i--) {                int rest = gas[i] - cost[i];                minsum += rest;                if (minsum >= 0) {                    return i;                }            }        }        return -1;    }};</code></pre><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2><p><a href="https://leetcode.cn/problems/lemonade-change/">力扣题目链接(opens new window)</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool lemonadeChange(vector<int>& bills) {        vector<int> save(3, 0); //分别记录我有每种钱的数量         if(bills[0] != 5) return false;        for(int i = 0; i < bills.size(); i++){            if(bills[i] == 5) save[0]++;            else if(bills[i] == 10){                   if(save[0]){                    save[0]--;                    save[1]++;                }else return false;            }else{                if(save[1] && save[0]){                    save[1]--;                    save[0]--;                    save[2]++;                }else if(save[0] >= 3){                    save[0] = save[0] - 3;                    save[2]++;                }else return false;            }        }        return true;    }};</code></pre><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">力扣题目链接(opens new window)</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</li><li>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</li></ul></li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。// 按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面// 按照k为下标重新插入队列// 插入操作很多可以换成链表,代码会用到迭代器来找插入位置class Solution {public:    static bool cmp(const vector<int>& A, const vector<int>& B){        if(A[0] == B[0]) return A[1] < B[1]; //身高相同的话则k小的站前面        return A[0] > B[0]; // 身高一定是从大到小排    }    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {        sort(people.begin(), people.end(), cmp);         vector<vector<int>> que;        for (int i = 0; i < people.size(); i++) {            int position = people[i][1];            que.insert(que.begin() + position, people[i]);        }        return que;    }};</code></pre><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接(opens new window)</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><ul><li>输入：points = [[10,16],[2,8],[1,6],[7,12]]</li><li>输出：2</li><li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 先排序，若后一个气球和前一个重叠，则直接把边界拉成两个气球的最小右边界class Solution {public:    static bool cmp(vector<int>& a, vector<int>& b) {        return a[0] < b[0];    }    int findMinArrowShots(vector<vector<int>>& points) {        sort(points.begin(),points.end(),cmp);        int result = 1;        for(int i = 1; i < points.size(); i++){            if(points[i][0] > points[i-1][1]){ //不重叠                result++;            }else{                points[i][1] = min(points[i][1], points[i-1][1]);            }        }        return result;    }};</code></pre><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接(opens new window)</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 按右边界从小到大排序// 当前左边界没有超过end，就更新end为当前右边界；如果左边界超了end，就result++class Solution {public:    static bool cmp (const vector<int>& a, const vector<int>& b) {        return a[1] < b[1];    }    int eraseOverlapIntervals(vector<vector<int>>& intervals) {        sort(intervals.begin(), intervals.end(), cmp);        int end = intervals[0][1];        int result = 0;        for (int i = 1; i < intervals.size(); i++) {            if(intervals[i][0] >= end) end = intervals[i][1];            else result++;        }        return result;    }};</code></pre><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><p><a href="https://leetcode.cn/problems/partition-labels/">力扣题目链接(opens new window)</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S = “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 统计每一个字符最后出现的位置// 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点class Solution {public:    vector<int> partitionLabels(string S) {        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置        for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置            hash[S[i] - 'a'] = i;        }        vector<int> result;        int left = 0;        int right = 0;        for (int i = 0; i < S.size(); i++) {            right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界            if (i == right) {                result.push_back(right - left + 1);                left = i + 1;            }        }        return result;    }};</code></pre><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接(opens new window)</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    static bool cmp(vector<int>& a, vector<int>& b) {        return a[0] < b[0];    }    vector<vector<int>> merge(vector<vector<int>>& intervals) {        sort(intervals.begin(), intervals.end(), cmp);        int begin = intervals[0][0];        int end = intervals[0][1];        vector<vector<int>> result;        for(int i = 1; i < intervals.size(); i++){            if(intervals[i][0] <= end){                end = max(end, intervals[i][1]);            }else{                result.push_back(vector<int>{begin,end}); //注意这里的初始化方法 如[1,6] vector<int>{1，6}                begin = intervals[i][0];                end = intervals[i][1];            }        }        result.push_back(vector<int>{begin,end});        return result;    }};</code></pre><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接(opens new window)</a></p><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">//flag 记录降1的位置，后面的全变成9class Solution {public:    int monotoneIncreasingDigits(int n) {        string strNum = to_string(n);        int flag = 0;        for(int i = 1; i < strNum.size(); i++){            if(strNum[i] > strNum[i-1]) flag = i;            else if(strNum[i] < strNum[i-1]){                strNum[flag] = strNum[flag] - 1;                while(flag < strNum.size() - 1){                    flag++;                    strNum[flag] = '9';                }                break;            }        }        return stoi(strNum);    }};</code></pre><h1 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20230401212319522.png" alt="image-20230401212319522" style="zoom:33%;"></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！// 0：该节点无覆盖// 1：本节点有摄像头// 2：本节点有覆盖class Solution {private:    int result;    int traversal(TreeNode* cur) {        // 空节点，该节点有覆盖        if (cur == NULL) return 2;        int left = traversal(cur->left);    // 左        int right = traversal(cur->right);  // 右        // 情况1        // 左右节点都有覆盖        if (left == 2 && right == 2) return 0;        // 情况2 左右节点至少有一个无覆盖的情况        // left == 0 && right == 0 左右节点无覆盖        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头        // left == 0 && right == 2 左节点无覆盖，右节点覆盖        // left == 2 && right == 0 左节点覆盖，右节点无覆盖        if (left == 0 || right == 0) {            result++;            return 1;        }        // 情况3 左右节点至少有一个有摄像头        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头        // left == 1 && right == 1 左右节点都有摄像头        // 其他情况前段代码均已覆盖        if (left == 1 || right == 1) return 2;        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解        // 这个 return -1 逻辑不会走到这里。        return -1;    }public:    int minCameraCover(TreeNode* root) {        result = 0;        // 情况4        if (traversal(root) == 0) { // root 无覆盖            result++;        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">贪心算法理论基础
贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

有同学问了如何验证可不可以用贪心算法呢？

最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。

455.分发饼干
力扣题目链接(opens new window)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-11T06:35:57.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p><p>当我们需要<strong>查询一个元素是否出现过，或者一个元素是否在集合里的时候</strong>，就要第一时间想到哈希法。</p><p><strong>拉链法</strong></p><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235015226.png" alt="哈希表4"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p><strong>线性探测法</strong></p><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20210104235109950.png" alt="哈希表5"></p><p>常见的哈希结构：数组、set（集合）、map（映射）</p><blockquote><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p></blockquote><p><strong>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset</strong></p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，不过给我们的使用方式，还是哈希法的使用方式，即key和value。map同理。</p><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><blockquote><p>数组就是简单的哈希表，但是数组的大小可不是无限开辟的</p></blockquote><p>本题使用数组模拟哈希表，数组大小为26，元素值代表字母出现的次数</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/242.有效的字母异位词.gif" alt="242.有效的字母异位词"></p><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/20200818193523911.png" alt="349. 两个数组的交集"></p><p>本题结果是无重复的，且没有限制数组的长度，且无需排序，因此使用<strong>unordered_set</strong></p><blockquote><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的长度。</strong>而这道题目没有限制数值的长度，就无法使用数组来做哈希表了。</p><p>（用vector代替数组是否能解决限制长度的问题）</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p></blockquote><p><a href="https://blog.csdn.net/qq_40286920/article/details/124731777">c++ unordered<em>set详细操作</em>好人好事代表nxx的博客-CSDN博客_unordered_set</a></p><p><strong>使用迭代器构造</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">unordered_set<int> set3(set1.begin(), set1.end());</code></pre><p><strong>find()函数——查找</strong><br>//查找2，找到返回迭代器，失败返回end()</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">set1.find(2);</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {        unordered_set<int> result_set;        unordered_set<int> nums_set(nums1.begin(),nums1.end());        for(int num:nums2){            if (nums_set.find(num) != nums_set.end()) {                result_set.insert(num);            }        }        return vector<int>(result_set.begin(), result_set.end()); //注意返回值类型    }};</code></pre><p>注：</p><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int getSum(int n){        int sum = 0;        //取数值各个位上的单数操作        while(n){            sum += (n % 10) * (n % 10); //不可使用^2表示平方            n = n/10;        }        return sum;    }    bool isHappy(int n) {        unordered_set<int> sums_set;        while(1){            int sum = getSum(n);            if(sum == 1) return true;            if(sums_set.find(sum) != sums_set.end()) return false;            sums_set.insert(sum);            n = sum;        }    }};</code></pre><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接(opens new window)</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><p><strong>思路：</strong></p><p>每次遍历时要看这个<strong>元素</strong>之前是否出现过–&gt;考虑用哈希</p><p>同时要存元素和下表两个值–&gt;用map–&gt;元素对应key，下标对应value</p><p><strong>题解：</strong></p><p><a href="https://blog.csdn.net/zyc2018/article/details/93591189">(73条消息) C++之auto的使用<em>Waldeinsamkeit</em>的博客-CSDN博客_auto iter</a></p><p><a href="https://blog.csdn.net/u010112268/article/details/81153034">(73条消息) C++中pair的用法_淼淼1111的博客-CSDN博客_pair</a></p><pre class=" language-lang-c++"><code class="language-lang-c++">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        std::unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map.insert(pair<int, int>(nums[i], i));//可用此用法            }        }        return {};    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        unordered_map <int,int> map;        for(int i = 0; i < nums.size(); i++){            auto iter = map.find(target-nums[i]);            if(iter != map.end()){                return {iter->second,i};            }else{                map[nums[i]]=i;  //可用此用法            }        }        return {};    }};</code></pre><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>思路：</strong></p><p>HashMap 存一个数组，如 A。然后计算三个数组之和，如 BCD。时间复杂度为：O(n)+O(n^3)，得到 O(n^3).<br>HashMap 存三个数组之和，如 ABC。然后计算一个数组，如 D。时间复杂度为：O(n^3)+O(n)，得到 O(n^3).<br>HashMap 存两个数组之和，如AB。然后计算两个数组之和，如 CD。时间复杂度为：O(n^2) + O(n^2)，得到 O(n^2).</p><p>要存a+b的所有可能，以及出现的次数</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {        std::unordered_map <int,int> map12;        int sum12;        int sum34;        int num=0;        for(int i = 0; i < nums1.size(); i++){            for(int j = 0; j < nums2.size(); j++){                map12[nums1[i]+nums2[j]]++;            }        }        for(int i = 0; i < nums3.size(); i++){            for(int j = 0; j < nums4.size(); j++){                sum34 = nums3[i]+nums4[j];                if(map12.find(-sum34) != map12.end()){                    num = num + map12[-sum34];                }            }        }        return num;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中        for (int a : A) {   // 注意这种特殊用法            for (int b : B) {                umap[a + b]++;            }        }        int count = 0; // 统计a+b+c+d = 0 出现的次数        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。        for (int c : C) {            for (int d : D) {                if (umap.find(0 - (c + d)) != umap.end()) {                    count += umap[0 - (c + d)];                }            }        }        return count;    }};</code></pre><p>后面大概还剩150道题</p><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p><strong>题解：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        unordered_map <int,int> map;        for(int i = 0; i < magazine.size(); i++){            map[magazine[i]]++;        }        for(int i = 0; i < ransomNote.size(); i++){            if(map.find(ransomNote[i]) != map.end()){                if(map[ransomNote[i]]>0){                    map[ransomNote[i]]--;                }else{                    return false;                }            }else{                return false;            }        }        return true;    }};</code></pre><p><strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 时间复杂度: O(n)// 空间复杂度：O(1)class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int record[26] = {0};        //add        if (ransomNote.size() > magazine.size()) {            return false;        }        for (int i = 0; i < magazine.length(); i++) {            // 通过recode数据记录 magazine里各个字符出现次数            record[magazine[i]-'a'] ++;        }        for (int j = 0; j < ransomNote.length(); j++) {            // 遍历ransomNote，在record里对应的字符个数做--操作            record[ransomNote[j]-'a']--;            // 如果小于零说明ransomNote里出现的字符，magazine没有            if(record[ransomNote[j]-'a'] < 0) {                return false;            }        }        return true;    }};</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接(opens new window)</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中<strong>不可以包含重复</strong>的三元组。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p><strong>思考：</strong></p><p>哈希法C++代码:（此题不宜使用哈希法，去重比较复杂）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> result;        sort(nums.begin(), nums.end());        // 找出a + b + c = 0        // a = nums[i], b = nums[j], c = -(a + b)        for (int i = 0; i < nums.size(); i++) {            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组            if (nums[i] > 0) {                break;            }            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重                continue;            }            unordered_set<int> set;            for (int j = i + 1; j < nums.size(); j++) {                if (j > i + 2                        && nums[j] == nums[j-1]                        && nums[j-1] == nums[j-2]) { // 三元组元素b去重                    continue;                }                int c = 0 - (nums[i] + nums[j]);                if (set.find(c) != set.end()) {                    result.push_back({nums[i], nums[j], c});                    set.erase(c);// 三元组元素c去重                } else {                    set.insert(nums[j]);                }            }        }        return result;    }};</code></pre><p>使用双指针法更高效：</p><p><img src="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/15.三数之和.gif" alt="15.三数之和"></p><p>遇事不决先排序，两边逼近双指针</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int i = 0; i < nums.size(); i++){            if(nums[i] > 0) break;            //a去重            if(i>0 && nums[i] == nums[i-1]) continue;            //定义双指针            int left = i + 1;            int right = nums.size() - 1;            while(right > left){                int sum = nums[i]+nums[left]+nums[right];                if(sum > 0) right--;                else if(sum <0) left++;                else{                    results.push_back(vector<int>{nums[i],nums[left],nums[right]});                    //去重                    while (right > left && nums[right] == nums[right - 1]) right--;                    while (right > left && nums[left] == nums[left + 1]) left++;                    right--;                    left++;                }            }        }        return results;    }};</code></pre><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接(opens new window)</a></p><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> fourSum(vector<int>& nums, int target) {        vector<vector<int>> results;        sort(nums.begin(),nums.end());        for(int j = 0; j < nums.size(); j++){            if(j>0 && nums[j] == nums[j-1]) continue;            for(int i = j + 1; i < nums.size(); i++){                //a去重                if(i>j+1 && nums[i] == nums[i-1]) continue;                //定义双指针                int left = i + 1;                int right = nums.size() - 1;                while(right > left){                    //此处需要强制转换为long，否则会溢出                    long sum =(long) nums[j]+nums[i]+nums[left]+nums[right];                    if(sum > target) right--;                    else if(sum <target) left++;                    else{                        results.push_back(vector<int>{nums[j],nums[i],nums[left],nums[right]});                        //去重                        while (right > left && nums[right] == nums[right - 1]) right--;                        while (right > left && nums[left] == nums[left + 1]) left++;                        right--;                        left++;                    }                }            }        }        return results;    }};</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在两数之和中map正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>map是一种<code>&lt;key, value&gt;</code>的结构，两数之和可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p>]]></content>
    
    
    <summary type="html">哈希表理论基础
哈希表是根据关键码的值而直接进行访问的数据结构。

当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

拉链法

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了



（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-05-30T13:04:19.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法理论基础"><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h2><p>回溯是递归的副产品，只要有递归就会有回溯。在下文中，<strong>回溯函数也就是递归函数，指的都是一个函数</strong></p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>回溯三部曲：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void backtracking(参数){    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}</code></pre><p>labuladong里面的看法：</p><p>回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝 or 路径」，DFS 算法是在遍历「节点」</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// DFS 算法，关注点在节点void traverse(TreeNode* root) {    if (root == nullptr) return;    printf("进入节点 %s", root); // 处理节点    for (TreeNode* child : root->children) {        traverse(child);    }    printf("离开节点 %s", root); //回溯节点}// 回溯算法，关注点在树枝void backtrack(TreeNode *root) {    if (root == nullptr) return;    for (TreeNode* child : root->children) {        // 做选择        printf("从 %s 到 %s", root, child);        backtrack(child);        // 撤销选择        printf("从 %s 到 %s", child, root);    }}</code></pre><p>我认为dfs和回溯也没啥区别，还是可以用回溯的方式做，只不过要把根节点提前加到路径罢了，不过按这个写更清晰</p><h2 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h2><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接(opens new window)</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><p>思路：</p><p>把组合问题抽象为如下树形结构：</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201123195223940-16777567027868.png" alt="77.组合" style="zoom:33%;"></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        for(int i = startIndex; i <=n; i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><p>剪枝优化题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result; // 存放符合条件结果的集合    vector<int> path; // 用来存放符合条件结果    void backtracking(int n, int k, int startIndex) {        if(path.size() == k){            result.push_back(path);            return;        }        // n-i+1 >= k-path.size() 大多数回溯算法的剪枝操作，都是改这里i的范围        for(int i = startIndex; i <= n + 1 - k + path.size(); i++){ //注意此处是<=            path.push_back(i);            backtracking(n, k, i + 1);            path.pop_back();        }    }    vector<vector<int>> combine(int n, int k) {        backtracking(n, k, 1);        return result;    }};</code></pre><h2 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接(opens new window)</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><p>思路：</p><p>k是树的深度，n是树的宽度</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9; i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><p>剪枝后：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(int targetSum, int k, int sum, int startIndex){        if(sum > targetSum) return;        if(path.size() == k){            if(sum == targetSum) result.push_back(path);            return;        }        for(int i = startIndex; i <= 9 + 1 - k + path.size(); i++){            path.push_back(i);            sum = sum + i;            backtracking(targetSum, k, sum, i+1);            sum = sum - i;            path.pop_back();        }    }    vector<vector<int>> combinationSum3(int k, int n) {        backtracking(n, k, 0, 1);        return result;    }};</code></pre><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/2020102916424043.png" alt="17.电话号码的字母组合"></p><p>思路：</p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    const string letterMap[10] = {        "", // 0        "", // 1        "abc", // 2        "def", // 3        "ghi", // 4        "jkl", // 5        "mno", // 6        "pqrs", // 7        "tuv", // 8        "wxyz", // 9    };    vector<string> result;    string s;    void backtracking(string digits, int index){        if (index == digits.size()) {            result.push_back(s);            return;        }        int digit = digits[index] - '0'; // 将index指向的数字转为int        string letters = letterMap[digit];        for (int i = 0; i < letters.size(); i++) {            s.push_back(letters[i]);            backtracking(digits,index + 1); // 递归            s.pop_back();        }    }    vector<string> letterCombinations(string digits) {        if(digits == "") return result;        backtracking(digits, 0);        return result;    }};</code></pre><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong></p><p><img src="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/20201223170730367.png" alt="39.组合总和"></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> results;    vector<int> path;    void backtracking(vector<int> candidates, int target, int index, int sum){        if(sum == target){            results.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = index; i < candidates.size(); i++) {            path.push_back(candidates[i]);            backtracking(candidates, target, i, sum + candidates[i]); // 递归            path.pop_back();        }    }    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {        backtracking(candidates, target, 0, 0);        return  results;    }};</code></pre><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接(opens new window)</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：数组candidates中会出现重复数字，需要<strong>排序后去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {        if (sum == target) {            result.push_back(path);            return;        }        if(sum > target){            return;        }        for (int i = startIndex; i < candidates.size(); i++) {            // 要对同一树层使用过的元素进行跳过，这是本题的关键            if (i > startIndex && candidates[i] == candidates[i - 1]) {                continue;            }            path.push_back(candidates[i]);            backtracking(candidates, target, sum + candidates[i], i + 1); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次            path.pop_back();        }    }public:    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {        path.clear();        result.clear();        // 首先把给candidates排序，让其相同的元素都挨在一起。        sort(candidates.begin(), candidates.end());        backtracking(candidates, target, 0, 0);        return result;    }};</code></pre><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接(opens new window)</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串    bool isPalindrome(const string& s, int start, int end) {        for (int i = start, j = end; i < j; i++, j--) {            if (s[i] != s[j]) {                return false;            }        }        return true;    }    vector<vector<string>> result;    vector<string> path; // 放已经回文的子串    void backtracking (const string& s, int startIndex) {        if (startIndex >= s.size()) {            result.push_back(path);            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isPalindrome(s, startIndex, i)) { // 是回文子串                // 获取[startIndex,i]在s中的子串                string str = s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            } else {                // 如果不是则直接跳过                continue;            }            backtracking(s, i + 1); // 寻找i+1为起始位置的子串            path.pop_back();        // 回溯过程，弹出本次已经填在的子串        }    }    vector<vector<string>> partition(string s) {        backtracking(s, 0);        return result;    }};</code></pre><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接(opens new window)</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,”255.255.111.35”]</li></ul><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法    bool isValid(const string& s, int start, int end) {        if (start > end) {            return false;        }        if (s[start] == '0' && start != end) { // 0开头的数字不合法                return false;        }        int num = 0;        for (int i = start; i <= end; i++) {            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法                return false;            }            num = num * 10 + (s[i] - '0');            if (num > 255) { // 如果大于255了不合法                return false;            }        }        return true;    }    vector<string> result;// 记录结果    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量    void backtracking(string& s, int startIndex, int pointNum){        if (pointNum == 3) { // 逗点数量为3时，分隔结束            // 判断第四段子字符串是否合法，如果合法就放进result中            if (isValid(s, startIndex, s.size() - 1)) {                result.push_back(s);            }            return;        }        for (int i = startIndex; i < s.size(); i++) {            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点                pointNum++;                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2                pointNum--;                         // 回溯                s.erase(s.begin() + i + 1);         // 回溯删掉逗点            } else break; // 不合法，直接结束本层循环        }    }    vector<string> restoreIpAddresses(string s) {        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了        backtracking(s, 0, 0);        return result;    }};</code></pre><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接(opens new window)</a></p><p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><p><strong>子集是收集树形结构中树的所有节点的结果</strong>。<strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int> nums, int index){        result.push_back(path);// 重点！不管到没到最后都要收集结果        //下面这个可要可不要,因为在for循环中给出了判断        if (index >= nums.size()) {            //不是在这里才收集结果            return;        }        for (int i = index; i < nums.size(); i++) {            path.push_back(nums[i]);            backtracking(nums, i + 1); // 递归            path.pop_back();        }    }    vector<vector<int>> subsets(vector<int>& nums) {        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h2><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p><p>给定一个可能包含<strong>重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p>思路：</p><p>本题就是在上一题的基础上加上了<strong>去重</strong>，通过<strong>排序去重</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        result.push_back(path);        //if (startIndex >= nums.size()) {        //    return;        //}        for (int i = startIndex; i < nums.size(); i++) {            //跳过重复元素            if (i > startIndex && nums[i] == nums[i - 1]) {                continue;            }            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> subsetsWithDup(vector<int>& nums) {        sort(nums.begin(), nums.end()); // 去重需要排序        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><ul><li>输入: [4, 6, 7, 7]</li><li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li></ul><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><p>思路：</p><p>不可对原数组进行重排，而且重复的数字不一定挨着出现，所以可以使用哈希表来判断数字是否用过</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking(vector<int>& nums, int startIndex) {        if (path.size() > 1) {            result.push_back(path);            // 注意这里不要加return，要取树上的节点        }        unordered_set<int> uset; // 使用set对本层元素进行去重        for (int i = startIndex; i < nums.size(); i++) {            //若当前数比上一个小（注意上一个是path.back），或者使用过，则跳过            if ((!path.empty() && nums[i] < path.back())                    || uset.find(nums[i]) != uset.end()) {                    continue;            }            uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了            path.push_back(nums[i]);            backtracking(nums, i + 1);            path.pop_back();        }    }public:    vector<vector<int>> findSubsequences(vector<int>& nums) {        result.clear();        path.clear();        backtracking(nums, 0);        return result;    }};</code></pre><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接(opens new window)</a></p><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><ul><li>输入: [1,2,3]</li><li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li></ul><p>思路：</p><p>用used数组，用过的记为1</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        // 此时说明找到了一组        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        for (int i = 0; i < nums.size(); i++) {            if (used[i] == true) continue; // path里已经收录的元素，直接跳过            used[i] = true;            path.push_back(nums[i]);            backtracking(nums, used);            path.pop_back();            used[i] = false;        }    }    vector<vector<int>> permute(vector<int>& nums) {        result.clear();        path.clear();        vector<bool> used(nums.size(), false);//注意vector的初始化方式        backtracking(nums, used);        return result;    }};</code></pre><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p><p>给定一个<strong>可包含重复</strong>数字的序列 nums ，按任意顺序返回所有<strong>不重复</strong>的全排列。</p><p>思路：</p><p>我的：used+set （复杂度很高）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复        for (int i = 0; i < nums.size(); i++) {            if (uset.find(nums[i]) != uset.end()) {                continue;            }            if (used[i] == false) {  //控制同一树枝不重复                uset.insert(nums[i]); // 记录元素                used[i] = true;                path.push_back(nums[i]);                backtracking(nums, used);                path.pop_back();                used[i] = false;            }        }    }public:    vector<vector<int>> permuteUnique(vector<int>& nums) {        result.clear();        path.clear();        // sort(nums.begin(), nums.end()); // 无需排序        vector<bool> used(nums.size(), false);        backtracking(nums, used);        return result;    }};</code></pre><p>题解：</p><p>used+ 排序（用排序来去重）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    vector<vector<int>> result;    vector<int> path;    void backtracking (vector<int>& nums, vector<bool>& used) {        // 此时说明找到了一组        if (path.size() == nums.size()) {            result.push_back(path);            return;        }        for (int i = 0; i < nums.size(); i++) {            // used[i - 1] == true，说明同一树支nums[i - 1]使用过            // used[i - 1] == false，说明同一树层nums[i - 1]使用过            // 如果同一树层nums[i - 1]使用过则直接跳过            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {                continue;            }            if (used[i] == false) {                used[i] = true;                path.push_back(nums[i]);                backtracking(nums, used);                path.pop_back();                used[i] = false;            }        }    }public:    vector<vector<int>> permuteUnique(vector<int>& nums) {        result.clear();        path.clear();        sort(nums.begin(), nums.end()); // 排序        vector<bool> used(nums.size(), false);        backtracking(nums, used);        return result;    }};</code></pre><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后*"></a>51. N皇后*</h2><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或<strong>同一斜线</strong>！上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>题解：</p><p>重点是 isValid函数的逻辑</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:vector<vector<string>> result;// n 为输入的棋盘大小// row 是当前递归到棋盘的第几行了void backtracking(int n, int row, vector<string>& chessboard) {    if (row == n) {        result.push_back(chessboard);        return;    }    for (int col = 0; col < n; col++) {        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放            chessboard[row][col] = 'Q'; // 放置皇后            backtracking(n, row + 1, chessboard);            chessboard[row][col] = '.'; // 回溯，撤销皇后        }    }}bool isValid(int row, int col, vector<string>& chessboard, int n) {    // 检查列    for (int i = 0; i < row; i++) { // 这是一个剪枝        if (chessboard[i][col] == 'Q') {            return false;        }    }    // 检查 45度角是否有皇后    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    // 检查 135度角是否有皇后    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    return true;}public:    vector<vector<string>> solveNQueens(int n) {        result.clear();        vector<string> chessboard(n, string(n, '.'));        backtracking(n, 0, chessboard);        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">回溯算法理论基础
回溯是递归的副产品，只要有递归就会有回溯。在下文中，回溯函数也就是递归函数，指的都是一个函数

回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。

回溯三部曲：

void backtracking(参数){
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); //</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-03-26T13:31:02.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><p>队列是先进先出，栈是先进后出。</p><p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong>SGI STL中队列一样是以deque为缺省情况下的底部结构</strong></p><p>STL 栈和队列都不被归类为容器，而被归类为container adapter（ 容器适配器）。</p><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接(opens new window)</a></p><p>使用栈实现队列的下列操作：</p><p>push(x) — 将一个元素放入队列的尾部。<br>pop() — 从队列首部移除元素。<br>peek() — 返回队列首部的元素。<br>empty() — 返回队列是否为空。</p><p>示例:</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek();  // 返回 1queue.pop();   // 返回 1queue.empty(); // 返回 false</code></pre><p>说明:</p><ul><li>你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p><strong>思路：</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2" style="zoom: 67%;"></p><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><p><strong>代码：</strong></p><p>类的构造函数</p><p><a href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">https://www.runoob.com/cplusplus/cpp-constructor-destructor.html</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">stack<type> s; // 初始化s.push(value); // 入栈s.pop(); // 出栈，返回voids.empty(); // 判断空否s.top(); // 返回栈顶元素s.size();  // 返回栈元素个数</code></pre><p>在pop()之前要先用top()访问，pop()本身是不返回元素的。这个想法看来还真是有意义的</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class MyQueue {public:    stack<int> stIn;    stack<int> stOut;    MyQueue() {    }    void push(int x) {        stIn.push(x);    }    int pop() {        if(stOut.empty()){            while(!stIn.empty()){                stOut.push(stIn.top());                stIn.pop();            }        }        int result = stOut.top();        stOut.pop();        return result;    }    int peek() {        int res = this->pop(); // 直接使用已有的pop函数        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去        return res;    }    bool empty() {        if(stOut.empty()&&stIn.empty()) return true;        else return false;    }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */</code></pre><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">力扣题目链接(opens new window)</a></p><p>使用单向队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p><strong>代码：</strong></p><p>queue操作：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">q.front();        //获取队首q.back();        //获取队尾q.push(x);        //插入元素,x表示要插入的值,什么都行（但是类型必须和定义的相同）q.pop();        //将队头弹出,无返回值q.size();        //返回队列里有多少个元素q.empty();        //如果队列为空，返回true，否则返回false（ 等同于q.size()==0 ）q.swap(q2);        //交换q和q2里面的值(q2需要和q是一个类型)</code></pre><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class MyStack {public:    queue<int> que;    MyStack() {    }    void push(int x) {        que.push(x);    }    int pop() {        int size = que.size();        while(size >1){            que.push(que.front());            que.pop();            size--;        }        int result = que.front();        que.pop();        return result;    }    int top() {        int result = this->pop();        que.push(result);        return result;    }    bool empty() {        return que.empty();    }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */</code></pre><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接(opens new window)</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><ul><li>输入: “()”</li><li>输出: true</li></ul><p>示例 2:</p><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><p>示例 3:</p><ul><li>输入: “(]”</li><li>输出: false</li></ul><p>示例 4:</p><ul><li>输入: “([)]”</li><li>输出: false</li></ul><p>示例 5:</p><ul><li>输入: “{[]}”</li><li>输出: true</li></ul><p>我的代码：</p><p>使用单个栈实现</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isValid(string s) {        stack<char> t;        for(int i = 0; i < s.size(); i++){            if(s[i] == '(' or s[i] == '[' or s[i] == '{'){                t.push(s[i]);            }else if(!t.empty()){                if((t.top() == '(' && s[i] == ')') or (t.top() == '[' && s[i] == ']') or (t.top() == '{' && s[i] == '}')) t.pop();                else return false;            }else return false;        }        if(t.size() == 0) return true;        else return false;    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isValid(string s) {        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求        stack<char> st;        for (int i = 0; i < s.size(); i++) {            if (s[i] == '(') st.push(')');            else if (s[i] == '{') st.push('}');            else if (s[i] == '[') st.push(']');            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false            else if (st.empty() || st.top() != s[i]) return false;            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素        }        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true        return st.empty();    }};</code></pre><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣题目链接(opens new window)</a></p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：”abbaca”</li><li>输出：”ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string s) {        stack<char> t;        for(int i = 0; i < s.size(); i++){            if(t.empty() || s[i] != t.top()) t.push(s[i]);            else t.pop();        }        string result = "";        while (!t.empty()){            result += t.top(); //注意字符串的+操作            t.pop();        }        reverse (result.begin(), result.end()); // 此时字符串需要反转一下        return result;    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string S) {        stack<char> st;        for (char s : S) {            if (st.empty() || s != st.top()) {                st.push(s);            } else {                st.pop(); // s 与 st.top()相等的情况            }        }        string result = "";        while (!st.empty()) { // 将栈中元素放到result字符串汇总            result += st.top();            st.pop();        }        reverse (result.begin(), result.end()); // 此时字符串需要反转一下        return result;    }};</code></pre><p>还可以拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    string removeDuplicates(string S) {        string result;        for(char s : S) {            if(result.empty() || result.back() != s) {                result.push_back(s); //注意字符串操作            }            else {                result.pop_back();//注意字符串操作            }        }        return result;    }};</code></pre><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, “ * “]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ul><p><strong>代码：</strong></p><p>C++字符串转换(stoi；stol；stoul；stoll；stoull；stof；stod；stold)</p><p><a href="https://blog.csdn.net/weixin_43899069/article/details/110290292?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-110290292-blog-114146606.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">https://blog.csdn.net/weixin_43899069/article/details/110290292?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-110290292-blog-114146606.pc_relevant_multi_platform_whitelistv4&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int evalRPN(vector<string>& tokens) {        stack<long long> st;         for(int i = 0; i < tokens.size(); i++){            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {                long long num1 = st.top();                st.pop();                long long num2 = st.top();                st.pop();                if (tokens[i] == "+") st.push(num2 + num1);                if (tokens[i] == "-") st.push(num2 - num1);                if (tokens[i] == "*") st.push(num2 * num1);                if (tokens[i] == "/") st.push(num2 / num1);            }else{                st.push(stoll(tokens[i]));            }        }        return st.top();    }};</code></pre><h2 id="239-滑动窗口最大值——单调队列"><a href="#239-滑动窗口最大值——单调队列" class="headerlink" title="239. 滑动窗口最大值——单调队列"></a>239. 滑动窗口最大值——单调队列</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接(opens new window)</a></p><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p><img src="/2023/02/01/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20230216192400940.png" alt="image-20230216192400940" style="zoom:33%;"></p><p><strong>思路：</strong></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2" style="zoom:67%;"></p><p>使用<strong>单调队列</strong>:</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的front元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于<strong>back元素</strong>的数值，那么就将队列front的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p><strong>代码：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    class MyQueue{ //单调队列（从大到小），由于需要访问q.back()和pop_back()，需要用双向的        public:            deque<int> q;            void pop(int x){                if(!q.empty() && x == q.front()) q.pop_front();            }        // 判断非空需要放在前面，如果改为x == q.front() && !q.empty()就会报错            void push(int x){                while(!q.empty() && x > q.back()) {                    q.pop_back();                }                q.push_back(x);            }            int front(){                return q.front();            }    };    vector<int> maxSlidingWindow(vector<int>& nums, int k) {        MyQueue que;        vector<int> results;        for(int i = 0; i < k; i++){            que.push(nums[i]);        }        results.push_back(que.front());        for(int i = k; i < nums.size(); i++){            que.pop(nums[i-k]);            que.push(nums[i]);            results.push_back(que.front());        }        return results;    }};</code></pre><h2 id="347-前-K-个高频元素——优先级队列"><a href="#347-前-K-个高频元素——优先级队列" class="headerlink" title="347.前 K 个高频元素——优先级队列"></a>347.前 K 个高频元素——优先级队列</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣题目链接(opens new window)</a></p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2</li><li>输出: [1,2]</li></ul><p>思路：</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>使用map（key元素  value频率）和小顶堆</p><p>【priority_queue优先队列的基础知识】</p><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solutions/1283998/c-xiao-bai-you-hao-you-xian-dui-lie-de-j-53ay/">https://leetcode.cn/problems/top-k-frequent-elements/solutions/1283998/c-xiao-bai-you-hao-you-xian-dui-lie-de-j-53ay/</a></p><p><a href="https://blog.csdn.net/qq_43679351/article/details/124825229">https://blog.csdn.net/qq_43679351/article/details/124825229</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 时间复杂度：O(nlogk)// 空间复杂度：O(n)class Solution {public:    //小顶堆    class mycomparison{    public:        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {            return lhs.second > rhs.second;        }    }; //注意这里的分号    vector<int> topKFrequent(vector<int>& nums, int k) {         // 要统计元素出现频率        unordered_map<int, int> map; // map<nums[i],对应出现的次数>        for (int i = 0; i < nums.size(); i++) {            map[nums[i]]++; //key元素  value频率        }        //上式可以改写为        // for (int i : nums) {        //    map[i]++; //key元素  value频率        //}        // 对频率排序        // 定义一个小顶堆，大小为k        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> q;        // 用固定大小为k的小顶堆，扫描所有频率的数值        for(auto& a:map){            q.push(a);            if(q.size()>k){               q.pop();             }        }        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组        vector<int> result(k);        for (int i = k - 1; i >= 0; i--) {            result[i] = q.top().first;            q.pop();        }        return result;    }};</code></pre><p>在一场考试中，有 n 道多选题，每道题有 4 个选项，选项分别为 A、B、C、D，有些题目可能存在多个正确答案，现在已知牛牛和牛妹分别做出了每道题的选择，每道题全部选对得 3 分，部分选对得 1 分，选错不得分，牛妹得了满分，求牛牛最终的得分。 输入描述： 第一行一个正整数 n，代表选择题的数量。 第二行 n 个长度为 1 到 4 的字符串，其中第 i 个字符串代表牛牛做出的第 i 道选择题的答案。 第三行 n 个长度为 1 到 4 的字符串，其中第 i 个字符串代表牛妹做出的第 i 道选择题的答案。 注意：1 &lt; n &lt; 10000。 输出描述： 一个整数，代表牛牛最终的得分。</p><p> 例子： 输入： 3 ABC AB CD  ABC ABD BC 输出： 4</p><p>给定一个长度为n的数组， 求有多少长度为k 的子区间满足：子区间中元素恰好构成一个顺子；</p><p>顺子的定义：排序后相邻两元素的差的绝对值恰好等于1.例如：[3,7,6,4,5]是一个顺子</p><p>输入：</p><p>​    第一行两个整数N和k</p><p>第二行n个整数</p><p>输出：</p><p>​    输出一个正整数代表答案</p><p>例子：</p><p>​    输入：</p><p>​    4 2</p><p>2 3 3 2</p><p>输出：</p><p>2</p><p>说明：</p><p>满足条件的区间有[1,2]和[3,4]</p>]]></content>
    
    
    <summary type="html">栈与队列理论基础
队列是先进先出，栈是先进后出。

我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

SGI STL中队列一样是以deque为缺省情况下的底部结构

STL 栈和队列都不被归类为容器，而被归类为container adapter（ 容器适配器）。

用栈实现队列
力扣题目链接(opens new window)

使用栈实现队列的下列操作：

push(x) — 将一个元素放入队列的尾部。
pop() — 从队列首部移除元素。
peek() — 返回队</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://youngyyp.github.io/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://youngyyp.github.io/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-02-01T13:14:33.000Z</published>
    <updated>2023-05-30T13:04:23.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树理论基础篇"><a href="#二叉树理论基础篇" class="headerlink" title="#二叉树理论基础篇"></a><a href="https://www.programmercarl.com/二叉树理论基础.html#二叉树理论基础篇">#</a>二叉树理论基础篇</h2><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn</p><p>unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表</p><p>一棵树当中没有子结点（即度为0）的结点称为<em>叶子</em>结点，简称“<em>叶子</em>”</p><p><strong>二叉树主要有两种遍历方式：</strong></p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>前中后是针对中间的节点</p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20200806191109896.png" alt="img" style="zoom:50%;"></p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="#二叉树的定义"></a><a href="https://www.programmercarl.com/二叉树理论基础.html#二叉树的定义">#</a>二叉树的定义</h3><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p><p>C++代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">struct TreeNode {    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) {}};</code></pre><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><h4 id="递归三要素："><a href="#递归三要素：" class="headerlink" title="递归三要素："></a>递归三要素：</h4><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p><strong>以下以前序遍历为例：</strong></p><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec)</code></pre><ol><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">if (cur == NULL) return;</code></pre><ol><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">vec.push_back(cur->val);    // 中traversal(cur->left, vec);  // 左traversal(cur->right, vec); // 右</code></pre><p>前序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void traversal(TreeNode* cur, vector<int>& vec) {        if (cur == NULL) return;        vec.push_back(cur->val);    // 中        traversal(cur->left, vec);  // 左        traversal(cur->right, vec); // 右    }    vector<int> preorderTraversal(TreeNode* root) {        vector<int> result;        traversal(root, result);        return result;    }};</code></pre><p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p><p>中序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec) {    if (cur == NULL) return;    traversal(cur->left, vec);  // 左    vec.push_back(cur->val);    // 中    traversal(cur->right, vec); // 右}</code></pre><p>后序遍历：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">void traversal(TreeNode* cur, vector<int>& vec) {    if (cur == NULL) return;    traversal(cur->left, vec);  // 左    traversal(cur->right, vec); // 右    vec.push_back(cur->val);    // 中}</code></pre><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong></p><p>可以用<strong>栈</strong>实现二叉树的前后中序遍历</p><h4 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/二叉树前序遍历（迭代法）-16766184074375.gif" alt="二叉树前序遍历（迭代法）" style="zoom: 67%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> preorderTraversal(TreeNode* root) {        stack<TreeNode*> st;        vector<int> result;        if (root == NULL) return result;        st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();                       // 中            st.pop();            result.push_back(node->val);            if (node->right) st.push(node->right);           // 右（空节点不入栈）            if (node->left) st.push(node->left);             // 左（空节点不入栈）        }        return result;    }};</code></pre><p><strong>中序遍历，可以写出如下代码：</strong></p><p><strong>需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素</strong></p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> inorderTraversal(TreeNode* root) {        vector<int> result;        stack<TreeNode*> st;        TreeNode* cur = root;        while (cur != NULL || !st.empty()) {            if (cur != NULL) { // 指针来访问节点，访问到最底层                st.push(cur); // 将访问的节点放进栈                cur = cur->left;                // 左            } else {                cur = st.top(); // 从栈里弹出的数据，就是放进result数组里的数据                st.pop();                result.push_back(cur->val);     // 中                cur = cur->right;               // 右            }        }        return result;    }};</code></pre><p>后序：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> postorderTraversal(TreeNode* root) {        stack<TreeNode*> st;        vector<int> result;        if (root == NULL) return result;        st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();            st.pop();            result.push_back(node->val);            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）            if (node->right) st.push(node->right); // 空节点不入栈        }        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了        return result;    }};</code></pre><h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><h4 id="迭代法中序遍历"><a href="#迭代法中序遍历" class="headerlink" title="迭代法中序遍历"></a>迭代法中序遍历</h4><p>中序遍历代码如下：（详细注释）</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> inorderTraversal(TreeNode* root) {        vector<int> result;        stack<TreeNode*> st;        if (root != NULL) st.push(root);        while (!st.empty()) {            TreeNode* node = st.top();            if (node != NULL) {                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）                st.push(node);                          // 添加中节点                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           // 将空节点弹出                node = st.top();    // 重新取出栈中元素                st.pop();                result.push_back(node->val); // 加入到结果集            }        }        return result;    }};</code></pre><p><strong>中节点放入栈之后，紧接着放入一个空指针作为标记</strong></p><h2 id="102-二叉树的层序遍历——广度优先"><a href="#102-二叉树的层序遍历——广度优先" class="headerlink" title="102.二叉树的层序遍历——广度优先"></a>102.二叉树的层序遍历——广度优先</h2><p>广度用队列，深度用栈</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203144842988.png" alt="102.二叉树的层序遍历" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//迭代法  主要还是看迭代法class Solution {public:    vector<vector<int>> levelOrder(TreeNode* root) {        queue<TreeNode*> que;        if (root != NULL) que.push(root);        vector<vector<int>> result;        while (!que.empty()) {            int size = que.size();            vector<int> vec;            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的            for (int i = 0; i < size; i++) {                TreeNode* node = que.front();                que.pop();                vec.push_back(node->val);                if (node->left) que.push(node->left);                if (node->right) que.push(node->right);            }            result.push_back(vec);        }        return result;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 递归法class Solution {public:    void order(TreeNode* cur, vector<vector<int>>& result, int depth)    {        if (cur == nullptr) return;        if (result.size() == depth) result.push_back(vector<int>());        result[depth].push_back(cur->val);        order(cur->left, result, depth + 1);        order(cur->right, result, depth + 1);    }    vector<vector<int>> levelOrder(TreeNode* root) {        vector<vector<int>> result;        int depth = 0;        order(root, result, depth);        return result;    }};</code></pre><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣题目链接(opens new window)</a></p><p>翻转一棵二叉树。</p><p>思路：</p><p>采用递归前序的方法。</p><p><a href="https://www.programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%8B%93%E5%B1%95">题解还有更多其他方法</a></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void order(TreeNode* cur)    {        if (cur == nullptr) return;        TreeNode* temp = cur->left;        cur->left = cur->right;        cur->right = temp;        order(cur->left);        order(cur->right);    }    TreeNode* invertTree(TreeNode* root) {        order(root);        return root;    }};</code></pre><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>递归法：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool compare(TreeNode* left, TreeNode* right){        if (left == NULL && right != NULL) return false;        else if (left != NULL && right == NULL) return false;        else if (left == NULL && right == NULL) return true;        else if (left->val != right->val) return false;         else{            bool outside = compare(left->left, right->right);            bool inside = compare(left->right, right->left);            bool isSame = outside && inside;            return isSame;        }    }    bool isSymmetric(TreeNode* root) {        if(root == NULL) return true;        return compare(root->left,root->right);    }};</code></pre><p>迭代法的条件判断和递归的逻辑是一样的。</p><p>代码如下：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool isSymmetric(TreeNode* root) {        if (root == NULL) return true;        queue<TreeNode*> que;        que.push(root->left);   // 将左子树头结点加入队列        que.push(root->right);  // 将右子树头结点加入队列        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转            TreeNode* leftNode = que.front(); que.pop();            TreeNode* rightNode = que.front(); que.pop();            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的                continue;            }            // 左右一个节点不为空，或者都不为空但数值不相同，返回false            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {                return false;            }            que.push(leftNode->left);   // 加入左节点左孩子            que.push(rightNode->right); // 加入右节点右孩子            que.push(leftNode->right);  // 加入左节点右孩子            que.push(rightNode->left);  // 加入右节点左孩子        }        return true;    }};</code></pre><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p><p>返回它的最大深度 3 。</p><p><strong>我的代码：</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    //使用递归法    int order(TreeNode* cur, int depth){        if(cur == NULL) return depth;        depth++;        int d1 = order(cur->left,depth);        int d2 = order(cur->right,depth);        depth = max(d1,d2);        return depth;    }    int maxDepth(TreeNode* root) {        int depth = 0;        return order(root, depth);    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//迭代法 层序遍历class Solution {public:    int maxDepth(TreeNode* root) {        if(root == NULL) return 0;        int depth = 0;        queue<TreeNode*> que;        que.push(root);        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }            depth++;        }        return depth;    }};</code></pre><p>我的n叉树求最大深度代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    //使用递归法    int order(Node* cur, int depth){        if(cur == NULL) return depth;        depth++;        int maxDepth = depth;        for(int i = 0; i < cur->children.size(); i++){            int d1 = order(cur->children[i],depth);            maxDepth = max(d1,maxDepth);        }        return maxDepth;    }    int maxDepth(Node* root) {        int depth = 0;        return order(root, depth);    }};</code></pre><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int maxDepth(Node* root) {        if (root == 0) return 0;        int depth = 0;        for (auto child : root->children){            depth = max(depth, maxDepth(child));        }        return depth + 1;    }};</code></pre><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从<strong>根节点到最近叶子节点</strong>的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><p><img src="https://img-blog.csdnimg.cn/2021020315582586.png" alt="111.二叉树的最小深度1"></p><p>返回它的最小深度 2</p><p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度" style="zoom:33%;"></p><p>我的代码 ：</p><p>本题核心就是找到根节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">// 后续遍历class Solution {public:// 如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。// 反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。// 最后如果左右子树都不为空，返回左右子树深度最小值 + 1     int getDepth(TreeNode* node){        int depth = 0;        if(node == NULL) return 0;        //上式不等价于node->left == NULL && node->right == NULL 的情况，而是表明这个节点为空，不会增加深度。        int leftDepth = getDepth(node->left);//左        int rightDepth = getDepth(node->right);//右        // 中  但是没有要处理的        if(node->left == NULL && node->right != NULL) return rightDepth + 1;        if(node->left != NULL && node->right == NULL) return leftDepth + 1;        // if(node->left != NULL && node->right != NULL) return min(leftDepth,rightDepth) + 1;        // if(node->left == NULL && node->right == NULL) return 0 + 1;  叶子节点 深度加1        return min(leftDepth,rightDepth) + 1;  //最好还是在所有分支都给返回值，防止编译器判断为无返回值    }    int minDepth(TreeNode* root) {        return getDepth(root);    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//题解：前序class Solution {private:    int result;    void getdepth(TreeNode* node, int depth) {        if (node->left == NULL && node->right == NULL) {            result = min(depth, result);              return;        }        // 中 只不过中没有处理的逻辑        if (node->left) { // 左            getdepth(node->left, depth + 1);        }        if (node->right) { // 右            getdepth(node->right, depth + 1);        }        return ;    }public:    int minDepth(TreeNode* root) {        if (root == NULL) return 0;        result = INT_MAX;        getdepth(root, 1);        return result;    }};</code></pre><pre class=" language-lang-cpp"><code class="language-lang-cpp">//用队列进行层序遍历，逻辑比较清晰class Solution {public:    int minDepth(TreeNode* root) {        if (root == NULL) return 0;        int depth = 0;        queue<TreeNode*> que;        que.push(root);        while(!que.empty()) {            int size = que.size();            depth++; // 记录最小深度            for (int i = 0; i < size; i++) {                TreeNode* node = que.front();                que.pop();                if (node->left) que.push(node->left);                if (node->right) que.push(node->right);                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出                    return depth;                }            }        }        return depth;    }};</code></pre><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">力扣题目链接(opens new window)</a></p><p>给出一个完全二叉树，求出该树的节点个数。</p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20200920221638903.png" alt="img" style="zoom: 33%;"></p><p>我的代码（没有针对完全二叉树做优化）：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int countNodes(TreeNode* root) {        queue<TreeNode*> que;        if(root != NULL) que.push(root);        int num = 0;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                num++;                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }        }        return num;    }};</code></pre><p>题解：</p><p>这个就不是满二叉树</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img" style="zoom:33%;"></p><p>判断其子树是不是满二叉树(一直向左遍历的深度==一直向右遍历的深度)，如果是则利用公式（2^树深度 - 1 ，注意这里根节点深度为1）计算这个子树（满二叉树）的节点数量，如果不是则继续递归</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int countNodes(TreeNode* root) {        if (root == nullptr) return 0;        TreeNode* left = root->left;        TreeNode* right = root->right;        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便        while (left) {  // 求左子树深度            left = left->left;            leftDepth++;        }        while (right) { // 求右子树深度            right = right->right;            rightDepth++;        }        if (leftDepth == rightDepth) {            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0        }        //上面是返回条件        return countNodes(root->left) + countNodes(root->right) + 1;    }};</code></pre><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>这里强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210203155515650.png" alt="110.平衡二叉树2" style="zoom:50%;"></p><p>采用递归：</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int getHeight(TreeNode* node){        if(node == NULL) return 0;        int leftHeight = getHeight(node->left);        if(leftHeight == -1) return -1;        int rightHeight = getHeight(node->right);        if(rightHeight == -1) return -1;        if(abs(leftHeight-rightHeight)>1) return -1;        else return 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度    }    bool isBalanced(TreeNode* root) {        int result = getHeight(root);        if(result != -1) return true;        else return false;    }};</code></pre><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>题解：</p><p>to_string() 将数字转为string</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    void traversal(TreeNode* cur, string path, vector<string>& result) {        path += to_string(cur->val); // 中        if (cur->left == NULL && cur->right == NULL) {            result.push_back(path);            return;        }        if (cur->left) traversal(cur->left, path + "->", result); // 左        if (cur->right) traversal(cur->right, path + "->", result); // 右    }public:    vector<string> binaryTreePaths(TreeNode* root) {        vector<string> result;        string path;        if (root == NULL) return result;        traversal(root, path, result);        return result;    }};</code></pre><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接(opens new window)</a></p><p>计算给定二叉树的所有左叶子之和。</p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int sumleft(TreeNode* root , int leftfig, int sum){        // int leftfig = 0;        // int sum = 0;        if(root->left == NULL && root->right == NULL && leftfig == 1){            return sum + root->val;        }        int sum1 = 0;        int sum2 = 0;        if(root->left) sum1 = sumleft(root->left, 1 ,sum);        if(root->right) sum2 = sumleft(root->right, 0 ,sum);        return sum1 + sum2;    }    int sumOfLeftLeaves(TreeNode* root) {        int leftfig = 0;        int sum = 0;        if(root == NULL) return 0;        return sumleft(root, leftfig, sum);    }};</code></pre><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>我的代码：</p><p>层序遍历</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    int findBottomLeftValue(TreeNode* root) {        queue <TreeNode*> que;        que.push(root);        int result;        while(!que.empty()){            int size = que.size();            for(int i = 0; i < size; i++){                TreeNode* node = que.front();                que.pop();                if(i == 0) result = node->val; //关键是这一行，记录最后一层的第一个元素                if(node->left) que.push(node->left);                if(node->right) que.push(node->right);            }        }        return result;    }};</code></pre><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h2><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>我的代码：参考<strong>257. 二叉树的所有路径</strong></p><p>当不用遍历所有二叉树时，需要返回值，如本题，一旦找到路径就返回。</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    bool traversal(TreeNode* cur, int pathsum, int targetSum) {        pathsum += cur->val; // 中        if (cur->left == NULL && cur->right == NULL) {            if(pathsum == targetSum) return true;            else return false;        }        bool leftsig;        bool rightsig;        if (cur->left) leftsig = traversal(cur->left, pathsum, targetSum); // 左        if (cur->right) rightsig = traversal(cur->right, pathsum, targetSum); // 右        return leftsig || rightsig; //这里也可以优化一下，只要leftsig=1，就返回，right同理    }    bool hasPathSum(TreeNode* root, int targetSum) {        if(root == NULL) return false;        return traversal(root, 0, targetSum);    }};</code></pre><h2 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h2><p><a href="https://leetcode.cn/problems/path-sum-ii/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>我的代码：参考<strong>257. 二叉树的所有路径</strong></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    void traversal(TreeNode* cur, vector<int> path, int pathsum, int targetSum, vector<vector<int>>& path_results) {        path.push_back(cur->val);        pathsum += cur->val; // 中        if (cur->left == NULL && cur->right == NULL) {            if(pathsum == targetSum){                path_results.push_back(path);                return ;            }             else return;        }        if (cur->left) traversal(cur->left, path, pathsum, targetSum, path_results); // 左        if (cur->right) traversal(cur->right, path, pathsum, targetSum, path_results); // 右        return ;    }    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {        vector<vector<int>> path_results;        vector<int> path;        if(root == NULL) return path_results;        traversal(root, path, 0, targetSum, path_results);        return path_results;    }};</code></pre><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树*"></a>106.从中序与后序遍历序列构造二叉树*</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接(opens new window)</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/20210203154316774-16775032045302.png" alt="106. 从中序与后序遍历序列构造二叉树1" style="zoom:100%;"></p><p>思路：</p><p>以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* traversal(vector<int>& inorder, vector<int>& postorder) {            // 第一步 终止条件        if (postorder.size() == 0) return NULL;        int rootValue = postorder[postorder.size() - 1];        TreeNode* root = new TreeNode(rootValue);        if (postorder.size() == 1) return root;// 叶子节点        // 找到中序遍历的切割点        int delimiterIndex;        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {            if (inorder[delimiterIndex] == rootValue) break;        }        // 切割中序数组  这题关键：这里切割的写法        // 左闭右开区间：[0, delimiterIndex)        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);        // [delimiterIndex + 1, end)        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );        // 切割后序        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());        // [leftInorder.size(), end)        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()- 1);        root->left = traversal(leftInorder, leftPostorder);        root->right = traversal(rightInorder, rightPostorder);        return root;        }    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {        if (inorder.size() == 0 || postorder.size() == 0) return NULL;        return traversal(inorder, postorder);    }};</code></pre><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">力扣题目地址(opens new window)</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img" style="zoom:50%;"></p><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* recursion(vector<int> nums) {        if(nums.size() == 0) return NULL;        int rootValue = 0;        int rootValueIndex = 0;        for(int i = 0; i < nums.size(); i++){            if(nums[i]>rootValue){                rootValue = nums[i];                rootValueIndex = i;            }        }        TreeNode* root = new TreeNode(rootValue);        vector<int> leftnums(nums.begin(), nums.begin() + rootValueIndex);        vector<int> rightnums(nums.begin() + rootValueIndex + 1, nums.end());        root->left = recursion(leftnums);        root->right = recursion(rightnums);        return root;    }    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {        return recursion(nums);    }};</code></pre><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接(opens new window)</a></p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>我的代码：</p><p>也可以不new，在root1上改</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {        TreeNode* root = new TreeNode();        if(root1 == NULL) return root2;        if(root2 == NULL) return root1;        root->val = root1->val + root2->val;        root->left = mergeTrees(root1->left,root2->left);        root->right = mergeTrees(root1->right,root2->right);        return root;     }};</code></pre><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">力扣题目地址(opens new window)</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>思路：</p><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>我的代码：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* searchBST(TreeNode* root, int val) {        if(root == NULL) return NULL;        if(root->val == val){            return root;        }        if(root->val < val){            return searchBST(root->right, val);        }        if(root->val > val){            return searchBST(root->left, val);        }        return NULL;    }};</code></pre><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树*"></a>98.验证二叉搜索树*</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>思路：</p><p>这道题目比较容易陷入两个陷阱：</p><ul><li>陷阱1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。<strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。</p><p>例如： [10,5,15,null,null,6,20] 这个case：</p><p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树" style="zoom: 67%;"></p><p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p><ul><li>陷阱2</li></ul><p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p><p>此时可以初始化比较元素为longlong的最小值<code>long long maxVal = LONG_MIN;</code></p><p><strong>核心思想：二叉搜索树如果按左中右（中序）顺序遍历，则数据是递增的</strong></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//先变成数组class Solution {private:    vector<int> vec;    void traversal(TreeNode* root) {        if (root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }public:    bool isValidBST(TreeNode* root) {        vec.clear(); // 不加这句在leetcode上也可以过，但最好加上        traversal(root);        for (int i = 1; i < vec.size(); i++) {            // 注意要小于等于，搜索树里不能有相同元素            if (vec[i] <= vec[i - 1]) return false;        }        return true;    }};</code></pre><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接(opens new window)</a></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>我的代码（参考98）：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> vec;    void traversal(TreeNode* root){        if(root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }    int getMinimumDifference(TreeNode* root) {        traversal(root);        int min_sub = 100000;        for (int i = 1; i < vec.size(); i++) {            min_sub = min(min_sub,vec[i] - vec[i - 1]);        }        return min_sub;    }};</code></pre><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>思路：</p><p>针对任意二叉树，可以使用map（有序，key是次数，value是节点值）</p><p>这里是二叉搜索树，是递增的，可以只比较相邻元素</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    vector<int> vec;    void traversal(TreeNode* root){        if(root == NULL) return;        traversal(root->left);        vec.push_back(root->val); // 将二叉搜索树转换为有序数组        traversal(root->right);    }    vector<int> findMode(TreeNode* root) {        traversal(root);        int left = 0;        int maxnum = 0;        vector<int> results;        for (int right = 0; right < vec.size(); right++) {            if(vec[left] != vec[right]) left = right;            if(maxnum < right - left){                maxnum = right - left;                results.clear(); //这里很关键                results.push_back(vec[right]);            }else if(maxnum == right - left){                results.push_back(vec[right]);            }        }        return results;    }};</code></pre><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>我的代码：</p><p>返回子树中找到目标值的个数</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* result = NULL;    int traversal(TreeNode* node, TreeNode* p, TreeNode* q) {        if(result != NULL) return 2;        int leftfig = 0;        int rightfig = 0;        if(node->left) leftfig = traversal(node->left, p, q);        else leftfig = 0;        if(node->right) rightfig = traversal(node->right, p, q);        else rightfig = 0;        if(leftfig == 1 && rightfig == 1) {            result = node;            return 2;        }else if((leftfig == 1 && rightfig == 0)or(leftfig == 0 && rightfig == 1)){            if(node == p || node == q) {                result = node;                return 2;            }            else return 1;        }         else if(leftfig == 0 && rightfig == 0) {            if(node == p || node == q) return 1;            else return 0;        }        else return 2;    }    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        traversal(root, p, q);        return result;    }};</code></pre><p>题解：</p><p>主要是理清这张图的逻辑</p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/202102041512582.png" alt="236.二叉树的最近公共祖先2" style="zoom:50%;"></p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        if (root == q || root == p || root == NULL) return root;        TreeNode* left = lowestCommonAncestor(root->left, p, q);        TreeNode* right = lowestCommonAncestor(root->right, p, q);        if (left != NULL && right != NULL) return root;        if (left == NULL && right != NULL) return right;        else if (left != NULL && right == NULL) return left;        else  { //  (left == NULL && right == NULL)            return NULL;        }    }};</code></pre><ol><li>求最小公共祖先，需要<strong>从底向上遍历</strong>，那么二叉树，只能通过<strong>后序遍历（</strong>即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><pre class=" language-lang-cpp"><code class="language-lang-cpp">//后序遍历left = 递归函数(root->left);  // 左right = 递归函数(root->right); // 右left与right的逻辑处理;         // 中</code></pre><p>搜索一条边的写法（本题，下题）：</p><pre class=" language-lang-text"><code class="language-lang-text">if (递归函数(root->left)) return ;if (递归函数(root->right)) return ;</code></pre><p>搜索整个树写法：</p><pre class=" language-lang-text"><code class="language-lang-text">left = 递归函数(root->left);right = 递归函数(root->right);left与right的逻辑处理;</code></pre><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">//对于二叉搜索树，从上向下去递归遍历，第一次遇到 cur节点是数值在[p, q]区间中，那么cur就是 p和q的最近公共祖先class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {        while(root) {            if (root->val > p->val && root->val > q->val) {                root = root->left;            } else if (root->val < p->val && root->val < q->val) {                root = root->right;            } else return root;        }        return NULL;    }};</code></pre><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/insertbst-16777246991064.jpg" alt="img" style="zoom:50%;"></p><p>我的代码：</p><p>迭代法</p><p>找到空的就插入新节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* insertIntoBST(TreeNode* root, int val) {        TreeNode* node = root;         TreeNode* insert = new TreeNode(val);//注意新插入节点的创建方式        if(node == NULL) return insert;        while(node != NULL){            if(val > node->val) {                if(node->right) node = node->right;                else {                    node->right = insert;                    break;                }            }            if(val < node->val) {                if(node->left) node = node->left;                else {                    node->left = insert;                    break;                }            }        }        return root;    }};</code></pre><p>题解：</p><p>记录了父节点</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* insertIntoBST(TreeNode* root, int val) {        if (root == NULL) {            TreeNode* node = new TreeNode(val);            return node;        }        TreeNode* cur = root;        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点        while (cur != NULL) {            parent = cur;            if (cur->val > val) cur = cur->left;            else cur = cur->right;        }        TreeNode* node = new TreeNode(val);        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值        else parent->right = node;        return root;    }};</code></pre><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点*"></a>450.删除二叉搜索树中的节点*</h2><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接(opens new window)</a></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p><p>思路：</p><ol><li><p>暴力：中序遍历后变成数组再处理</p></li><li><p><strong>分析各种可能的情况</strong></p><p> 有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为该节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为该节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为该节点。</li></ul></li></ul></li></ol><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* deleteNode(TreeNode* root, int key) {        if (root == nullptr) return nullptr; //1        if (root->val == key) {            if(root->left == nullptr && root->right == nullptr) return nullptr; //2            if(root->left == nullptr) return root->right; //3            if(root->right == nullptr) return root->left; //4            if(root->left != nullptr && root->right != nullptr){ //5                // 找右子树最左面的节点                TreeNode* cur = root->right;                 while(cur->left != nullptr) {                    cur = cur->left;                }                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置                root = root->right;                 return root;            }         }   //上面相当于把新的节点返回给上一层，上一层就要用 root->left 或者 root->right接住，代码如下：        if (root->val > key) root->left = deleteNode(root->left, key);        if (root->val < key) root->right = deleteNode(root->right, key);        return root;    }};</code></pre><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树*"></a>669. 修剪二叉搜索树*</h2><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">力扣题目链接</a></p><p><img src="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/trim2.jpg" alt="img" style="zoom:33%;"></p><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {public:    TreeNode* trimBST(TreeNode* root, int low, int high) {        if (root == nullptr ) return nullptr;        if (root->val < low) {            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点            return right;        }        if (root->val > high) {            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点            return left;        }        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子        return root;    }};</code></pre><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">力扣题目链接(opens new window)</a></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>思路：</p><ol><li>选取数组中间的节点为根节点，分割数组为左右两部分</li><li>分别在两部分中间再找中间节点</li></ol><p>题解：</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    TreeNode* traversal(vector<int>& nums, int left, int right) {        if (left > right) return nullptr;        int mid = left + ((right - left) / 2); // 防止溢出         // 等价于int mid = (left + right) / 2;        TreeNode* root = new TreeNode(nums[mid]);        root->left = traversal(nums, left, mid - 1);        root->right = traversal(nums, mid + 1, right);        return root;    }public:    TreeNode* sortedArrayToBST(vector<int>& nums) {        TreeNode* root = traversal(nums, 0, nums.size() - 1);        return root;    }};</code></pre><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">力扣题目链接(opens new window)</a></p><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>思路：</p><p>右中左序遍历，需要记录前一个节点的数值</p><pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {private:    int pre = 0; // 记录前一个节点的数值    void traversal(TreeNode* cur) { // 右中左遍历        if (cur == NULL) return;        traversal(cur->right);        cur->val += pre;        pre = cur->val;        traversal(cur->left);    }public:    TreeNode* convertBST(TreeNode* root) {        pre = 0;        traversal(root);        return root;    }};</code></pre>]]></content>
    
    
    <summary type="html">#二叉树理论基础篇
C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn

unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表

一棵树当中没有子结点（即度为0）的结点称为叶子结点，简称“叶子”

二叉树主要有两种遍历方式：

 1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
 2. 广度优先遍历：一层一层的去遍历。

 * 深度优先遍历 * 前序遍历（递归法，迭代法）
    * 中序遍历（递归法，迭代法）
    * 后序</summary>
    
    
    
    <category term="CPP" scheme="https://youngyyp.github.io/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>pytorch冻结网络模型</title>
    <link href="https://youngyyp.github.io/2022/11/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/"/>
    <id>https://youngyyp.github.io/2022/11/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/</id>
    <published>2022-11-08T01:49:41.000Z</published>
    <updated>2023-03-11T06:28:19.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冻结模型"><a href="#冻结模型" class="headerlink" title="冻结模型"></a>冻结模型</h2><p><a href="https://www.zhihu.com/question/311095447/answer/589307812">https://www.zhihu.com/question/311095447/answer/589307812</a></p><pre class=" language-lang-python"><code class="language-lang-python"># 冻结model.fc1.weight.requires_grad = Falseoptimizer = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=0.1)# # compute loss # loss.backward()# optmizer.step()# 解冻model.fc1.weight.requires_grad = Trueoptimizer.add_param_group({'params': model.fc1.parameters()})</code></pre><p><strong>终极方法代码实现：</strong></p><pre class=" language-lang-python"><code class="language-lang-python">from collections.abc import Iterabledef set_freeze_by_names(model, layer_names, freeze=True):    if not isinstance(layer_names, Iterable):        layer_names = [layer_names]    for name, child in model.named_children():        if name not in layer_names:            continue        for param in child.parameters():            param.requires_grad = not freezedef freeze_by_names(model, layer_names):    set_freeze_by_names(model, layer_names, True)def unfreeze_by_names(model, layer_names):    set_freeze_by_names(model, layer_names, False)def set_freeze_by_idxs(model, idxs, freeze=True):    if not isinstance(idxs, Iterable):        idxs = [idxs]    num_child = len(list(model.children()))    idxs = tuple(map(lambda idx: num_child + idx if idx < 0 else idx, idxs))    for idx, child in enumerate(model.children()):        if idx not in idxs:            continue        for param in child.parameters():            param.requires_grad = not freezedef freeze_by_idxs(model, idxs):    set_freeze_by_idxs(model, idxs, True)def unfreeze_by_idxs(model, idxs):    set_freeze_by_idxs(model, idxs, False)</code></pre><pre class=" language-lang-python"><code class="language-lang-python"># 冻结第一层freeze_by_idxs(model, 0)# 冻结第一、二层freeze_by_idxs(model, [0, 1])#冻结倒数第一层freeze_by_idxs(model, -1)# 解冻第一层unfreeze_by_idxs(model, 0)# 解冻倒数第一层unfreeze_by_idxs(model, -1)# 冻结 em层freeze_by_names(model, 'em')# 冻结 fc1, fc3层freeze_by_names(model, ('fc1', 'fc3'))# 解冻em, fc1, fc3层unfreeze_by_names(model, ('em', 'fc1', 'fc3'))</code></pre>]]></content>
    
    
    <summary type="html">冻结模型
https://www.zhihu.com/question/311095447/answer/589307812

# 冻结
model.fc1.weight.requires_grad = False
optimizer = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=0.1)
# 
# compute loss 
# loss.backward()
# optmizer.step()

# 解冻
model.fc1.weight.requires_grad = True
optimizer</summary>
    
    
    
    <category term="计算机视觉" scheme="https://youngyyp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="pytorch" scheme="https://youngyyp.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>UAV和卫星图像配准思路</title>
    <link href="https://youngyyp.github.io/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    <id>https://youngyyp.github.io/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/</id>
    <published>2022-11-08T01:49:41.000Z</published>
    <updated>2023-03-11T06:21:00.597Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>针对UAV和卫星匹配的特定任务，在图像检索的基础上进行特征匹配（可细分为图像检索和特征匹配两个任务）</p><ul><li><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><ul><li>通过特征匹配结果协助进行图像检索<ul><li>CMU&amp;ICRA22 UAV俯瞰视觉定位竞赛（-2022.9.1）<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114102144712.png" alt="image-20221114102144712" style="zoom:50%;"></li></ul></li></ul></li><li>通过特征匹配结果求解更精确的无人机位姿<ul><li>UAV Pose Estimation using Cross-view Geolocalization with Satellite Imagery (ICRA 2019)<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114102216892.png" alt="image-20221114102216892"></li></ul></li></ul></li><li>通过特征匹配的feature map促进图像检索网络的训练<ul><li>Multiple-environment Self-adaptive Network for Aerial-view Geo-localization  (arXiv 2022.4.18)<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114102429372.png" alt="image-20221114102429372"></li></ul></li></ul></li></ul></li><li></li><li><h3 id="数据集：UAV和卫星图像的对应-相对位姿"><a href="#数据集：UAV和卫星图像的对应-相对位姿" class="headerlink" title="数据集：UAV和卫星图像的对应+相对位姿"></a>数据集：UAV和卫星图像的对应+相对位姿</h3><ul><li>注：大多数数据集为图像检索数据集，即仅存在图像级的对应，不一定有每张图像的位姿，且没有点对点的监督信息<ul><li>==&gt; 若要训练特征点匹配网络，只能采用自监督(随机单应变换等)/弱监督（相机位姿监督）的方法<ul><li>特征匹配自监督训练方式可参考：<ul><li>SuperPoint: Self-Supervised Interest Point Detection and Description（CVPR 2018）<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114104109994.png" alt="image-20221114104109994" style="zoom:33%;"></li></ul></li><li>UnSuperPoint:End-to-End Unsupervised Interest Point Detector And Descriptor (arXiv 2019)<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114110939059.png" alt="image-20221114110939059" style="zoom:33%;"></li></ul></li><li>Digging Into Self-Supervised Learning of Feature Descriptors (3DV 2021)<ul><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114103344274.png" alt="image-20221114103344274" style="zoom:33%;"></li></ul></li><li>Looking Beyond Corners: Contrastive Learning of Visual Representations for Keypoint Detection and Description Extraction (arXiv 2021.12)<ul><li>对比学习的方式训练</li><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114103411106.png" alt="image-20221114103411106"></li></ul></li></ul></li></ul></li></ul></li><li><h3 id="数据特点："><a href="#数据特点：" class="headerlink" title="数据特点："></a>数据特点：</h3><ul><li>旋转角度大==&gt;可采用旋转不变CNN来改进网络<ul><li>A case for using rotation invariant features in state of the art feature matchers （CVPRW 2022）</li><li><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/image-20221114104424545.png" alt="image-20221114104424545" style="zoom:33%;"></li></ul></li><li>UAV的斜视视角和卫星的俯视视角==&gt;不同视角的转化、不同色彩风格的转化</li></ul></li><li><p>UAV-Satellite View Synthesis for Cross-view Geo-Localization （IEEE Transactions on Circuits and Systems for Video Technology 2021）</p><pre><code>  - &lt;img src="开题相关/image-20221114104920560.png" alt="image-20221114104920560" style="zoom:33%;" /&gt;</code></pre></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">* 针对UAV和卫星匹配的特定任务，在图像检索的基础上进行特征匹配（可细分为图像检索和特征匹配两个任务）
   
    * 目的：
       * 通过特征匹配结果协助进行图像检索 * CMU&amp;amp;ICRA22 UAV俯瞰视觉定位竞赛（-2022.9.1） * 
            
            
         
         
       * 通过特征匹配结果求解更精确的无人机位姿 * UAV Pose Estimation using Cross-view Geolocalization with Satellite Imagery (ICRA 2019) * 
</summary>
    
    
    
    <category term="计算机视觉" scheme="https://youngyyp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="图像匹配" scheme="https://youngyyp.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>UAV和卫星图像配准论文阅读</title>
    <link href="https://youngyyp.github.io/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/"/>
    <id>https://youngyyp.github.io/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/</id>
    <published>2022-11-08T01:49:41.000Z</published>
    <updated>2023-03-11T06:21:01.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UAV-Geolocalization-Using-Satellite-Imagery"><a href="#UAV-Geolocalization-Using-Satellite-Imagery" class="headerlink" title="UAV Geolocalization Using Satellite Imagery"></a><a href="https://abhinavtripathi95.github.io/lets-talk/technical/2020/08/03/uav-geolocalization.html">UAV Geolocalization Using Satellite Imagery</a></h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>无人机通常靠GPS来获得全局姿态估计，然而为了使用GPS进行精确的地理定位，无人机必须能够从四个或更多的GPS卫星接收直接的视线。这可能是一个问题，如果存在高楼大厦，山脉或干扰器，可以阻碍来自卫星的信号。<br>那么我们能在没有GPS的情况下推断出无人机的全局姿态吗?<br>答案是肯定的，我们可以使用无人机下面附加的相机传感器来比较场景和卫星图像，并推断出无人机的位置。</p><h3 id="Geolocalization-as-an-Image-Matching-Problem"><a href="#Geolocalization-as-an-Image-Matching-Problem" class="headerlink" title="Geolocalization as an Image Matching Problem"></a>Geolocalization as an Image Matching Problem</h3><p>考虑这样一个场景，您有一个卫星图像数据库，其中标注了它们的位置。<br>通过将无人机相机的图像与数据库进行精确匹配，可以很好地获得无人机的经纬度近似。<br>为了从卫星数据库中检索相似的图像，我们必须能够精确地匹配卫星图像与无人机相机馈送。<br>因此，在本研究中，我们将自己局限于<strong>航空图像匹配问题</strong>，训练一个深度学习模型，<strong>可以精确匹配来自卫星和无人机相机的图像</strong>。</p><h2 id="UAV-Pose-Estimation-using-Cross-view-Geolocalization-with-Satellite-Imagery-ICRA-2019"><a href="#UAV-Pose-Estimation-using-Cross-view-Geolocalization-with-Satellite-Imagery-ICRA-2019" class="headerlink" title="UAV Pose Estimation using Cross-view Geolocalization with Satellite Imagery (ICRA 2019)"></a>UAV Pose Estimation using Cross-view Geolocalization with Satellite Imagery (ICRA 2019)</h2><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221031184827896.png" alt="image-20221031184827896" style="zoom:30%;"></p><p>数据集是从谷歌地图上收集的“Sample matching pairs of UAV images from Google Earth (top row) and satellite images from Google Maps (bottom row).”</p><p>scene localization network 用于对每张图片生成一个描述符，计算欧式距离d，用于计算权重</p><p>Camera Localization network 是一个双分支网络，第一个分支输出一个热力图，最大值位置代表x,y水平位置，第二个分支直接回归垂直位置，朝向(heading)和倾斜角度(tilt)</p><p>Cross-view Geolocalization 模块，将多张图像经过两个网络后的结果根据d计算加权，生成最终相机位姿</p><h2 id="Visual-Localization-with-Google-Earth-Images-for-Robust-Global-Pose-Estimation-of-UAVs（ICRA-2020）"><a href="#Visual-Localization-with-Google-Earth-Images-for-Robust-Global-Pose-Estimation-of-UAVs（ICRA-2020）" class="headerlink" title="Visual Localization with Google Earth Images for Robust Global Pose Estimation of UAVs（ICRA 2020）"></a>Visual Localization with Google Earth Images for Robust Global Pose Estimation of UAVs（ICRA 2020）</h2><p>数据集：<a href="https://www.dynsyslab.org/cloud-dataset/">CLOUD: Canadian Longterm Outdoor UAV Dataset | Dynamic Systems Lab | Prof. Angela Schoellig (dynsyslab.org)</a></p><p>包含季节变化和光照变化的无人机图像，以及UAV的GPS位置信息和姿态信息</p><p>还包括对应的卫星图像（由谷歌地球生成）</p><p>在这项工作中，所有真实的和渲染的图像都是用指向最低点的相机拍摄的</p><h2 id="UAV-Localization-Using-Autoencoded-Satellite-Images（IEEE-ROBOTICS-AND-AUTOMATION-LETTERS-2021）"><a href="#UAV-Localization-Using-Autoencoded-Satellite-Images（IEEE-ROBOTICS-AND-AUTOMATION-LETTERS-2021）" class="headerlink" title="UAV Localization Using Autoencoded Satellite Images（IEEE ROBOTICS AND AUTOMATION LETTERS 2021）"></a>UAV Localization Using Autoencoded Satellite Images（IEEE ROBOTICS AND AUTOMATION LETTERS 2021）</h2><p>和上一篇是一个团队</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221031194705659.png" alt="image-20221031194705659" style="zoom:33%;"></p><h3 id="动机："><a href="#动机：" class="headerlink" title="动机："></a>动机：</h3><p>由于谷歌地图中用于重建的卫星图像是多年前拍摄的，在照明、小对象移动(例如车辆、拖车)、大的结构变化(例如建筑物的增建/拆除)以及不寻常的对象重建方面与现场图像有所不同，特别是对于树木等非矩形对象。这使得<strong>基于特征的方法在很多情况下很难获得准确和稳健的结果。</strong></p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>图像在GE中围绕所需的飞行路线进行渲染。对这些特定于路径的图像进行自动编码器训练，以将它们压缩成小得多的矢量表示。同样的自动编码器也用于压缩实时图像。通过内积核将压缩的实时图像向量与附近的所有压缩GE图像向量进行比较。这会产生与每个相应GE图像姿势相关联的权重。<br>根据这些权重，计算出带有伴随协方差的经度、纬度和航向的位置。</p><h3 id="数据集："><a href="#数据集：" class="headerlink" title="数据集："></a>数据集：</h3><p>uav图像+GE图像</p><p>一天中六个不同时刻的1.1公里路径上的真实无人机图像数据集上进行了演示，覆盖了几种照明条件</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>查找速度快</p><h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><p>不是端到端训练</p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>用最新的基于特征的方法进行尝试</p><h2 id="UAV-Satellite-View-Synthesis-for-Cross-view-Geo-Localization"><a href="#UAV-Satellite-View-Synthesis-for-Cross-view-Geo-Localization" class="headerlink" title="UAV-Satellite View Synthesis for Cross-view Geo-Localization"></a>UAV-Satellite View Synthesis for Cross-view Geo-Localization</h2><p>（IEEE Transactions on Circuits and Systems for Video Technology TCSVT 2021)</p><h3 id="数据集：-1"><a href="#数据集：-1" class="headerlink" title="数据集："></a>数据集：</h3><p>本研究使用的数据集是大学1652[30]，其中包含来自全球72所大学的1652栋建筑（1652个地点）。据我们所知，这是迄今为止<strong>唯一一个同时包含无人机视图图像和卫星视图图像的数据集</strong>。每个建筑物都与三个不同视角的图像相关联（见图7），包括一个卫星视图图像、54个不同高度和角度的无人机视图图像以及一个或多个地面视图图像。在本文中，我们使用了卫星图像（垂直视图）和无人机图像（斜视图）。大多数无人机视图是倾斜的，这为使用透视投影变换实现更好的匹配性能提供了巨大的潜力。</p><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221102151027518.png" alt="image-20221102151027518" style="zoom:33%;"></p><p>通过数据集的先验信息进行的透视投影变换（？？？），然后采用GAN网络生成和卫星图像风格相似的图像（同时视角也更相似），如下图所示</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221101105655053.png" alt="image-20221101105655053" style="zoom: 80%;"></p><p>随后对特征图采用一个方环分割策略来获取距离图像中心不同距离的上下文特征信息</p><pre><code>如图6所示，我们将高级特征分为正方形环形分区中的几个部分。由于地理目标通常位于图像的中心，周围有上下文信息，分割方法不仅可以获得地理目标信息（区域A和B），还可以获得与地理目标具有不同距离的若干上下文信息部分（区域C和D）。因此，我们可以显式地利用上下文信息来优化PCL。我们观察到，我们的分割策略在本质上对图像旋转是鲁棒的。例如，当将图6中中间行的图像旋转到顶行的图像时，四个区域（A、B、C和D）仍然包含与中间图像的对应区域相同的信息。因此，根据方环分割策略设计的网络对图像旋转具有良好的鲁棒性</code></pre><p>(缺陷：只对90°旋转鲁棒，且目标不一定位于图像中心)</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221101110400421.png" alt="image-20221101110400421" style="zoom:33%;"></p><p>最后对图片生成一个描述符，并比较和其他图像的余弦相似性</p><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><p>UAV图像和卫星图像的视野范围基本一样？</p><p>是否能生成已知对应关系的GAN网络</p><h2 id="University-1652-A-Multi-view-Multi-source-Benchmark-for-Drone-based-Geo-localization"><a href="#University-1652-A-Multi-view-Multi-source-Benchmark-for-Drone-based-Geo-localization" class="headerlink" title="University-1652: A Multi-view Multi-source Benchmark for Drone-based Geo-localization"></a>University-1652: A Multi-view Multi-source Benchmark for Drone-based Geo-localization</h2><p>（ACM Multimedia 2020）</p><p>针对跨视角地理定位问题，提出一个baseline和dataset</p><p>数据集包含三种视角（地面、无人机、卫星）</p><p>Google Earth中的3D引擎用于模拟相机的不同视点。</p><h2 id="Joint-Representation-Learning-and-Keypoint-Detection-for-Cross-View-Geo-Localization"><a href="#Joint-Representation-Learning-and-Keypoint-Detection-for-Cross-View-Geo-Localization" class="headerlink" title="Joint Representation Learning and Keypoint Detection for Cross-View Geo-Localization"></a>Joint Representation Learning and Keypoint Detection for Cross-View Geo-Localization</h2><p>(IEEE TRANSACTIONS ON IMAGE PROCESSING 2022)</p><p>我们的模型自动从卫星视图图像和无人机视图图像的相应区域提取关键点，而无需额外监督</p><p>USAM提取的关键点仅用于增强图像的特征识别，而不是检测实际映射。</p><p>（1）我们的方法不需要额外的注释，例如相机姿势、深度等。</p><p>（2） 我们的方法不进行方位估计。</p><p>（3） 所提出的方法考虑了点对点关系</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221108091237749.png" alt="image-20221108091237749"></p><p>USC相当于算子</p><p>-1 -1 -1</p><p>-1  8 -1</p><p>-1 -1 -1</p><p><a href="https://github.com/AggMan96/RK-Net">AggMan96/RK-Net: Code for RK-Net (github.com)</a></p><h2 id="Real-time-Geo-localization-Using-Satellite-Imagery-and-Topography-for-Unmanned-Aerial-Vehicles"><a href="#Real-time-Geo-localization-Using-Satellite-Imagery-and-Topography-for-Unmanned-Aerial-Vehicles" class="headerlink" title="Real-time Geo-localization Using Satellite Imagery and Topography for Unmanned Aerial Vehicles"></a>Real-time Geo-localization Using Satellite Imagery and Topography for Unmanned Aerial Vehicles</h2><p>使用谷歌地球提供的3D模型+blender渲染卫星图像和深度图像</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221108110109358.png" alt="image-20221108110109358" style="zoom: 50%;"></p><h2 id="Multiple-environment-Self-adaptive-Network-for-Aerial-view-Geo-localization"><a href="#Multiple-environment-Self-adaptive-Network-for-Aerial-view-Geo-localization" class="headerlink" title="Multiple-environment Self-adaptive Network for Aerial-view Geo-localization"></a>Multiple-environment Self-adaptive Network for Aerial-view Geo-localization</h2><p>(arXiv 2022.4.18)</p><p>现有的方法在真实的天气（如雨天和雾天）下会遇到较大的性能下降，因为它们没有考虑训练数据和多个测试环境之间的域转换。为了缩小这一领域差距，我们提出了一种多环境自适应网络（MuSe-Net），以动态调整环境变化引起的领域偏移。<br>特别是，MuSe-Net采用了包含一个多环境类型提取网络和一个自适应特征提取网络的两分支神经网络。顾名思义，多环境风格提取网络用于提取与环境相关的风格信息，而自适应特征提取网络利用自适应调制模块来动态地最小化与环境有关的风格差距。</p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221108105026501.png" alt="image-20221108105026501"></p><h2 id="CMU-amp-ICRA22-UAV俯瞰视觉定位竞赛"><a href="#CMU-amp-ICRA22-UAV俯瞰视觉定位竞赛" class="headerlink" title="CMU&amp;ICRA22 UAV俯瞰视觉定位竞赛"></a>CMU&amp;ICRA22 UAV俯瞰视觉定位竞赛</h2><p>[ICRA2022] General Place Recognition: Visual Terrain Relative Navigation</p><p><a href="https://www.bilibili.com/video/BV1NG411G78L/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0bb4d13f4bd26eaf7f64c37f29dc9f27">CMU &amp; ICRA22 UAV俯瞰视觉定位竞赛冠军技术方案分享|军事科学院_哔哩哔哩_bilibili</a></p><p><a href="https://www.sohu.com/a/587059840_121124366">CMU&amp;ICRA22 UAV俯瞰视觉定位竞赛亚军技术方案分享_VINS-Mono_VINS-Fusion_cvlife (sohu.com)</a></p><p><a href="https://sites.google.com/andrew.cmu.edu/gpr-competition/">竞赛官网GPR-Competition (google.com)</a></p><p><a href="https://github.com/MetaSLAM/ALTO">数据集：MetaSLAM/ALTO: ALTO (Aerial-view Large-scale Terrain-Oriented) dataset (github.com)</a></p><h3 id="数据集简介："><a href="#数据集简介：" class="headerlink" title="数据集简介："></a>数据集简介：</h3><p><a href="https://www.dropbox.com/sh/q1w5dmghbkut553/AAASkcJEpfsV9PbdLjszzdYAa/UAV?dl=0&amp;preview=readme.txt&amp;subfolder_nav_tracking=1">自述文件.txt (dropbox.com)</a></p><ul><li><p>俄亥俄州到匹兹堡的150公里长的飞行轨迹，使用直升飞机拍摄；</p></li><li><p>轨迹上包括几种不同难度的环境，包括城市/郊区、森林、农村和其他自然地形。</p></li><li>测试集中有几年前的图像（2017年同样是飞机拍的），同时也包括2012年的卫星图像</li><li>500*500像素</li><li>每张直升机图像有成对的卫星图像</li><li>包括GPS（全局的位置，亚米级精度, UTM坐标系）和IMU（四元数，相机相对于ECEF参考帧的方向）信息</li></ul><pre><code>This dataset contains nadir-facing RGB camera imagery captured via commercial helicopter (query), as wellas by high-altitude plane (reference, captured by USGS). We include some query telemetry information thatmay be useful for preprocessing or incorporated into your algorithm as contextual information.We provide three data splits: Train, Val, and Test. These are non-overlapping and include (24701), (3979), and (4209) images, respectively. These are all part of a 150km helicopter flight over a variety ofdifferent terrains, including Urban, Suburban, Rural, Dense Forest, Rivers, and Lakes.For ease of use with deep learning pipelines, we include the images in png format. All images are RGBand in 500x500 pixel resolution.In addition to the imagery in the Train and Val sets, we also provide a few csv files.  Their contents are as follows:    - gt_matches.csv: This file provides the ground truth best match between the query images and the reference images.        As states above, multiple query images may map to a single reference image. We determine "best match" by using the L2         distance of the UTM coordinates associated with the respective images.        - query_ind: The index of the query image.        - query_name: The name of the query image.        - ref_ind: The index of the reference image that best matches the query image.        - ref_name: The name of the reference image that best matches the query image.        - distance: The distance (meters) between the query and best matching reference image.    - query.csv: Telemetry information about each query image frame.        - easting: The ground truth Easting coordinate (meters) where the image was taken.        - northing: The ground truth Northing coordinate (meters) where the image was taken.        - altitude: The ground truth Altitude (meters) above the WGS84 ellipsoid surface.        - orient_x, orient_y, orient_z, orient_w: The orientation (scalar last quaternion) of the camera with respect the the ECEF reference frame.        - name: The name of the query image.    - reference.csv: Information about each reference image frame. Contains information about all offset reference images as well.        - easting: The ground truth Easting coordinate (meters) where the image was taken.        - northing: The ground truth Northing coordinate (meters) where the image was taken.        - name: The directory and name of the reference image.</code></pre><h2 id="Deep-learning-based-robust-positioning-for-all-weather-autonomous-driving"><a href="#Deep-learning-based-robust-positioning-for-all-weather-autonomous-driving" class="headerlink" title="Deep learning-based robust positioning for all-weather autonomous driving"></a>Deep learning-based robust positioning for all-weather autonomous driving</h2><p>定位能力负责精确预测AV在地图上的位置。AV的大多数核心组件（如预测和规划）都依赖于精确定位，例如在几厘米以内。尽管AV严重依赖于GPS等天基全球导航卫星系统的信号进行定位，但由于障碍物或反射，无线电信号可能在许多环境中丢失或退化。尤其是，在被高层建筑包围的城市地区，AV运营仍然极具挑战性。此外，GPS仅提供米级定位精度，而没有方位信息，这对AV乘客或周围环境中的乘客来说可能是致命的。</p><p>自我运动估计方法应利用摄像机（丰富、密集的视觉信息）、激光雷达（可见范围内的精细粒度）和雷达（对恶劣天气的免疫力）的优势，同时解决其相对缺点。</p><p>通过重建的质量来创建监督信号</p><p>自监督的核心思想<a href="https://blog.csdn.net/weixin_43882112/article/details/108610832">(54条消息) 【SLAM系列】Unsupervised Learning of Depth and Ego-Motion from Video<em>^</em>^ 晅菲的博客-CSDN博客</a></p><p><img src="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&amp;Satellite/%E8%B0%83%E7%A0%94/image-20221106211924306.png" alt="image-20221106211924306"></p>]]></content>
    
    
    <summary type="html">UAV Geolocalization Using Satellite Imagery
Motivation
无人机通常靠GPS来获得全局姿态估计，然而为了使用GPS进行精确的地理定位，无人机必须能够从四个或更多的GPS卫星接收直接的视线。这可能是一个问题，如果存在高楼大厦，山脉或干扰器，可以阻碍来自卫星的信号。
那么我们能在没有GPS的情况下推断出无人机的全局姿态吗?
答案是肯定的，我们可以使用无人机下面附加的相机传感器来比较场景和卫星图像，并推断出无人机的位置。

Geolocalization as an Image Matching Problem
考虑这样一个场景，您有一个卫星图像数</summary>
    
    
    
    <category term="计算机视觉" scheme="https://youngyyp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="图像匹配" scheme="https://youngyyp.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>LoFTR代码</title>
    <link href="https://youngyyp.github.io/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/"/>
    <id>https://youngyyp.github.io/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/</id>
    <published>2022-11-07T01:49:41.000Z</published>
    <updated>2023-03-11T06:13:25.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h2><pre class=" language-lang-python"><code class="language-lang-python">train.py "configs/data/megadepth_trainval_640.py" "configs/loftr/outdoor/loftr_ds_dense.py" --exp_name="outdoor-ds-640" --gpus=2 --num_nodes=1 --accelerator="ddp" --batch_size=1 --num_workers=0 --pin_memory=true --check_val_every_n_epoch=1 --log_every_n_steps=1 --flush_logs_every_n_steps=1 --limit_val_batches=1. --num_sanity_val_steps=10 --benchmark=True --max_epochs=30demo_loftr.py --weight /home/young/disk/code/feature_matching/LoFTR/logs/tb_logs/outdoor-ds-640-bs=6/version_2/checkpoints/epoch=6-auc@5=0.433-auc@10=0.606-auc@20=0.742.ckpt --input /home/young/disk/code/feature_matching/LoFTR/data/videos/video1.mp4</code></pre><h2 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h2><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20220918163227217.png" alt="image-20220918163227217"></p><p>修改train_list.txt来减少数据集的场景数目</p><p>dataset的数量不会影响显存占用，输入网络的图像尺寸才会影响显存占用</p><p>原数据量（640*640）的测试结果</p><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20220930105732853.png" alt="image-20220930105732853"></p><p>quadattention（640*640）</p><p>5 epoch  45.90  63.19  76.30</p><p>30 epoch  49.75  66.76  79.87</p><p>best 27 epoch  50.96  68.05  80.32</p><h3 id="test-1500-results"><a href="#test-1500-results" class="headerlink" title="test_1500 results"></a>test_1500 results</h3><p>loftr_od_ds</p><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20221012112651765.png" alt="image-20221012112651765"></p><p>quad_od_ds (my)</p><p>quad_od_ds(author)</p><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20221012123020189.png" alt="image-20221012123020189"></p><h3 id="用十分之一的数据测试结果"><a href="#用十分之一的数据测试结果" class="headerlink" title="用十分之一的数据测试结果"></a>用十分之一的数据测试结果</h3><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20220930110011605.png" alt="image-20220930110011605"></p><p>20epoch的效果相当于原2epoch</p><h2 id="原理部分"><a href="#原理部分" class="headerlink" title="原理部分"></a>原理部分</h2><p>线性attention</p><p><a href="https://zhuanlan.zhihu.com/p/157490738?from_voters_page=true">https://zhuanlan.zhihu.com/p/157490738?from_voters_page=true</a></p><p><img src="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/image-20221013150606391.png" alt="image-20221013150606391"></p><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><ul><li>全部替换为旋转不变的transformer（包括cnn）</li><li>添加几何信息指导</li><li>大尺寸图像（图像尺寸在训练和测试时都是一样的吗？必须固定？）</li><li>每一层attention都输出匹配对信息，最后对这些信息进行投票</li><li>加入光流法or直接法</li><li>粗配准的结果已经可以求一个大致的位姿，能否根据这个位姿进行优化</li><li>可以设置一个目标：以最少数量的点，得到最准确的位姿，这样取出来的点就是最准确的点</li><li>点的误差改为3d点的误差，而不是2d点</li><li>粗匹配结果计算单应矩阵后，对图像（或者feature map）进行单应变换得到粗对齐，<a href="https://blog.csdn.net/weixin_43605641/article/details/120970142?spm=1001.2014.3001.5501">(53条消息) RANSAC-Flow: generic two-stage image alignment（ECCV 2020）图像对齐论文代码详细分析_秋山丶雪绪的博客-CSDN博客</a></li><li>同时解决旋转和尺度的问题</li><li>局部性失效时才采用更全局的信息</li><li>图像对垂直化</li></ul>]]></content>
    
    
    <summary type="html">代码运行
train.py &quot;configs/data/megadepth_trainval_640.py&quot; &quot;configs/loftr/outdoor/loftr_ds_dense.py&quot; --exp_name=&quot;outdoor-ds-640&quot; --gpus=2 --num_nodes=1 --accelerator=&quot;ddp&quot; --batch_size=1 --num_workers=0 --pin_memory=true --check_val_every_n_epoch=1 --log_every_n_steps=1 --flush_logs_every_n_steps=1 --li</summary>
    
    
    
    <category term="计算机视觉" scheme="https://youngyyp.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="特征匹配" scheme="https://youngyyp.github.io/tags/%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
</feed>
