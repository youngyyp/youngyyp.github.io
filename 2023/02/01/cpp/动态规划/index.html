<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>动态规划 | young&#39;s blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="动态规划 | young&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Oops～，我崩溃了！找不到你想要的页面了">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="https://youngyyp.github.io/404.html">
<meta property="og:site_name" content="young&#39;s blog">
<meta property="og:description" content="Oops～，我崩溃了！找不到你想要的页面了">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-23T11:37:07.000Z">
<meta property="article:modified_time" content="2021-02-10T02:51:50.601Z">
<meta property="article:author" content="young">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="young's blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/1.png"/>
</a>
<div class="author">
    <span>young</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(47)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="计算机视觉">
                        
                        计算机视觉
                        <small>(20)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="嵌入式和硬件">
                        
                        嵌入式和硬件
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="软件使用">
                        
                        软件使用
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="深度学习基础">
                        
                        深度学习基础
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(13)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="FPGA">
                        
                        FPGA
                        <small>(6)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="47">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>目标检测</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>目标识别</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>深度学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>神经网络</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>事件相机</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数电</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>特征匹配</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图像处理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图像匹配</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>位姿估计</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>线路故障检测</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>障碍物识别</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>正交解调，FPGA</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>自平衡电桥</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Atlas</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>batch norm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>dehazing</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>haze removal</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo指令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>heze removal</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HLS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>modelsim</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pytorch</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SLAM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>test time adaptation</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ubuntu</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>verilog</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vivado</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>yolo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ZYNQ</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 "
           href="/2023/06/26/work/%E7%AE%80%E5%8E%86%E4%BC%98%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-06-26 22:14:08">2023/06/26</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/04/27/cpp/%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图">图</span>
            <span class="post-date" title="2023-04-27 10:13:33">2023/04/27</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/03/01/cpp/ACM%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ACM模式">ACM模式</span>
            <span class="post-date" title="2023-03-01 21:14:33">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/03/01/cpp/%E5%8D%95%E8%B0%83%E6%A0%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="单调栈">单调栈</span>
            <span class="post-date" title="2023-03-01 21:14:33">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/03/01/cpp/%E5%89%91%E6%8C%87offer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="剑指offer">剑指offer</span>
            <span class="post-date" title="2023-03-01 21:14:33">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 深度学习基础 "
           href="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="经典八股">经典八股</span>
            <span class="post-date" title="2023-03-01 21:14:33">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 深度学习基础 "
           href="/2023/03/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/transformer/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="transformer基础">transformer基础</span>
            <span class="post-date" title="2023-03-01 21:14:33">2023/03/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态规划">动态规划</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符串">字符串</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数组">数组</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E9%93%BE%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表">链表</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贪心算法">贪心算法</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E5%93%88%E5%B8%8C%E8%A1%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="哈希表">哈希表</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E5%9B%9E%E6%BA%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="回溯">回溯</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="栈与队列">栈与队列</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 CPP "
           href="/2023/02/01/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树">二叉树</span>
            <span class="post-date" title="2023-02-01 21:14:33">2023/02/01</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/"
           data-tag="pytorch"
           data-author="" >
            <span class="post-title" title="pytorch冻结网络模型">pytorch冻结网络模型</span>
            <span class="post-date" title="2022-11-08 09:49:41">2022/11/08</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&Satellite/%E5%BC%80%E9%A2%98%E7%9B%B8%E5%85%B3/"
           data-tag="图像匹配"
           data-author="" >
            <span class="post-title" title="UAV和卫星图像配准思路">UAV和卫星图像配准思路</span>
            <span class="post-date" title="2022-11-08 09:49:41">2022/11/08</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/UAV&Satellite/%E8%B0%83%E7%A0%94/"
           data-tag="图像匹配"
           data-author="" >
            <span class="post-title" title="UAV和卫星图像配准论文阅读">UAV和卫星图像配准论文阅读</span>
            <span class="post-date" title="2022-11-08 09:49:41">2022/11/08</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/LoFTR/"
           data-tag="特征匹配"
           data-author="" >
            <span class="post-title" title="LoFTR代码">LoFTR代码</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E7%90%86%E8%A7%A3BN/"
           data-tag="batch norm"
           data-author="" >
            <span class="post-title" title="理解BN">理解BN</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/Low%20Dimensional%20Trajectory%20Hypothesis%20is%20True/"
           data-tag="test time adaptation"
           data-author="" >
            <span class="post-title" title="子空间论文阅读">子空间论文阅读</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/TENT/"
           data-tag="test time adaptation"
           data-author="" >
            <span class="post-title" title="TENT论文阅读">TENT论文阅读</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E5%BC%80%E9%A2%98/"
           data-tag="test time adaptation"
           data-author="" >
            <span class="post-title" title="TTA开题">TTA开题</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/test_time_adaptation/%E6%B3%9B%E8%AF%BB/"
           data-tag="test time adaptation"
           data-author="" >
            <span class="post-title" title="TTA论文泛读">TTA论文泛读</span>
            <span class="post-date" title="2022-11-07 09:49:41">2022/11/07</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
           data-tag="目标检测"
           data-author="" >
            <span class="post-title" title="目标检测基础知识">目标检测基础知识</span>
            <span class="post-date" title="2022-10-26 15:49:06">2022/10/26</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/Feature%20Matching/%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D/"
           data-tag="图像匹配"
           data-author="" >
            <span class="post-title" title="特征匹配论文">特征匹配论文</span>
            <span class="post-date" title="2022-04-10 16:52:31">2022/04/10</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2022/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/yolo/"
           data-tag="yolo"
           data-author="" >
            <span class="post-title" title="YOLO使用">YOLO使用</span>
            <span class="post-date" title="2022-01-01 13:23:06">2022/01/01</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/%E9%A3%9E%E6%9C%BA%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1(%E6%9D%A8%E4%B8%9A%E9%B9%8F-20220310203222)/"
           data-tag="位姿估计"
           data-author="" >
            <span class="post-title" title="飞机6D位姿估计">飞机6D位姿估计</span>
            <span class="post-date" title="2021-12-10 16:52:31">2021/12/10</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/"
           data-tag="SLAM"
           data-author="" >
            <span class="post-title" title="SLAM十四讲代码bug及解决">SLAM十四讲代码bug及解决</span>
            <span class="post-date" title="2021-11-24 18:50:44">2021/11/24</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/11/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E4%BA%8B%E4%BB%B6%E7%9B%B8%E6%9C%BA/%E8%B0%83%E7%A0%94/"
           data-tag="事件相机"
           data-author="" >
            <span class="post-title" title="事件相机调研">事件相机调研</span>
            <span class="post-date" title="2021-11-10 19:49:06">2021/11/10</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%A8%E5%8E%BB%E9%9B%BE/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%95%B4%E7%90%86/"
           data-tag="dehazing,haze removal"
           data-author="" >
            <span class="post-title" title="图像去雾去雨论文整理">图像去雾去雨论文整理</span>
            <span class="post-date" title="2021-10-22 12:00:00">2021/10/22</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/%E5%8D%AB%E6%98%9F%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"
           data-tag="位姿估计"
           data-author="" >
            <span class="post-title" title="卫星姿态估计调研">卫星姿态估计调研</span>
            <span class="post-date" title="2021-10-20 09:49:41">2021/10/20</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1%E5%9F%BA%E7%A1%80(%E6%9D%A8%E4%B8%9A%E9%B9%8F-20220310203222)/"
           data-tag="位姿估计"
           data-author="" >
            <span class="post-title" title="位姿估计基础及论文">位姿估计基础及论文</span>
            <span class="post-date" title="2021-10-20 09:49:41">2021/10/20</span>
        </a>
        
        
        <a  class="全部文章 软件使用 "
           href="/2021/10/08/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%85%B6%E4%BB%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他软件使用">其他软件使用</span>
            <span class="post-date" title="2021-10-08 09:49:41">2021/10/08</span>
        </a>
        
        
        <a  class="全部文章 软件使用 "
           href="/2021/09/23/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/ubuntu(%E6%9D%A8%E4%B8%9A%E9%B9%8F-20220829094535)/"
           data-tag="ubuntu"
           data-author="" >
            <span class="post-title" title="ubuntu相关">ubuntu相关</span>
            <span class="post-date" title="2021-09-23 10:29:44">2021/09/23</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%A8%E5%8E%BB%E9%9B%BE/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/"
           data-tag="dehazing,heze removal"
           data-author="" >
            <span class="post-title" title="图像去雾">图像去雾</span>
            <span class="post-date" title="2021-09-23 10:29:44">2021/09/23</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/HDLBits%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"
           data-tag="verilog,数电"
           data-author="" >
            <span class="post-title" title="HDLBits刷题笔记">HDLBits刷题笔记</span>
            <span class="post-date" title="2021-09-05 11:16:10">2021/09/05</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/08/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/ZYNQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag="ZYNQ,vivado"
           data-author="" >
            <span class="post-title" title="ZYNQ学习笔记">ZYNQ学习笔记</span>
            <span class="post-date" title="2021-08-04 19:03:34">2021/08/04</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/07/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/HLS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag="HLS"
           data-author="" >
            <span class="post-title" title="HLS学习笔记">HLS学习笔记</span>
            <span class="post-date" title="2021-07-30 10:15:16">2021/07/30</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/07/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/vivado2020-2%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"
           data-tag="vivado"
           data-author="" >
            <span class="post-title" title="vivado2020.2安装教程">vivado2020.2安装教程</span>
            <span class="post-date" title="2021-07-30 09:39:08">2021/07/30</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/07/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/%E3%80%90FPGA%E3%80%91%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"
           data-tag="图像处理"
           data-author="" >
            <span class="post-title" title="【FPGA】图像处理">【FPGA】图像处理</span>
            <span class="post-date" title="2021-07-23 14:52:46">2021/07/23</span>
        </a>
        
        
        <a  class="全部文章 FPGA "
           href="/2021/07/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/FPGA/verilog%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag="verilog,modelsim"
           data-author="" >
            <span class="post-title" title="verilog学习笔记">verilog学习笔记</span>
            <span class="post-date" title="2021-07-16 15:50:28">2021/07/16</span>
        </a>
        
        
        <a  class="全部文章 嵌入式和硬件 "
           href="/2021/03/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/%E3%80%90%E7%94%B5%E8%B5%9B%E3%80%91%E7%BA%BF%E8%B7%AF%E8%B4%9F%E8%BD%BD%E5%8F%8A%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B%E8%A3%85%E7%BD%AE/"
           data-tag="线路故障检测,自平衡电桥,正交解调，FPGA"
           data-author="" >
            <span class="post-title" title="【电赛】线路负载及故障检测装置">【电赛】线路负载及故障检测装置</span>
            <span class="post-date" title="2021-03-13 20:43:36">2021/03/13</span>
        </a>
        
        
        <a  class="全部文章 嵌入式和硬件 "
           href="/2021/03/12/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%92%8C%E7%A1%AC%E4%BB%B6/%E3%80%90%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E3%80%91%E5%9F%BA%E4%BA%8EAtlas-200-DK%E7%9A%84%E9%9A%9C%E7%A2%8D%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"
           data-tag="Atlas,深度学习,神经网络,障碍物识别,目标识别"
           data-author="" >
            <span class="post-title" title="【本科毕业设计】基于Atlas_200_DK的障碍物识别系统设计与实现">【本科毕业设计】基于Atlas_200_DK的障碍物识别系统设计与实现</span>
            <span class="post-date" title="2021-03-12 19:20:57">2021/03/12</span>
        </a>
        
        
        <a  class="全部文章 软件使用 "
           href="/2021/02/12/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%B8%B8%E7%94%A8hexo%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C/"
           data-tag="hexo指令"
           data-author="" >
            <span class="post-title" title="常用hexo博客操作">常用hexo博客操作</span>
            <span class="post-date" title="2021-02-12 13:14:45">2021/02/12</span>
        </a>
        
        
        <a  class="全部文章 计算机视觉 "
           href="/2021/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/%E5%8D%AB%E6%98%9F%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1review/"
           data-tag="位姿估计"
           data-author="" >
            <span class="post-title" title="卫星姿态估计综述">卫星姿态估计综述</span>
            <span class="post-date" title="2021-01-16 10:42:41">2021/01/16</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-cpp/动态规划" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">动态规划</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="CPP">CPP</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-04-03 09:24:07'>2023-02-01 21:14</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">动态规划基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">509. 斐波那契数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62.不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text">343. 整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96.不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-text">01背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%84"><span class="toc-text">二维dp数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E7%94%A8%E7%89%A9%E5%93%81%E5%8E%BB%E9%81%8D%E5%8E%86%E4%B8%8D%E5%90%8C%E9%87%8D%E9%87%8F%E7%9A%84%E8%83%8C%E5%8C%85"><span class="toc-text">一维dp数组——用物品去遍历不同重量的背包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-text">1049.最后一块石头的重量II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">494.目标和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85"><span class="toc-text">474.一和零——二维背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">动态规划：完全背包理论基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II"><span class="toc-text">518.零钱兑换II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-text">377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279.完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-text">139.单词拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-text">多重背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198.打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII"><span class="toc-text">213.打家劫舍II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-text">337.打家劫舍 III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-text">122.买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII"><span class="toc-text">123.买卖股票的最佳时机III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV"><span class="toc-text">188.买卖股票的最佳时机IV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-text">309.最佳买卖股票时机含冷冻期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-text">714.买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">300.最长递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-text">674. 最长连续递增序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">718. 最长重复子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1143.最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">53. 最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">392.判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">115.不同的子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">72. 编辑距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">647. 回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">516.最长回文子序列</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="动态规划基础知识"><a href="#动态规划基础知识" class="headerlink" title="动态规划基础知识"></a>动态规划基础知识</h2><p>动态规划，Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>
<p>动规是由前一个状态推导出来的，而贪心是局部直接选最优的</p>
<p>动规五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接(opens new window)</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p>
<p>我的：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        return fib(n-1) + fib(n-2);
    }
};
</code></pre>
<p>题解动规：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
</code></pre>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接(opens new window)</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>用递归和回溯都超出时间限制</strong></p>
<p>我的代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        vector<int> dp(n+1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];//关键
        }
        return dp[n];
    }
};
</code></pre>
<p>还可以用完全背包，求排列（先遍历背包，再遍历物体）</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接(opens new window)</a></p>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);
        dp[0] = 0; // 默认第一步都是不花费体力的
        dp[1] = 0;
        for (int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.size()];
    }
};
</code></pre>
<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">力扣题目链接(opens new window)</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        //初始化，最好吧初始化和逻辑处理分开写，比较明了
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;

        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
</code></pre>
<h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接(opens new window)</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>我的代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(); //！！记住这里的方式
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));

        /* 这块的判断写复杂了
        int sig = 1;
        for (int i = 0; i < m; i++) {
            if(obstacleGrid[i][0] == 1) {
                dp[i][0] = 0;
                sig = 0;
            }
            if(sig) dp[i][0] = 1;
        }
        sig = 1;
        for (int j = 0; j < n; j++) {
            if(obstacleGrid[0][j] == 1) {
                dp[0][j] = 0;
                sig = 0;
            }
            if(sig) dp[0][j] = 1;
        }
        */
        //题解的初始化判断
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;

        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++){
                if(obstacleGrid[i][j] == 1) dp[i][j] = 0;
                else dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
</code></pre>
<h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">力扣题目链接(opens new window)</a></p>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>思路：遍历，比较<code>dp[i - j] * j, (i - j) * j</code>大小，即比较拆成两个和拆成两个以上的乘积大小。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for (int j = 2; j < i; j++){
                dp[i] = max(dp[i],max(dp[i - j] * j, (i - j) * j));
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数 n，求以 1 … n 为节点组成的<strong>二叉搜索树</strong>有多少种？</p>
<p>思路：</p>
<p><img src="/2023/02/01/cpp/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230310111953290.png" alt="image-20230310111953290"> </p>
<p>dp[3] = dp[0]dp[2] + dp[1]dp[1]+dp[2]dp[0];</p>
<p>节点的数值其实关系不大，只要每个值不一样就行；</p>
<p>dp[i] += dp[j - 1] * dp[i - j];</p>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有N件物品和⼀个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p>
<p>例：</p>
<p>背包最⼤重量为4。<br>              重量    价值<br>物品0      1          15<br>物品1      3          20<br>物品2      4          30</p>
<p>思路：</p>
<h4 id="二维dp数组"><a href="#二维dp数组" class="headerlink" title="二维dp数组"></a>二维dp数组</h4><p>对于背包问题，有⼀种写法， 是使⽤<strong>⼆维数组</strong>，即<code>dp[i] [j]</code> 表⽰从下标为<code>[0-i]</code>的物品⾥任意取，放进容量为<code>j</code>的背包，价值总和最⼤是多少。</p>
<p>不放物品i:  <code>dp[i-1] [j]</code></p>
<p>放物品i:<code>dp[i-1] * [j - weight[ i ]] + value[ i ]</code></p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//测试代码
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}
</code></pre>
<h4 id="一维dp数组——用物品去遍历不同重量的背包"><a href="#一维dp数组——用物品去遍历不同重量的背包" class="headerlink" title="一维dp数组——用物品去遍历不同重量的背包"></a>一维dp数组——用物品去遍历不同重量的背包</h4><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[ i-1 ] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p><strong>所以递归公式为：</strong></p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</code></pre>
<p>一维dp数组<strong>遍历顺序</strong>比较固定：</p>
<ul>
<li>物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历</li>
</ul>
<p>注意：</p>
<ul>
<li>若先遍历重量，则每个重量的背包只放了一个物品</li>
<li>若正序遍历重量，则存在物品被放置多次的现象</li>
</ul>
<p>代码如下：</p>
<pre class=" language-lang-text"><code class="language-lang-text">for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
</code></pre>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}
</code></pre>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接(opens new window)</a></p>
<p>题目难易：中等</p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意: 每个数组中的元素不会超过 100， 数组的大小不会超过 200</p>
<p>示例 1:</p>
<ul>
<li>输入: [1, 5, 11, 5]</li>
<li>输出: true</li>
<li>解释: 数组可以分割成 [1, 5, 5] 和 [11].</li>
</ul>
<p>转换：</p>
<p>背包最⼤重量为11。<br>              重量    价值<br>物品0      1          1<br>物品1      5          5<br>物品2     11        11<br>物品3      5          5</p>
<p>思路：</p>
<p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为target = sum / 2</li>
<li>背包要放入的商品（集合里的元素）<strong>重量为 元素的数值</strong>，<strong>价值也为元素的数值</strong></li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。即寻找dp[target] == target</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>我的：</p>
<p>背包能放的最大价值（等价于最大重量），就是刚好放满</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[j]容量为j的背包，所背的物品价值可以最大为dp[j]。
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
                if (dp[target] == target) return true;
            }
        }
        // // 集合中的元素正好可以凑成总和target
        // if (dp[target] == target) return true;
        return false;
    }
};
</code></pre>
<h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接(opens new window)</a></p>
<p>题目难度：中等</p>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；</p>
<p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
<p>示例：</p>
<ul>
<li>输入：[2,7,4,1,8,1]</li>
<li>输出：1</li>
</ul>
<p>解释：</p>
<ul>
<li><p>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</p>
</li>
<li><p>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</p>
</li>
<li><p>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</p>
</li>
<li><p>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p>
</li>
</ul>
<p>思路：</p>
<p>本题其实就是<strong>尽量</strong>让石头<strong>分成重量相同的两堆</strong>，相撞之后剩下的石头最小</p>
<ol>
<li><p>dp数组含义：dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背的最大重量</p>
</li>
<li><p>递推公式：<strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p>
</li>
<li>初始化： dp的size初始化为最大重量，value初始化为0；<code>vector&lt;int&gt; dp(15001, 0);</code></li>
<li>确定遍历顺序：同01背包</li>
<li>举例推导dp数组</li>
</ol>
<p>最后dp[target]里是容量为target的背包所能背的最大重量。</p>
<p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。<strong>target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p>
<p>所以<code>return sum - dp[target] - dp[target];</code></p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001,0);
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        }
        int target = sum / 2;
        //先遍历物品，再遍历容量
        for(int i = 0; i < stones.size(); i++){
            for(int j = target; j >= stones[i]; j--){
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
</code></pre>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">力扣题目链接(opens new window)</a></p>
<p>难度：中等</p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<ul>
<li>输入：nums: [1, 1, 1, 1, 1], S: 3</li>
<li>输出：5</li>
</ul>
<p>解释：</p>
<ul>
<li>-1+1+1+1+1 = 3</li>
<li>+1-1+1+1+1 = 3</li>
<li>+1+1-1+1+1 = 3</li>
<li>+1+1+1-1+1 = 3</li>
<li>+1+1+1+1-1 = 3</li>
</ul>
<p>思路：</p>
<p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 x - (sum - x) = target</p>
<p>x = (target + sum) / 2</p>
<ol>
<li>dp数组含义：dp[j]表示填满容积为j的背包，有多少种组合</li>
<li></li>
</ol>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
</code></pre>
<p>记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">dp[j] += dp[j - nums[i]];
</code></pre>
<h2 id="474-一和零——二维背包"><a href="#474-一和零——二维背包" class="headerlink" title="474.一和零——二维背包"></a>474.一和零——二维背包</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接(opens new window)</a></p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>示例 ：</p>
<ul>
<li>输入：strs = [“10”, “0”, “1”], m = 1, n = 1</li>
<li>输出：2</li>
<li>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</li>
</ul>
<p><strong>思路：</strong></p>
<p>二维背包</p>
<ol>
<li>dp：<strong>最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]</strong>。</li>
<li>递推公式：dp [i] [j] 可以由前一个strs里的字符串推导出来，当前str里的字符串有zeroNum个0，oneNum个1（其实就相当于重量）。dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</li>
<li>初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</li>
<li><strong>外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历</strong></li>
</ol>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
</code></pre>
<h2 id="动态规划：完全背包理论基础"><a href="#动态规划：完全背包理论基础" class="headerlink" title="动态规划：完全背包理论基础"></a>动态规划：完全背包理论基础</h2><p>完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">// 先遍历物品，再遍历背包（这个顺序可以调换，但是有区别）
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
</code></pre>
<h2 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a>518.零钱兑换II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">力扣题目链接(opens new window)</a></p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>示例 1:</p>
<ul>
<li>输入: amount = 5, coins = [1, 2, 5]</li>
<li>输出: 4</li>
</ul>
<p>解释: 有四种方式可以凑成总金额:</p>
<ul>
<li>5=5</li>
<li>5=2+2+1</li>
<li>5=2+1+1+1</li>
<li>5=1+1+1+1+1</li>
</ul>
<p>思路：</p>
<p>背包容量为5，要刚好装满；硬币面额相当于物体重量</p>
<ol>
<li>dp[j]：背包容量为j，能装满的<strong>最大方式数</strong></li>
<li>递推公式   dp[j] += dp[j-coins[i]]</li>
<li>初始化</li>
<li>遍历顺序</li>
</ol>
<p>我的：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1,0);
        dp[0] = 1;
        for(int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j <= amount; j++){
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
</code></pre>
<p><strong>注意：</strong></p>
<p>本题要求凑成总和的<strong>组合数</strong>，元素之间明确要求<strong>没有顺序</strong>。纯完全背包是能凑成总和就行，不用管怎么凑的。</p>
<p>所以本题要 ：<strong>先遍历物品再遍历容量，计算的是组合数</strong></p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
</code></pre>
<p>而先遍历容量再遍历物体，计算的是<strong>排列数</strong></p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
</code></pre>
<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">力扣题目链接(opens new window)</a></p>
<p>难度：中等</p>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<ul>
<li>nums = [1, 2, 3]</li>
<li>target = 4</li>
</ul>
<p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p>
<p>请注意，顺序不同的序列被视作不同的组合。</p>
<p>因此输出为 7</p>
<p><strong>思路：</strong></p>
<p>多重背包问题，求排列数</p>
<ol>
<li>dp[j]  :  刚好装满容量为j的背包的最大排列数</li>
<li>dp[j] += dp[j - nums[i]]</li>
<li>dp[0] = 1</li>
<li>先遍历背包，再遍历物品</li>
</ol>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for(int j = 0; j <= target; j++){
            for(int i = 0; i < nums.size(); i++){
// C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[j] < INT_MAX - dp[j - nums[i]]。这里省去了。ps：数量类型改成longlong还是会超
                if (j - nums[i] >= 0) dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
};
</code></pre>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">力扣题目链接(opens new window)</a></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<ul>
<li>输入：coins = [1, 2, 5], amount = 11</li>
<li>输出：3</li>
<li>解释：11 = 5 + 5 + 1</li>
</ul>
<p>思路：</p>
<p>完全背包，求<strong>最少</strong>硬币数</p>
<p><strong>本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓</strong></p>
<p>dp[j] 装满背包容量为j的最少硬币数 </p>
<p>凑足总金额为0所需钱币的个数一定是0，那么<strong>dp[0] = 0;</strong> (为什么不是和求最大数量一样dp[0]=1)</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过,因为+1会溢出，而且最小值还是不变
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
</code></pre>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">力扣题目链接(opens new window)</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：</p>
<ul>
<li>输入：n = 12</li>
<li>输出：3</li>
<li>解释：12 = 4 + 4 + 4</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i <= n; i++){ // i=0也可以，但是没有意义，不会改变结果
            for(int j = i*i; j <= n; j++){
                if(dp[j - i*i] != INT_MAX){
                    dp[j] = min(dp[j], dp[j - i*i] + 1);
                }
            }
        }
        //if (dp[n] == INT_MAX) return -1; 由于该问题一定有解，所以加不加这个都行
        return dp[n];
    }
};
</code></pre>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">力扣题目链接(opens new window)</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。</p>
<p>你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<ul>
<li>输入: s = “leetcode”, wordDict = [“leet”, “code”]</li>
<li>输出: true</li>
<li>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</li>
</ul>
<p>思路：</p>
<p>完全背包求排列，先遍历背包再遍历物品      单词就是物品，字符串s就是背包</p>
<p>dp[j]: 长度为j的背包s刚好能被单词装满</p>
<p>题解：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set <string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j] == true) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
</code></pre>
<p>or 可以把unordered_set改成用find()函数</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>每种物品数量有限(1&lt;= 数量 &lt; 无穷)</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    vector<int> dp(bagWeight + 1, 0);


    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数 ！！！
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
        // 打印一下dp数组
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;
}
int main() {
    test_multi_pack();
}
</code></pre>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">力扣题目链接(opens new window)</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<ul>
<li>示例 1：</li>
<li>输入：[1,2,3,1]</li>
<li>输出：4</li>
</ul>
<p>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>思路：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p>
<ol>
<li>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</li>
<li>dp[0] = nums[0]   dp[1]  = max(nums[1], nums[0])</li>
<li>从前向后遍历</li>
</ol>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for (int i = 2; i < nums.size(); i++){
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
</code></pre>
<h2 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">力扣题目链接</a></p>
<p>相对上一题添加条件： 房间成环，即第一个房间和最后一个房间挨着</p>
<p>思路:</p>
<p>考虑两种情况：考虑包含首元素，不包含尾元素；  考虑包含尾元素，不包含首元素</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
</code></pre>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">力扣题目链接</a></p>
<p>这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>思路：</p>
<p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p>关键是要讨论当前节点抢还是不抢。如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子</p>
<ol>
<li><p>确定递归函数的参数和返回值</p>
<p> 参数为当前节点，代码如下：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp"> vector<int> robTree(TreeNode* cur) {
</code></pre>
<p> 其实这里的返回数组就是dp数组。</p>
<p> 所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p>
</li>
<li><p>终止条件<code>if (cur == NULL) return vector&lt;int&gt;{0, 0};</code></p>
</li>
<li><p>确定遍历顺序</p>
<p> 首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p>
<p> 通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p> 通过递归右节点，得到右节点偷与不偷的金钱。</p>
<p> 代码如下：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp"> // 下标0：不偷，下标1：偷
 vector<int> left = robTree(cur->left); // 左
 vector<int> right = robTree(cur->right); // 右
 // 中
</code></pre>
</li>
<li><p>确定单层递归的逻辑</p>
<p> 当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp"> int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷
 int val1 = cur->val + left[0] + right[0]; //偷
 return {val0,val1};
</code></pre>
</li>
</ol>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0],result[1]);
    }

    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        int val0 = max(left[0], left[1]) + max(right[0], right[1]); //不偷
        int val1 = cur->val + left[0] + right[0]; //偷
        return {val0,val1};
    }
};
</code></pre>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>思路：</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p> dp[i] [0] 表示第i天持有股票所得最多现金 </p>
<p> dp[i] [1] 表示第i天不持有股票所得最多现金</p>
</li>
<li><p>确定递推公式</p>
<p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</li>
<li><p>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</p>
<p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</p>
<p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p>
</li>
<li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p>
</li>
<li><p>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p>
<p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p>
</li>
</ul>
</li>
<li><p>初始化</p>
<p> dp[0] [0]  = - prices[0]</p>
<p> dp[0] [1] = 0</p>
</li>
<li><p>遍历顺序从前到后</p>
<p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
</li>
</ol>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 1) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2)); //注意vector<int>(2) ！
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.size()-1][1];
    }
};
</code></pre>
<p>用滚动数组优化，节省空间复杂度：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
</code></pre>
<h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以<strong>尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>思路:</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p> dp[i] [0] 表示第i天持有股票所得最多现金 </p>
<p> dp[i] [1] 表示第i天不持有股票所得最多现金</p>
</li>
<li><p>确定递推公式</p>
<p> 如果第i天持有股票即dp[i] [0]， 那么可以由两个状态推出来</p>
<ul>
<li><p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1] [0]</p>
</li>
<li><p>第i-1天不持有股票，第i天买入股票，<strong>所得现金就是买入今天股票花的钱加上之前赚的钱</strong>：    </p>
<p>  <strong>dp[i - 1] [1]</strong> - prices[i]</p>
<p>那么dp[i] [0]应该选所得现金最大的，所以dp[i] [0] = max(dp[i - 1] [0], <strong>dp[i - 1] [1]</strong> - prices[i]); </p>
<p><strong>！！！加粗部分为和上一题唯一的不同</strong></p>
<p>如果第i天不持有股票即dp[i] [1]， 也可以由两个状态推出来</p>
</li>
<li><p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1] [1]</p>
</li>
<li><p>第i-1天持有股票，第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1] [0]</p>
<p>同样dp[i] [1]取最大的，dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</p>
</li>
</ul>
</li>
<li><p>初始化</p>
<p> dp[0] [0]  = - prices[0]</p>
<p> dp[0] [1] = 0</p>
</li>
<li><p>遍历顺序从前到后</p>
<p> dp[5] [1]就是最终结果。<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
</li>
</ol>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 1) return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]-prices[i]); // 唯一不同
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[prices.size()-1][1];
    }
};
</code></pre>
<h2 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">力扣题目链接(opens new window)</a></p>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。</p>
<p>思路：</p>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<p> 一天一共就有五个状态，</p>
<ol>
<li>没有操作 （其实我们也可以不设置这个状态）</li>
<li>第一次持有股票</li>
<li>第一次不持有股票</li>
<li>第二次持有股票</li>
<li><p>第二次不持有股票</p>
<p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j所剩最大现金。</p>
</li>
</ol>
</li>
<li><p>确定递推公式</p>
</li>
</ol>
<p>达到dp[i] [1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i] [1] = dp[i-1] [0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] = dp[i - 1] [1]</li>
</ul>
<p>一定是选最大的，所以 dp[i] [1] = max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if(len == 1) return 0;
        vector<vector<int>> dp(len,vector<int>(5));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i = 1; i < len; i++){
            dp[i][0] = dp[i - 1][0]; //这个其实一直是0
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); //第一次不买or买
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); //第一次不卖or卖
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[len-1][4];
    }
};
</code></pre>
<h2 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">力扣题目链接</a></p>
<p>最多可以完成K笔交易</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
</code></pre>
<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例:</p>
<ul>
<li>输入: [1,2,3,0,2]</li>
<li>输出: 3</li>
<li>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li>
</ul>
<p>思路：</p>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<p> dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p>
<p> 具体可以区分出如下四个状态：</p>
</li>
</ol>
<ul>
<li>状态0：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li>
<li>不持有股票状态，这里就有两种卖出股票状态<ul>
<li>状态1：结束冷冻期的状态（前一天是冷冻期。或者是前几天是冷冻期）</li>
<li>状态2：今天卖出股票</li>
</ul>
</li>
<li>状态3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));
    }
};
</code></pre>
<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>思路：</p>
<p>dp[i] [j]</p>
<p>0: 持有股票 dp[i] [0] :  dp [i-1] [0]     dp[i-1] [1] - prices[i] </p>
<p>1：不持有股票 dp[i] [1]: dp[i-1] [1]     dp[i-1] [0] + prices[i] - fee  卖出的时候再扣手续费</p>
<p>我的代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp [i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]- fee);
        }
        return dp[n-1][1];//题解这里用的max(dp[n - 1][0], dp[n - 1][1]);感觉不太对，一定是不持股的时候钱多；
    }
};
</code></pre>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">力扣题目链接(opens new window)</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums = [10,9,2,5,3,7,101,18]</li>
<li>输出：4</li>
<li>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</li>
</ul>
<p><strong>子序列问题是动态规划的一个重要系列</strong></p>
<p>思路：</p>
<ol>
<li><p>dp[i]的定义</p>
<p> dp[i]表示以<strong>nums[i]结尾</strong>的最长递增子序列的长度</p>
<p> 因为比较递增，那么一定是比较最后一个数字的大小</p>
</li>
<li><p>状态转移方程</p>
<p> 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p> 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p>
</li>
<li><p>dp[i]的初始化</p>
<p> 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p>
</li>
<li><p>确定遍历顺序</p>
<p> 从前向后遍历。</p>
</li>
</ol>
<p>代码：</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            result = max(result, dp[i]); // 取长的子序列
        }
        return result;
    }
};
</code></pre>
<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">力扣题目链接(opens new window)</a></p>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>示例 1：</p>
<ul>
<li>输入：nums = [1,3,5,4,7]</li>
<li>输出：3</li>
<li>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int n = nums.size();
        int result = 1;
        vector<int> dp(n, 1);
        for(int i = 1; i < n; i++){
            if(nums[i] > nums[i - 1]){
                dp[i] = dp[i-1] + 1;
            }
            result = max(result,dp[i]);
        }
        return result;
    }
};
</code></pre>
<h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">力扣题目链接(opens new window)</a></p>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<p>输入：</p>
<ul>
<li>A: [1,2,3,2,1]</li>
<li>B: [3,2,1,4,7]</li>
<li>输出：3</li>
<li>解释：长度最长的公共子数组是 [3, 2, 1] 。</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] ：以下标i为结尾的A，和以下标j为结尾的B，最长重复子数组长度为dp[i][j]
//if(nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
//dp[0][j] 
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        int result = 0;
        vector<vector<int>> dp(n1,vector<int>(n2,0));
        // 要对第一行，第一列经行初始化
        for (int i = 0; i < nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;
        for (int j = 0; j < nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1;

        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                if(nums1[i] == nums2[j] && i > 0 && j >0) dp[i][j] = dp[i-1][j-1] + 1;
                result = max(result,dp[i][j]);
            }
        }

        return result;

    }
};
</code></pre>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">力扣题目链接(opens new window)</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">// dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
//if(text1[i-1] == text2[i-1])  dp[i][j] = dp[i-1][j-1] + 1;
//else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size();
        int n2 = text2.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n1][n2];
    }
};
</code></pre>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);
        dp[0] = nums[0];
        int result = dp[0];

        for(int i = 1; i < n; i++){
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]); 
        }
        return result;
    }
};
</code></pre>
<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">力扣题目链接(opens new window)</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1： 输入：s = “abc”, t = “ahbgdc” 输出：true</p>
<p>示例 2： 输入：s = “axc”, t = “ahbgdc” 输出：false</p>
<p>可以发现和 <a target="_blank" rel="noopener" href="https://programmercarl.com/1143.最长公共子序列.html">1143.最长公共子序列 (opens new window)</a>的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n1 = s.size();
        int n2 = t.size();
        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[n1][n2] == n1;
    }
};
</code></pre>
<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
class Solution {
public:
    int numDistinct(string s, string t) {
        int n1 = s.size();
        int n2 = t.size();
        vector<vector<uint64_t>> dp(n1+1,vector<uint64_t> (n2+1,0));
        for (int i = 0; i <= n1; i++) dp[i][0] = 1;
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                // dp[i-1][j] 不用 s的最后一位 来匹配
                // dp[i-1][j-1]表示s和t最后一位已经匹配，
                if(s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else dp[i][j] = dp[i-1][j];
            }
        }
        return dp[n1][n2];   
    }
};
</code></pre>
<h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">力扣题目链接(opens new window)</a></p>
<p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<ul>
<li>输入: “sea”, “eat”</li>
<li>输出: 2</li>
<li>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//求最长公共子序列
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1 + 1, vector<int> (n2 + 1, 0));
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            } 
        }
        return n1+n2-2*dp[n1][n2];
    }
};
</code></pre>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">力扣题目链接(opens new window)</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 长度为i的word1 转换成 长度为j的word2 所使用的最少操作数
// 插：word2删1  删：word1删1  换：都删1

class Solution {
public:
    int minDistance(string word1, string word2) {
        int l1 = word1.size();
        int l2 = word2.size();
        vector<vector<int>> dp(l1 + 1, vector<int>(l2 + 1, 0));
        for(int i = 0; i <= l1; i++) dp[i][0] = i;
        for(int j = 0; j <= l2; j++) dp[0][j] = j;

        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];
                else {
                    int n1 = dp[i-1][j] + 1;
                    int n2 = dp[i][j-1] + 1;
                    int n3 = dp[i-1][j-1] + 1;
                    dp[i][j] = min(min(n1,n2),n3);
                }
            }
        }
        return dp[l1][l2];
    }
};
</code></pre>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<ul>
<li>输入：”abc”</li>
<li>输出：3</li>
<li>解释：三个回文子串: “a”, “b”, “c”</li>
</ul>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
//dp[i + 1][j - 1] 在 dp[i][j]的左下角 ,要从左下开始遍历，顺序是从下到上，从左到右。
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        int result = 0;
        vector<vector<int>> dp(n,vector<int>(n,0));
        // dp[0][0] = 1;
        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] != s[j]) dp[i][j] = 0;
                else{
                    if(i == j) {
                        dp[i][j] = 1;
                        result++;
                    }
                    else if(j-i == 1) {
                        dp[i][j] = 1;
                        result++;
                    }
                    else {
                        if(dp[i+1][j-1]){
                            dp[i][j] = 1;
                            result++;
                        }
                    }
                }
            }
        }
        return result;
    }
};
</code></pre>
<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
<pre class=" language-lang-cpp"><code class="language-lang-cpp">//dp[i][j] 表示s[i,j] 最长的回文子串
//画图理解  i表示行，j表示列
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int result = 0;
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i = n-1; i >= 0; i--){
            for(int j = i; j < n; j++){
                if(s[i] == s[j]) {
                    if(i == j) dp[i][j] = 1;
                    else if(j-i == 1) dp[i][j] = 2;
                    else dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。 </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2023 Youngyep
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 562px;
    }
    .nav.fullscreen {
        margin-left: -562px;
    }
    .nav-left {
        width: 140px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 512px;
        }
        .nav.fullscreen {
            margin-left: -512px;
        }
        .nav-left {
            width: 120px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 512px;
            margin-left: -512px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
